<?php                                                         ?><?php #PHK M M1.4.0        V1.4.0        FS482315      PO241         SSO179412      STO180029      FTO206866      SIO482315      CRC1bd860e0 PCO1773        PCS177639      ?><?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

if (!class_exists('PHK',0))
	{
	//-- When extension is not present, the first package loads the PHP
	//-- ('slow') runtime code.

	$_phk_fp=fopen(__FILE__,'rb');
	$_phk_buf=fread($_phk_fp,241);
	fseek($_phk_fp,(int)(substr($_phk_buf,212,11)),SEEK_SET);
	$_phk_size=(int)(substr($_phk_buf,227,11));

	$_phk_code='';
	while (strlen($_phk_code) < $_phk_size)
		$_phk_code .=fread($_phk_fp,$_phk_size-strlen($_phk_code));

	fclose($_phk_fp);

	eval($_phk_code);

	unset($_phk_code);
	unset($_phk_fp);
	unset($_phk_buf);
	unset($_phk_size);
	}

//------

$_phk_cmd=null;
$_phk_ret=0;

PHK::prolog(__FILE__,$_phk_cmd,$_phk_ret);

eval($_phk_cmd);

//var_dump($_phk_cmd);
//var_dump($_phk_ret);

return $_phk_ret;
 __halt_compiler(); ?>ÿÿÿÿ
//=============================================================================
//
// Copyright Francois Laupretre <automap@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The Automap runtime code
*
* @copyright Francois Laupretre <automap@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category Automap
* @package Automap
*/
//===========================================================================

if (!class_exists('Automap',false)) 
{
//------------------------------------------
/**
* Automap runtime class
*
* This class allows to autoload PHP scripts and extensions by extension,
* constant, class, or function name.
*
* @package Automap
*/

class Automap
{
const VERSION='1.1.0';

const MAGIC="AUTOMAP  M\024\x8\6\3";// Magic value for map files (offset 0)

//---------

const T_FUNCTION='F';
const T_CONSTANT='C';
const T_CLASS='L';
const T_EXTENSION='E';

const F_SCRIPT='S';
const F_EXTENSION='X';
const F_PACKAGE='P';

private static $type_strings=array(
	self::T_FUNCTION	=> 'function',
	self::T_CONSTANT	=> 'constant',
	self::T_CLASS		=> 'class',
	self::T_EXTENSION	=> 'extension',
	self::F_SCRIPT		=> 'script',
	self::F_EXTENSION	=> 'extension file',
	self::F_PACKAGE		=> 'package'
	);

private static $failure_handlers=array();

private static $success_handlers=array();

private static $support_constant_autoload; // whether the engine is able to
private static $support_function_autoload; // autoload functions/constants

//-- Load flags

// Reserved for future use

//---------

private static $automaps;	// Key=mnt ; Value=Automap instance

private static $mount_order; // Key=numeric(load order) ; Value=instance

//============ Utilities (please keep in sync with PHK_Util) ============

private static function is_web()
{
return (php_sapi_name()!='cli');
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

private static function path_unique_id($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//================== Map manager (static methods) =======================

public static function init()	// Unpublished - Internal use only
{
self::$automaps=array();
self::$mount_order=array();

// Determines if function/constant autoloading is supported

$f=new ReflectionFunction('function_exists');
self::$support_function_autoload=($f->getNumberOfParameters()==2);

$f=new ReflectionFunction('defined');
self::$support_constant_autoload=($f->getNumberOfParameters()==2);
}

//-------- User handlers -----------

public static function register_failure_handler($callable)
{
self::$failure_handlers[]=$callable;
}

//--------

public static function register_success_handler($callable)
{
self::$success_handlers[]=$callable;
}

//-------- Key management -----------

// Combines a type and a symbol in a 'key'. The resulting string can be used
// as a key or a value with the appropriate prefix in an automap.

public static function key($type,$symbol)
{
// Extension names are case insensitive

if (($type==self::T_EXTENSION)
	||($type==self::T_FUNCTION)
	||($type==self::T_CLASS)) $symbol=strtolower($symbol);

return $type.$symbol;
}

//---------

public static function get_type_from_key($key)
{
if (strlen($key) <= 1) throw new Exception('Invalid key');

return $key{0};
}

//---------
// Extracts the symbol from a key. If the key contains
// a '|' character, ignores everything from this char.

public static function get_symbol_from_key($key)
{
if (strlen($key) <= 1) throw new Exception('Invalid key');

return substr($key,1,strcspn($key,'|',1));
}

//---------

public static function get_type_string($type)
{
if (!isset(self::$type_strings[$type]))
	throw new Exception("$type: Invalid type");

return self::$type_strings[$type];
}

//---------

public static function string_to_type($string)
{
$type=array_search($string,self::$type_strings,true);

if ($type===false) throw new Exception("$type: Invalid type");

return $type;
}

//-------- Map mounting/unmounting -----------

/**
* Checks if a mount point is valid (if it corresponds to a currently mounted
* package)
*
* @param string $mnt Mount point to check
* @return boolean
*/

public static function is_mounted($mnt)
{
return isset(self::$automaps[$mnt]);
}

//-----
/**
* Same as is_mounted but throws an exception is the mount point is invalid.
*
* Returns the mount point so that it can be embedded in a call string.
*
* @param string $mnt Mount point to check
* @return string mount point (not modified)
* @throws Exception if mount point is invalid
*/

public static function validate($mnt)
{
if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point');

return $mnt;
}

//-----
/**
* Returns the Automap object corresponding to a given mount point
*
* @param string $mnt Mount point
* @return Automap instance
* @throws Exception if mount point is invalid
*/

public static function instance($mnt)
{
self::validate($mnt);

return self::$automaps[$mnt];
}

//-----
/**
* Returns the list of the defined mount points.
*
* @return array
*/

public static function mnt_list()
{
return array_keys(self::$automaps);
}

//---------
/**
* Given a file path, tries to determine if it is currently mounted. If it is
* the case, the corresponding mount point is returned. If not, an exception is
* thrown.
*
* @param string $path Path of an automap file
* @return the corresponding mount point
* @throws Exception if the file is not currently mounted
*/

public static function path_to_mnt($path)
{
$dummy=null;

$mnt=self::path_unique_id('m',$path,$dummy);

if (self::is_mounted($mnt)) return $mnt;

throw new Exception($path.': path is not mounted');
}

//---------
/**
* Mount an automap and returns the new (or previous, if already loaded)
* mount point.
*
* @param string $path The path of an existing automap file
* @param string $base_dir The base directory to use as a prefix (with trailing
*				separator).
* @param int $flags Or-ed combination of mount flags.
* @param string $mnt The mount point to use. Reserved for stream wrappers.
*					 Should be null for plain files.
* @return string the mount point
*/

public static function mount($path,$base_dir=null,$mnt=null,$flags=0)
{
try
{
if (is_null($mnt))
	{
	$dummy=null;
	$mnt=self::path_unique_id('m',$path,$dummy);
	}

if (self::is_mounted($mnt))
	{
	self::instance($mnt)->mnt_count++;
	return $mnt;
	}

if (is_null($base_dir))
	{
	$base_dir=dirname($path);
	if (($base_dir!=='/') && ($base_dir!=='\\'))
		$base_dir .= DIRECTORY_SEPARATOR;
	}

self::$mount_order[]
	=self::$automaps[$mnt]=new self($path,$base_dir,$mnt,$flags);
}
catch (Exception $e)
	{
	if (isset($mnt) && self::is_mounted($mnt)) unset(self::$automaps[$mnt]);
	throw new Exception($path.': Cannot mount - '.$e->getMessage());
	}

return $mnt;
}

//---------------------------------
/**
* Umounts a mounted map.
*
* We dont use __destruct because :
*	1. We don't want this to be called on script shutdown
*	2. Exceptions cannot be caught when sent from a destructor.
*
* Accepts to remove a non registered mount point without error
*
* @param string $mnt The mount point to umount
*/

public static function umount($mnt)
{
if (self::is_mounted($mnt))
	{
	$map=self::instance($mnt);
	if ((--$map->mnt_count) > 0) return;
	
	foreach (self::$mount_order as $order => $obj)
		{
		if ($obj===$map) self::$mount_order[$order]=null;
		}
	unset(self::$automaps[$mnt]);
	}
}

//-------- Symbol resolution -----------

private static function symbol_is_defined($type,$symbol)
{
switch($type)
	{
	case self::T_CONSTANT:	return (self::$support_constant_autoload ?
		defined($symbol,false) : defined($symbol));

	case self::T_FUNCTION:	return (self::$support_function_autoload ?
		function_exists($symbol,false) : function_exists($symbol));

	case self::T_CLASS:		return class_exists($symbol,false)
								|| interface_exists($symbol,false);

	case self::T_EXTENSION:	return extension_loaded($symbol);
	}
}

//---------
// The autoload handler, the default type is 'class', hoping that future
// versions of PHP support function and constant autoloading.

public static function autoload_hook($symbol,$type=self::T_CLASS)
{
self::get_symbol($type,$symbol,true,false);
}

//---------
// resolve a symbol, i.e. load what needs to be loaded for the symbol to be
// defined. Returns true on success / false if unable to resolve symbol.

private static function get_symbol($type,$symbol,$autoload=false
	,$exception=false)
{
//echo "get_symbol(".self::get_type_string($type).",$symbol)\n";//TRACE

if (!$autoload)
	{
	if (self::symbol_is_defined($type,$symbol)) return true;
	}

$key=self::key($type,$symbol);
foreach(array_reverse(self::$mount_order) as $map)
	{
	if ((!is_null($map)) && $map->resolve_key($key)) return true;
	}

foreach (self::$failure_handlers as $callable) $callable($key);

if ($exception) throw new Exception('Automap: Unknown '
	.self::get_type_string($type).': '.$symbol);

return false;
}

//---------

public static function get_function($symbol)
	{ return self::get_symbol(self::T_FUNCTION,$symbol,false,false); }

public static function get_constant($symbol)
	{ return self::get_symbol(self::T_CONSTANT,$symbol,false,false); }

public static function get_class($symbol)
	{ return self::get_symbol(self::T_CLASS,$symbol,false,false); }

public static function get_extension($symbol)
	{ return self::get_symbol(self::T_EXTENSION,$symbol,false,false); }

//---------

public static function require_function($symbol)
	{ return self::get_symbol(self::T_FUNCTION,$symbol,false,true); }

public static function require_constant($symbol)
	{ return self::get_symbol(self::T_CONSTANT,$symbol,false,true); }

public static function require_class($symbol)
	{ return self::get_symbol(self::T_CLASS,$symbol,false,true); }

public static function require_extension($symbol)
	{ return self::get_symbol(self::T_EXTENSION,$symbol,false,true); }

//=============== Instance (one per map) =================================
// Automap instance
// Used for plain maps and package-wrapped maps. So, this class must support
// plain script files and packages.
// Using a 2-stage creation. __construct creates a simple instance, and
// realize() really reads the map file.

private $path;
private $base_dir; // Prefix to combine with table entries (with trailing separator)
private $mnt;
private $flags;	 // Load flags;
private $mnt_count;

private $symbols=null;	// Null until realize()d
private $options=null;
private $version;
private $min_version;

//-----
// This object must be created from load() or from Automap_Creator.
// Making __construct() private avoids direct creation from elsewhere.
// base_dir is used only when resolving symbols.
// If base_dir is not set, it is taken as the directory where the map file lies

private function __construct($path,$base_dir,$mnt,$flags=0)
{
$this->path=$path;
$this->mnt=$mnt;
$this->base_dir=$base_dir;
$this->flags=$flags;

$this->mnt_count=1;
}

//-----

private function realize()
{
if (!is_null($this->symbols)) return;

try
{
if (($buf=@file_get_contents($this->path))===false)
	throw new Exception($this->path.': Cannot read map file');

if (substr($buf,0,14)!=self::MAGIC) throw new Exception('Bad Magic');

$this->min_version=trim(substr($buf,16,12));	// Check min version
if (version_compare($this->min_version,self::VERSION) > 0)
	throw new Exception('Cannot understand this automap.'.
		' Requires at least Automap version '.$this->min_version);

$this->version=trim(substr($buf,30,12));

if (strlen($buf)!=($sz=(int)substr($buf,45,8)))		// Check file size
	throw new Exception('Invalid file size. Should be '.$sz);

if (($buf=unserialize(substr($buf,53)))===false)
	throw new Exception('Cannot unserialize data from map file');

if (!is_array($buf))
	throw new Exception('Map file should contain an array');

if (!array_key_exists('map',$buf))
	throw new Exception('No symbol table');

if (!array_key_exists('options',$buf))
	throw new Exception('No options array');

if (!is_array($this->symbols=$buf['map']))
	throw new Exception('Symbol table should contain an array');

if (!is_array($this->options=$buf['options']))
	throw new Exception('Options should be an array');
}
catch (Exception $e)
	{
	$this->symbols=array(); // No retry later
	throw new Exception($this->path.': Cannot load map - '.$e->getMessage());
	}
}

//---

public function path()
{
self::validate($this->mnt);

return $this->path;
}

//---

public function base_dir()
{
self::validate($this->mnt);

return $this->base_dir;
}

//---

public function mnt()
{
self::validate($this->mnt);

return $this->mnt;
}

//---

public function flags()
{
self::validate($this->mnt);

return $this->flags;
}

//---

public function symbols()
{
self::validate($this->mnt);

$this->realize();
return $this->symbols;
}

//---

public function options()
{
self::validate($this->mnt);

$this->realize();
return $this->options;
}

//---

public function version()
{
self::validate($this->mnt);

$this->realize();
return $this->version;
}

//---

public function min_version()
{
self::validate($this->mnt);

$this->realize();
return $this->min_version;
}

//---

public function option($opt)
{
self::validate($this->mnt);

$this->realize();

return (isset($this->options[$opt]) ? $options[$opt] : null);
}

//---

public function symbol_count()
{
self::validate($this->mnt);

return count($this->symbols());
}

//---

private function call_success_handlers($key,$value)
{
foreach (self::$success_handlers as $callable)
	$callable($key,$this->mnt,$value);
}

//---
/**
* Resolves an Automap symbol.
*
* When the symbol is in a package, the search is recursive and the
* concerned (sub)package(s) are automatically mounted.
*
* @param string $key The key we are resolving
* @return boolean symbol could be resolved (true/false)
*/

private function resolve_key($key)
{
$this->realize();
if (!isset($this->symbols[$key])) return false;

$value=$this->symbols[$key];
$fname=self::get_symbol_from_key($value);

switch($ftype=self::get_type_from_key($value))
	{
	case self::F_EXTENSION:
		if (!dl($fname)) return false;
		$this->call_success_handlers($key,$value);
		break;

	case self::F_SCRIPT:
		$file=$this->base_dir.$fname;
		//echo "Loading script file : $file\n";//TRACE
		{ require($file); }
		$this->call_success_handlers($key,$value);
		break;

	case self::F_PACKAGE:
		// Remove E_NOTICE messages if the test script is a package - workaround
		// to PHP bug #39903 ('__COMPILER_HALT_OFFSET__ already defined')

		$file=$this->base_dir.$fname;
		error_reporting(($errlevel=error_reporting()) & ~E_NOTICE);
		$mnt=require($file);
		error_reporting($errlevel);
		self::instance($mnt)->resolve_key($key);
		break;

	default:
		throw new Exception('<'.$ftype.'>: Unknown file type in map');
	}

return true;
}

//---------
// Display the content of a map

public function show($subfile_to_url_function=null)
{
self::validate($this->mnt);

$this->realize();

if ($html=self::is_web())
	{
	$this->html_show($subfile_to_url_function);
	return;
	}

echo "\n* Global information :\n\n";
echo '	Map version : '.$this->version."\n";
echo '	Min reader version : '.$this->min_version."\n";
echo '	Symbol count : '.$this->symbol_count()."\n";

echo "\n* Options :\n\n";
print_r($this->options);

echo "\n* Symbols :\n\n";

$ktype_len=$kname_len=4;
$fname_len=10;

foreach($this->symbols as $key => $value)
	{
	$ktype=self::get_type_string(self::get_type_from_key($key));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	$ktype_len=max($ktype_len,strlen($ktype)+2);
	$kname_len=max($kname_len,strlen($kname)+2);
	$fname_len=max($fname_len,strlen($fname)+2);
	}

echo str_repeat('-',$ktype_len+$kname_len+$fname_len+8)."\n";
echo '|'.str_pad('Type',$ktype_len,' ',STR_PAD_BOTH);
echo '|'.str_pad('Name',$kname_len,' ',STR_PAD_BOTH);
echo '| T ';
echo '|'.str_pad('Defined in',$fname_len,' ',STR_PAD_BOTH);
echo "|\n";
echo '|'.str_repeat('-',$ktype_len);
echo '|'.str_repeat('-',$kname_len);
echo '|---';
echo '|'.str_repeat('-',$fname_len);
echo "|\n";

foreach($this->symbols as $key => $value)
	{
	$ktype=ucfirst(self::get_type_string(self::get_type_from_key($key)));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	echo '| '.str_pad(ucfirst($ktype),$ktype_len-1,' ',STR_PAD_RIGHT);
	echo '| '.str_pad($kname,$kname_len-1,' ',STR_PAD_RIGHT);
	echo '| '.$ftype.' ';
	echo '| '.str_pad($fname,$fname_len-1,' ',STR_PAD_RIGHT);
	echo "|\n";
	}
}
//---
// The same in HTML

private function html_show($subfile_to_url_function=null)
{
echo "<h2>Global information</h2>";

echo '<table border=0>';
echo '<tr><td>Map version:&nbsp;</td><td>'
	.htmlspecialchars($this->version).'</td></tr>';
echo '<tr><td>Min reader version:&nbsp;</td><td>'
	.htmlspecialchars($this->min_version).'</td></tr>';
echo '<tr><td>Symbol count:&nbsp;</td><td>'
	.$this->symbol_count().'</td></tr>';
echo '</table>';

echo "<h2>Options</h2>";
echo '<pre>'.htmlspecialchars(print_r($this->options,true)).'</pre>';

echo "<h2>Symbols</h2>";

echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 '
	.'cellspacing=0 style="border-collapse: collapse"><tr><th>Type</th>'
	.'<th>Name</th><th>FT</th><th>Defined in</th></tr>';
foreach($this->symbols as $key => $value)
	{
	$ktype=ucfirst(self::get_type_string(self::get_type_from_key($key)));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	echo '<tr><td>'.$ktype.'</td><td>'.htmlspecialchars($kname)
		.'</td><td align=center>'.$ftype.'</td><td>';
	if (!is_null($subfile_to_url_function)) 
		echo '<a href="'.call_user_func($subfile_to_url_function,$fname).'">';
	echo htmlspecialchars($fname);
	if (!is_null($subfile_to_url_function)) echo '</a>';
	echo '</td></tr>';
	}
echo '</table>';
}

//---

public function export($path=null)
{
self::validate($this->mnt);

$this->realize();

$file=(is_null($path) ? "STDOUT" : $path);
$fp=fopen($file,'w');
if (!$fp) throw new Exception("$file: Cannot open for writing");

foreach($this->symbols as $key => $value) fwrite($fp,"$key $value\n");

fclose($fp);
}

//---
} // End of class Automap
//===========================================================================

// Registers the automap callback (needs SPL). We support only the SPL
// registration process because defining an _autoload() function is too
// intrusive.

if (!defined('_AUTOMAP_DISABLE_REGISTER'))
	{
	if (!extension_loaded('spl'))
		throw new Exception("Automap requires the SPL extension");

	spl_autoload_register('Automap::autoload_hook');
	}

Automap::init();

} // End of class_exists('Automap')
//===========================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Util class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Util',false))
{
//============================================================================

class PHK_Util	// Static only
{
//-----

private static $verbose=true;

public static function msg($msg)
{
if (self::$verbose) echo $msg."\n";
}

//-----

public static function var_type($var)
{
return is_object($var) ? 'object '.get_class($var) : gettype($var);
}

//-----

public static function is_web()
{
return (php_sapi_name()!='cli');
}

//----

public static function is_windows()
{
return (substr(PHP_OS, 0, 3) == 'WIN');
}

//----

public static function file_suffix($filename)
{
$dotpos=strrpos($filename,'.');
if ($dotpos===false) return '';

return strtolower(substr($filename,$dotpos+1));
}

//---------
// Combines a base directory and a relative path. If the base directory is
// '.', returns the relative part without modification
// Use '/' separator on stream-wrapper URIs

public static function combine_path($dir,$rpath)
{
if ($dir=='.' || $dir=='') return $rpath;
$rpath=trim($rpath,'/');
$rpath=trim($rpath,'\\');

$separ=(strpos($dir,':')!==false) ? '/' : DIRECTORY_SEPARATOR;
if (($dir==='/') || ($dir==='\\')) $separ='';
else
	{
	$c=substr($dir,-1,1);
	if (($c==='/') || ($c=='\\')) $dir=rtrim($dir,$c);
	}

return $dir.$separ.$rpath;
}

//---------
// Adapted from PEAR

public static function load_extension($ext)
{
if (extension_loaded($ext)) return;

if (PHP_OS == 'AIX') $suffix = 'a';
else $suffix = PHP_SHLIB_SUFFIX;

@dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix);

if (!extension_loaded($ext)) throw new Exception("$ext: Cannot load extension");
}

//---------
// Require several extensions. Allows to list every extensions that are not
// present.

public static function load_extensions($ext_list)
{
$failed_ext=array();
foreach($ext_list as $ext)
	{
	try { self::load_extension($ext); }
	catch (Exception $e) { $failed_ext[]=$ext; }
	}
if (count($failed_ext))
	throw new Exception('Cannot load the following required extension(s): '
		.implode(' ',$failed_ext));
}

//---------
// Replacement for substr()
// Difference : returns '' instead of false (when index out of range)

public static function substr($buf,$position,$len=NULL)
{
$str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len);
if ($str===false) $str='';
return $str;
}

//---------
// This function must be called before every file access
// In PHP 6, magic_quotes_runtime is suppressed and set_magic_quotes_runtime()
// does not exist any more.

private static $mqr_exists=null;
private static $mqr_level=0;
private static $mqr_save;

public static function disable_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

if (self::$mqr_level==0)
	{
	self::$mqr_save=get_magic_quotes_runtime();
	set_magic_quotes_runtime(0);
	}
self::$mqr_level++;
}

//---------
// This function must be called after every file access

public static function restore_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

self::$mqr_level--;
if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save);
}

//---------
// Converts a timestamp to a string
// @ to suppress warnings about system timezone

public static function timestring($time=null)
{
if ($time=='unlimited') return $time;
if (is_null($time)) $time=time();
return @strftime('%d-%b-%Y %H:%M %z',$time);
}

//---------
// HTTP mode only: Compute the base URL we were called with

public static function http_base_url()
{
if (!self::is_web()) return '';

if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF'];

$phpself=$_SERVER['PHP_SELF'];
$slen=strlen($phpself);

$pathinfo=$_SERVER['PATH_INFO'];
$ilen=strlen($pathinfo);

// Remove PATH_INFO from PHP_SELF if it is at the end. Don't know
// which config does this, but some servers put it, some don't.

if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo))
	$phpself=substr($phpself,0,$slen-$ilen);

return $phpself;
}

//---------------------------------
// Sends an HTTP 301 redirection

public static function http_301_redirect($path)
{
header('Location: http://'.$_SERVER['HTTP_HOST'].self::http_base_url().$path);
header('HTTP/1.1 301 Moved Permanently');
exit(0);
}

//---------------------------------
// Sends an HTTP 404 failure

public static function http_404_fail()
{
header("HTTP/1.0 404 Not Found");
exit(1);
}

//---------------------------------
// Sends an HTTP 403 failure

public static function http_403_fail()
{
header("HTTP/1.0 403 Forbidden");
exit(1);
}

//-----

public static function bool2str($cond)
{
return $cond ? 'Yes' : 'No';
}

//---------

public static function readfile($path)
{
if (($data=@file_get_contents($path))===false)
	throw new Exception($path.': Cannot get file content');
return $data;
}

//---------
// Throws exceptions and removes '.' and '..'

public static function scandir($path)
{
if (($subnames=scandir($path))===false)
	throw new Exception($path.': Cannot read directory');

$a=array();
foreach($subnames as $f)
	if (($f!='.') && ($f!='..')) $a[]=$f;

return $a;
}

//---------

public static function trace($msg)
{
if (($tfile=getenv('PHK_TRACE_FILE')) !== false)
        {
        // Append message to trace file
        if (($fp=fopen($tfile,'a'))===false) throw new Exception($tfile.': Cannot open trace file');
        fwrite($fp,self::timestring().': '.$msg."\n");
        fclose($fp);
        }
}

//---------
// $start=microtime() float

public static function delta_ms($start)
{
$delta=microtime(true)-$start;

return round($delta*1000,2).' ms';
}

//---------

public static function mk_array($data)
{
if (is_null($data)) return array();
if (!is_array($data)) $data=array($data);
return $data;
}

//---------

public static function display_slow_path()
{
if (getenv('PHK_DEBUG_SLOW_PATH')!==false)
	{
	$html=PHK_Util::is_web();

	if (isset($GLOBALS['__PHK_SLOW_PATH']))
		$data="Slow path entered at:\n".$GLOBALS['__PHK_SLOW_PATH'];
	else $data="Fast path OK\n";

	PHK::info_section($html,'Fast path result');

	if ($html) echo "<pre>";
	echo $data;
	if ($html) echo "/<pre>";
	}
}

//---------

public static function slow_path()
{
if ((getenv('PHK_DEBUG_SLOW_PATH')!==false)
	&& (!isset($GLOBALS['__PHK_SLOW_PATH'])))
	{
	$e=new Exception();
	$GLOBALS['__PHK_SLOW_PATH']=$e->getTraceAsString();
	}
}

//-----
/**
* Sends an Exception with a message starting with 'Format error'
*
* @param string $msg Message to send
* @return void
* @throws Exception
*/

public static function format_error($msg)
{
throw new Exception('Format error: '.$msg);
}

//---------------------------------
// Utility functions called by PHK_Mgr. When using the accelerator, this
// data is persistent. So, retrieving it to populate the cache can be done
// in PHP.

public static function get_min_version($mnt,$caching)
{
return PHK_Stream::get_file(false,PHK_Mgr::command_uri($mnt
	,'magic_field&name=mv'),$mnt,'magic_field',array('name' => 'mv'),''
	,$caching);
}

public static function get_options($mnt,$caching)
{
return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt
	,'OPTIONS'),$mnt,'section',array('name' => 'OPTIONS'),'',$caching));
}

public static function get_build_info($mnt,$caching)
{
return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt
	,'BUILD_INFO'),$mnt,'section',array('name' => 'BUILD_INFO'),'',$caching));
}

//---------------------------------

public static function call_method($object,$method,$args)
{
return call_user_func_array(array($object,$method),$args);
}

//---------------------------------

public static function run_webinfo($phk)
{
$phk->proxy()->crc_check();	//-- check CRC before running webinfo
$phkw=new PHK_Webinfo($phk);
$phkw->run();
}

//---------------------------------

public static function atomic_write($path,$data)
{
$tmpf=tempnam(dirname($path),'tmp_');

if (file_put_contents($tmpf,$data)!=strlen($data))
	throw new Exception($tmpf.": Cannot write");

// Windows does not support renaming to an existing file (looses atomicity)

if (PHK_Util::is_windows()) @unlink($path);

if (!rename($tmpf,$path))
	{
	unlink($tmpf);
	throw new Exception($path,'Cannot replace file');
	}
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

public static function path_unique_id($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//---------
} // End of class PHK_Util
//=============================================================================
} // End of class_exists('PHK_Util')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* Contains the code to physically access PHK package files.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_File',false))
{

//-------------------------
class PHK_File
{

private $fp=null;
private $path;
private $size;
private $open_count=0;
private $keep_open_flag;

//------
// Special case : keep sub-PHKs open (in stream wrapper memory)

public function __construct($path,$flags)
{
$this->set_params($path,$flags);

if (($this->size=filesize($path))===false)
	throw new Exception($path.': Cannot get file size');
}

//------

public function set_params($path,$flags)
{
$this->path=$path;

$this->keep_open_flag=PHK_Mgr::is_a_phk_uri($path);
}

//---

public function __sleep()
{
return array('size');
}

//------

public function __destruct()
{
$this->really_close();
}

//------

private function really_close()
{
if (!is_null($this->fp))
	{
	fclose($this->fp);
	$this->fp=null;
	$this->open_count=0;
	}
}

//------
// Open in read-only mode. Maintains a count for close(), throws exceptions,
// and force 'b' mode (for Windows).
// Called from self or PHK_FileSpace only

public function _open()
{
if (is_null($this->fp))
	{
	if (!($this->fp=fopen($this->path,'rb',false)))	//-- 'b' mode is for Windows
		throw new Exception($this->path.': Cannot open for reading');
	$this->open_count=1;
	}
else $this->open_count++;
}

//-----
// fclose() the file pointer. Maintains an open count.
// Called from self or PHK_FileSpace only

public function _close()
{
$this->open_count--;
if (($this->open_count <= 0) && (!$this->keep_open_flag)) $this->really_close();
}

//-----
// Same as PHP fread() but reads any size, throws exceptions, and checks size
// I don't use stream_get_contents() because, sometimes, it crashes
// on Windows (detected with PHP 5.1.4).

private function read($size)
{
$data='';
$nb_chunks=intval($size/8192);
$rest=$size % 8192;

PHK_Util::disable_mqr();
while ($nb_chunks > 0)
	{
	$data .= $this->read_chunk(8192);
	$nb_chunks--;
	}

if ($rest) $data .= $this->read_chunk($rest);
PHK_Util::restore_mqr();

return $data;
}

//-----
// Read up to 8192 bytes

private function read_chunk($size)
{
$buf=fread($this->fp,$size);
if ($buf===false) throw new Exception('Cannot read');
if (($bsize=strlen($buf))!=$size)
	throw new Exception("Short read ($bsize/$size)");
return $buf;
}

//-----
// Reads a block from file.
// Called only from PHK_FileSpace. So:
//		- we don't need to check bounds,
//		- we don't provide default args,
//		- we are sure that size is > 0

public function _read_block($offset,$size)
{
try
	{
	$this->_open();
	if (fseek($this->fp,$offset,SEEK_SET) == -1)
		throw new Exception('Cannot seek');
	$buf=$this->read($size);
	$this->_close();	// At the end. Everything before can raise an exception
	}				// and we don't want to close it twice
catch (Exception $e)
	{
	$this->_close();
	throw new Exception($e->getMessage());
	}
return $buf;
}

//------

public function size()
{
return $this->size;
}

//------

public function path()
{
return $this->path;
}

}	// End of class PHK_File
//-------------------------
} // End of class_exists('PHK_File')
//=============================================================================

if (!class_exists('PHK_FileSpace',false))
{
//-------------------------
class PHK_FileSpace
{

public $file;	// underlying  PHK_File object
private $offset;
private $size;

//------
// Two possibles syntaxes :
// new PHK_FileSpace(String $path,int $flags) : creates a first space for a file
// new PHK_FileSpace(PHK_FileSpace $parent, int $offset, int $size) :
//		creates a subspace inside an existing FileSpace.

public function __construct($arg1,$arg2,$size=null)
{
if (is_string($arg1))
	{
	$this->file=new PHK_File($arg1,$arg2);
	$this->offset=0;
	$this->size=$this->file->size();
	}
else
	{
	if ((!($arg1 instanceof self))
		|| (!is_numeric($arg2))
		|| (!is_numeric($size))
		|| ($arg2 < 0)
		|| (($arg2+$size) > $arg1->size))
		throw new Exception("PHK_FileSpace: cannot create - invalid arguments");

	$this->file=$arg1->file;
	$this->offset=$arg1->offset + $arg2;
	$this->size=$size;
	}
}

//------
// Default args so that read_block() without args returns the whole filespace

public function read_block($offset=0,$size=null)
{
//PHK_Util::trace("Starting PHK_FileSpace::read_block - offset=$offset - size=$size");//TRACE

if (is_null($size)) $size=$this->size-$offset; // Read up to the end

if (($offset<0)||($size<0)||($offset+$size>$this->size))
	throw new Exception('PHK_FileSpace: Read out of bound');

if ($size==0) return '';

$data=$this->file->_read_block($this->offset+$offset,$size);

//PHK_Util::trace("Ending PHK_FileSpace::read_block");//TRACE
return $data;
}

//------
// Used to force the file to remain open temporarily

public function open()
{
$this->file->_open();
}

//------

public function close()
{
$this->file->_close();
}

//------

public function size()
{
return $this->size;
}

//------
// Returns path of underlying file (can be a PHK URI)

public function path()
{
return $this->file->path();
}

//------
}	// End of class PHK_FileSpace
//-------------------------
} // End of class_exists('PHK_FileSpace')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK cache gateway
*
* The cache key is based on the mount point because it uniquely defines the
* PHK file on the current host.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Cache',false))
{
// /---------------

//=============================================================================

class PHK_Cache	// Static only
{
/** Class version */

const VERSION='1.1.0';

const TTL=3600;	// Arbitrary TTL of one hour

//-- Global static properties

private static $caches=array("apc","xcache","eaccelerator");

private static $cache_name;	// Info

/** @var Object|false|null	The cache system we are using for PHK instances
*
* False means 'no cache'.
* null until set by set_cache_object().
*/

private static $cache=null;

private static $cache_maxsize=524288;	// 512 Kb

//-----

public static function cache_id($prefix,$key)
{
return 'phk.'.$prefix.'.'.$key;
}

//---------------------------------
// If the cache's init() method returns an exception, don't use it.

private static function set_cache_object()
{
if (is_null(self::$cache))
	{
	self::$cache=false;
	self::$cache_name='none';
	foreach(self::$caches as $c)
		{
		if (!extension_loaded($c)) continue;
		
		$class='PHK_Cache_'.$c;
		$obj=new $class;
		try { $status=$obj->init(); }
		catch (Exception $e) { $status=false; }
		if ($status)
			{
			self::$cache=$obj;
			self::$cache_name=$c;
			break;
			}
		unset($obj);
		}
	// echo "Cache system used : ".self::$cache_name."\n";//TRACE
	}
}

//---------------------------------

public static function set_cache_maxsize($size)
{
$this->cache_maxsize=$size;
}

//---------------------------------

public static function cache_name()
{
if (is_null(self::$cache)) self::set_cache_object();

return self::$cache_name;
}

//---------------------------------

public static function cache_present()
{
if (is_null(self::$cache)) self::set_cache_object();

return (self::$cache!==false);
}
//---------------------------------
/**
* Gets an element from cache
*
* Fast path
*
* @param string $id		Cache key
*
* @return string|null The data. Null if not found
*/

public static function get($id)
{
if (is_null(self::$cache)) self::set_cache_object();

if (self::$cache===false) return null;

$result=self::$cache->get($id);
if ($result===false) $result=null;

return $result;
}

//---------------------------------
/**
* Writes an element to cache
*
* @param string $id		Cache key
* @param string $data	Data to cache
*
* @return void
*/

public static function set($id,$data)
{
if (is_null(self::$cache)) self::set_cache_object();

if (is_object(self::$cache))
	{
	if (is_string($data) && (strlen($data) > self::$cache_maxsize)) return;

	PHK_Util::trace("Writing cache: id=$id");//TRACE
	self::$cache->set($id,$data);
	}
}

//---------------------------------
} // End of class PHK_Cache
//=============================================================================

abstract class PHK_Cache_Base
{
// Returns true if this system can be used. Exception if unavailable

abstract public function init();

// Return data or null

abstract public function get($id);

// Return void

abstract public function set($id,$data);
}

//=============================================================================

class PHK_Cache_apc extends PHK_Cache_Base
{

public function init()
{
// Valid only in a web environment or if CLI is explicitely enabled

return PHK_Util::is_web() || ini_get('apc.enable_cli');
}

//------

public function get($id)
{
return apc_fetch($id);
}

//------

public function set($id,$data)
{
apc_store($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_apc
//=============================================================================

class PHK_Cache_xcache extends PHK_Cache_Base
{

public function init()
{
return PHK_Util::is_web(); // Valid only in a web environment
}

//------

public function get($id)
{
return xcache_get($id);
}

//------

public function set($id,$data)
{
xcache_set($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_xcache
//=============================================================================

class PHK_Cache_eaccelerator extends PHK_Cache_Base
{

public function init()
{
// eaccelerator must be compiled with shared memory functions 
// (configured with --with-eaccelerator-shared-memory)

if (!function_exists('eaccelerator_get')) return false;

return PHK_Util::is_web(); // Valid only in a web environment
}

//------

public function get($id)
{
return eaccelerator_get($id);
}

//------

public function set($id,$data)
{
eaccelerator_put($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_eaccelerator
//=============================================================================

//-------------------------
} // End of class_exists('PHK_Cache')
//=============================================================================

//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Proxy class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Proxy',false))
{
// /---------------

//=============================================================================
/**
* The 'back-end' object providing physical access to the package file. This
* object is created and called by the stream wrapper on cache misses.
*
* Runtime code -> 100% read-only except set_buffer_interp().
*
* @see PHK_Stream
* @see PHK
* @see PHK_Mgr
* @package PHK
*/

class PHK_Proxy
{
//========== Class constants ===============

/** Class version */

const VERSION='1.3.0';

/** The size of the interp line (fixed size) */

const INTERP_LEN=64;

/** The size of a version string in the magic block - Up to 12 bytes */

const VERSION_SIZE=12;

/** The size of each offset field. As offset are limited to 11 bytes, the
* theoritical max size of a PHK archive is 100 G bytes. Not tested :) */

const OFFSET_SIZE=11;

/** The magic string. This is the string we identify to recognize a PHK archive */

const MAGIC_STRING="#PHK M\024\x8\6\3";
const MAGIC_STRING_LEN=10;

/** INTERP_LEN + 6 */

const MAGIC_STRING_OFFSET=70;

/** The size of the magic block */

const MAGIC_LINE_LEN=177;

/** The name of the optional Automap section, when it exists */

const AUTOMAP_SECTION='AUTOMAP';

/** The offset of the CRC field, from the beginning of the archive file.
* The CRC field is 8 bytes long (32 bits in hexadecimal) */

const CRC_OFFSET=200;

//========== Instance data ===============

/** @var PHK_Tree	Section tree */

protected	$stree=null;

/** @var PHK_Tree	File tree */

public		$ftree=null;

/** @var integer	Mount flags */

protected	$flags;

/** @var PHK_FileSpace	File Handler */

protected	$fspace;

/** @var array		Magic values */

private		$magic=null;

//========== Class methods ===============

/**
* Constructor
*
* This method must be called only from PHK_Mgr::proxy() only
*
* @param string mount point
*
* @throws Exception
*/

public function __construct($path,$flags)
{
try
{
PHK_Util::slow_path();

//PHK_Util::trace("Starting proxy init");//TRACE

$this->flags=$flags;

if (!($this->flags & PHK::F_CREATOR))
	{
	// file_is_package() moved here from PHK_Mgr::compute_mnt() because we don't
	// need to check this if data is already in cache.

	if (! self::file_is_package($path))
		throw new Exception($path.'is not a PHK package');

	$this->fspace= new PHK_FileSpace($path,$flags);
	$this->fspace->open();

	// Get magic block

	$this->get_magic_values();

	// Check that file size corresponds to the value stored in the magic block.
	// Done only once in slow path because, if the file size changes, the
	// modification date will change too, and thus the mount point.

	if ($this->fspace->size()!=$this->magic['fs']) // Check file size
		PHK_Util::format_error('Invalid file size. Should be '.$this->magic['fs']);

	// Import section tree

	$this->stree=PHK_Tree::create_from_edata(
		$this->fspace->read_block($this->magic['sso']
			,$this->magic['sto']-$this->magic['sso'])
		,new PHK_FileSpace($this->fspace,$this->magic['sto']
			,$this->magic['fto']-$this->magic['sto']));

	$this->ftree=PHK_Tree::create_from_edata($this->section('FTREE')
		,new PHK_FileSpace($this->fspace,$this->magic['fto']
			,$this->magic['sio']-$this->magic['fto']));

	$this->fspace->close(); // We keep the file open during init phase
	}
else
	{
	$this->ftree=PHK_Tree::create_empty();
	$this->stree=PHK_Tree::create_empty();
	}
}
catch (Exception $e)
	{
	throw new Exception('While initializing PHK proxy - '.$e->getMessage());
	}
//PHK_Util::trace("Ending init - path=$path");//TRACE
}

//---------

public function crc_check()
{
self::check_crc_buffer($this->fspace->read_block());
}

//---------------------------------
/**
* Inserts or clears a CRC in a memory buffer
*
* @static
* @param string $buffer	The original buffer whose CRC will be overwritten
* @param string $crc	If set, the CRC as an 8-char string (in hexadecimal). If
*	not set, we clear the CRC (set it to '00000000').
* @return string	The modified buffer
*/

public static function insert_crc($buffer,$crc)
{
return substr_replace($buffer,$crc,self::CRC_OFFSET,8);
}

//--------------------------------
/**
* Returns the CRC extracted from a memory buffer (not the computed one)
*
* @param string $buffer
* @return string The extracted 8-char hex CRC
*/

private static function get_crc($buffer)
{
return substr($buffer,self::CRC_OFFSET,8);
}

//---------------------------------
/**
* Computes a CRC from a given memory buffer
*
* As the given buffer already contains a CRC, we first clear it.
*
* @param string $buffer
* @return string The computed 8-char hex CRC
*/

private static function compute_crc($buffer)
{
return sprintf('%08x',crc32(self::insert_crc($buffer,'00000000')));
}

//---------------------------------
/**
* Checks a memory buffer's CRC
*
* The memory buffer is supposed to contain a whole PHK archive.
*
* No return value: if the CRC check fails, an exception is thrown.
*
* @param string $buffer
* @return void
* @throws Exception
*/

public static function check_crc_buffer($buffer)
{
if (self::compute_crc($buffer) !== self::get_crc($buffer))
	throw new Exception('Wrong CRC');
}

//---------------------------------
/**
* Computes and inserts a CRC in a memory buffer
*
* @param string $buffer
* @return string	The modified buffer
*/

public static function fix_crc($buffer)
{
return self::insert_crc($buffer,self::compute_crc($buffer));
}

//---------
/**
* Check if a given path contains a PHK package
*
* @param string $path	path to check (can be virtual)
* @return boolean
*/

public static function file_is_package($path)
{
if (filesize($path)< (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false;
if (($fp=fopen($path,'rb',false))===false) return false;
if (fseek($fp,self::MAGIC_STRING_OFFSET) != 0) return false;
if (($m=fread($fp,self::MAGIC_STRING_LEN))===false) return false;
fclose($fp);
return ($m===self::MAGIC_STRING);
}

//---------
/**
* Check if a data buffer contains a PHK package
*
* @param string $data	data buffer to check
* @return boolean
*/

public static function data_is_package($data)
{
if (strlen($data) < (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false;
return (substr($data,self::MAGIC_STRING_OFFSET,self::MAGIC_STRING_LEN)
	===self::MAGIC_STRING);
}

//---------------------------------
/**
* Extracts the value values out of a magic line buffer
*
* Note: A package is signed if (Signature offset != File size)
*
* @param string $buf A magic line content
* @return array An array containing the magic values
*/

public function get_magic_values()
{
$buf=$this->fspace->read_block(self::INTERP_LEN,self::MAGIC_LINE_LEN);

$fsize=(int)substr($buf,47,self::OFFSET_SIZE);
$sio=(int)substr($buf,121,self::OFFSET_SIZE);
$crc=null;
sscanf(substr($buf,136,8),'%08x',$crc);

$this->magic=array(
	'mv'  => trim(substr($buf,18,self::VERSION_SIZE)),	// Minimum required version
	'v'	  => trim(substr($buf,32,self::VERSION_SIZE)),	// Version
	'fs'  => $fsize,									// File size
	'po'  => (int)substr($buf,61,self::OFFSET_SIZE),	// Prolog offset
	'sso' => (int)substr($buf,76,self::OFFSET_SIZE),	// Serialized sections offset
	'sto' => (int)substr($buf,91,self::OFFSET_SIZE),	// Section table offset
	'fto' => (int)substr($buf,106,self::OFFSET_SIZE),	// File table offset
	'sio' => $sio,										// Signature offset
	'pco' => (int)substr($buf,148,self::OFFSET_SIZE),	// PHP code offset
	'pcs' => (int)substr($buf,163,self::OFFSET_SIZE),	// PHP code length
	'crc' => $crc,
	'signed' => ($sio != $fsize));
}

//---------------------------------

public function magic_field($name)
{
return $this->magic[$name];
}

//---------------------------------
/**
* Brings all data in memory
*
* After this function has run, we never access the package file any more.
*
* @see PHK_DC implements the data cache
*
* @return void
*/

private function cache_data()
{
$this->stree->walk('read');
$this->ftree->walk('read');
}

//---------------------------------
/**
* Clears the data cache
*
* @see PHK_DC implements the data cache
*
* @return void
*/

private function clear_cache()
{
$this->stree->walk('clear_cache');
$this->ftree->walk('clear_cache');
}

//---------------------------------

public function path_list()
{
return $this->ftree->path_list();
}

//---------------------------------

public function section_list()
{
return $this->stree->path_list();
}


//---------------------------------
/**
* Is this package digitally signed ?
*
* @return boolean
*/

public function signed()
{
return $this->magic['signed'];
}

//-----
/**
* Gets interpreter string
*
* If the interpreter is defined, returns it. Else, returns an empty string
*
* @return string
* @throws Exception if the interpreter string is invalid
*/

public function interp()
{
$block=$this->fspace->read_block(0,self::INTERP_LEN);

if ((($block{0}!='#')||($block{1}!='!')) && (($block{0}!='<')||($block{1}!='?')))
	throw new Exception('Invalid interpreter block');
return ($block{0}=='#') ? trim(substr($block,2)) : '';
}

//-----
/**
* Builds an interpreter block from an interpreter string
*
* Note: can be applied to a signed package as the signature ignores the
* interpreter block and the CRC.

* @param string $interp Interpreter to set or empty string to clear
* @return string Interpreter block (INTERP_LEN). Including trailing '\n'
*/

public static function interp_block($interp)
{
if (($interp!=='') && (strlen($interp) > (PHK_Proxy::INTERP_LEN-3)))
	throw new Exception('Length of interpreter string is limited to '
		.(PHK_Proxy::INTERP_LEN-3).' bytes');

// Keep '<?'.'php' or it will be translated when building the runtime code

if ($interp==='') return str_pad('<?'.'php',PHK_Proxy::INTERP_LEN-2).'?'.'>';
else return '#!'.str_pad($interp,PHK_Proxy::INTERP_LEN-3)."\n";
}

//-----
/**
* Inserts a new interpreter block in a file's content
*
* Allows a PHK user to change its interpreter string without
* having to use the PHK_Creator kit.
*
* Note: can be applied to a signed package as the signature ignores the
* interpreter block and the CRC.
*
* @param string $path PHK archive's path
* @param string $interp Interpreter string to set (empty to clear)
* @return string The modified buffer (the file is not overwritten)
*/

public static function set_buffer_interp($path,$interp='')
{
return self::fix_crc(substr_replace(PHK_Util::readfile($path)
	,self::interp_block($interp),0,PHK_Proxy::INTERP_LEN));
}

//-----
/**
* The version of the PHK_Creator tool this package was created from
*
* @return string Version
*/

public function version()
{
return $this->magic['v'];
}

//-----
/**
* Returns the $path property
*
* @return string
*/

public function path()
{
return $this->fspace->path();
}

//-----
/**
* Get a section's content
*
* @param string $name The section name
* @return string The section's content
* @throws Exception if section does not exist or cannot be read
*/

public function section($name)
{
try { $node=$this->stree->lookup_file($name); }
catch (Exception $e) { throw new Exception($name.': Unknown section'); }

try { return $node->read(); }
catch (Exception $e)
	{ throw new Exception($name.': Cannot read section - '.$e->getMessage()); }
}

//-----

public function ftree()
{
return $this->ftree;
}

//-----

public function stree()
{
return $this->stree;
}

//-----
/**
* Returns the $flags property
*
* @return integer
*/

public function flags()
{
return $this->flags;
}

//---------------------------------

public function display_packages()
{
$this->ftree->display_packages();
}

//---------------------------------
// Display the file tree

public function showfiles()
{
$this->ftree->display(true);
}

//----
} // End of class PHK
//=============================================================================
} // End of class_exists('PHK')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

//=============================================================================

if (!class_exists('PHK_Mgr',false))
{
//=============================================================================
/**
* This is a static-only class. It has the responsability to manage the table
* of currently mounted packages. Each package is uniquely identified by a
* 'mount point', which is a string computed at mount time. The PHK_Mgr class
* contains the methods allowing to get information from its table, as well
* as methods to mount and umount a package.
*
* Runtime code -> 100% read-only.
*
* @package PHK
*/

//=============================================================================

class PHK_Mgr	// Static only
{
/** Class version */

const VERSION='1.4.0';

//-- Global static properties

/** @var array		Currently mounted PHK instances */

private static $phk_tab=array(); // Key=mount directory, value=PHK instance

/**
* @var array		Proxy objects for each currently mounted package. As
* long as the proxy object is not instantiated through the proxy() method,
* the corresponding value is null in this array. Contains exactly the same
* keys as $phk_tab.
*/

private static $proxy_tab=array(); // Key=mount directory, value=PHK_Proxy|null

/* @var int Running value for PHK_Creator mount points */

private static $tmp_mnt_num=0;

/* @var boolean|null Global cache toggle. If null, per-instance logic is used */

private static $caching=null;

//-----
/**
* Checks if a mount point is valid (if it corresponds to a currently mounted
* package)
*
* @param string $mnt Mount point to check
* @return boolean
*/

public static function is_mounted($mnt)
{
return isset(self::$phk_tab[$mnt]);
}

//-----
/**
* Same as is_mounted but throws an exception is the mount point is invalid.
*
* Returns the mount point so that it can be embedded in a call string.
*
* @param string $mnt Mount point to check
* @return string mount point (not modified)
* @throws Exception if mount point is invalid
*/

public static function validate($mnt)
{
if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point');

return $mnt;
}

//-----
/**
* Returns the PHK object corresponding to a given mount point
*
* @param string $mnt Mount point
* @return PHK instance
* @throws Exception if mount point is invalid
*/

public static function instance($mnt)
{
self::validate($mnt);

return self::$phk_tab[$mnt];
}

//-----
/**
* Returns the PHK_Proxy object corresponding to a given mount point
*
* If the corresponding PHK_Proxy object does not exist yet, it is created.
*
* @param string $mnt Mount point
* @return PHK_Proxy proxy object
* @throws Exception if mount point is invalid
*/

public static function proxy($mnt)
{
self::validate($mnt);

if (is_null(self::$proxy_tab[$mnt]))
	{
	$phk=self::instance($mnt);
	self::$proxy_tab[$mnt]=new PHK_Proxy($phk->path(),$phk->flags());
	}

return self::$proxy_tab[$mnt];
}

//-----
/**
* Returns the list of the defined mount points.
*
* @return array
*/

public static function mnt_list()
{
return array_keys(self::$phk_tab);
}

//---------
/**
* Sets the global caching toggle
*
* Normally, the global cache toggle is always null, except in 'webinfo'
* mode, where it is false to inhibit any caching of webinfo information
* (2 reasons: useless in terms of performance, and could use the same keys as
* the 'non-webinfo' mode, so we would have to use another key prefix).
*
* @param boolean|null $caching True: always cache, False: never cache,
* null: use per-instance logic.
* @return void
*/

public static function set_cache($caching)
{
self::$caching=$caching;
}

//---------
/**
* Determines if a an URI can be cached.
*
* For performance reasons, the input URI is splitted.
*
* Called by the wrapper to know if it should cache the data it got from its
* backend.
*
* The global cache toggle is checked first. If it is null, control is
* transferred to the instance logic.
*
* @param string|null $mnt Mount point or null if global command
* @param string|null $command command if defined
* @param array|null $params Command parameters if defined
* @param string $path Path
* @return boolean whether the data should be cached or not
* @throws Exception if mount point is invalid
*/


public static function cache_enabled($mnt,$command,$params,$path)
{
if (!is_null(self::$caching)) return self::$caching;

if (is_null($mnt)) return false;

return self::instance($mnt)->cache_enabled($command,$params,$path);
}

//---------
/**
* Given a file path, tries to determine if it is currently mounted. If it is
* the case, the corresponding mount point is returned. If not, an exception is
* thrown.
*
* Note: when dealing with sub-packages, the input path parameter can be a PHK
* URI.
*
* @param string $path Path of a PHK package
* @return the corresponding mount point
* @throws Exception if the file is not currently mounted
*/

public static function path_to_mnt($path)
{
$dummy1=$mnt=$dummy2=null;
self::compute_mnt($path,$dummy1,$mnt,$dummy2);

if (self::is_mounted($mnt)) return $mnt;

throw new Exception($path.': path is not mounted');
}

//---------
/**
* Mount a PHK package and returns the new (or previous, if already loaded)
* PHK mount point.
*
* Can also create empty PHK_Creator instances (when the 'CREATOR' flag is set).
*
* @param string $path The path of an existing PHK archive, or the path of the
*                     archive to create if ($flags & PHK::F_CREATOR)
* @param int $flags Or-ed combination of PHK mount flags.
* @return string the mount point
*/

public static function mount($path,$flags=0)
{
try
{
if ($flags & PHK::F_CREATOR)
	{
	$mnt='_tmp_mnt_'.(self::$tmp_mnt_num++);
	self::$proxy_tab[$mnt]=null;
	self::$phk_tab[$mnt]=new PHK_Creator($mnt,$path,$flags);
	}
else	// Mount an existing archive
	{
	$parent_mnt=$mnt=$mtime=$options=$build_info=null;
	self::compute_mnt($path,$parent_mnt,$mnt,$mtime);
	if (self::is_mounted($mnt)) return $mnt;

	self::$proxy_tab[$mnt]=null;
	self::$phk_tab[$mnt]=$phk=new PHK($parent_mnt,$mnt,$path,$flags,$mtime);

	self::get_store_data($mnt,$options,$build_info);
	$phk->init($options,$build_info);
	}
}
catch (Exception $e)
	{
	if (isset($mnt) && self::is_mounted($mnt)) unset(self::$phk_tab[$mnt]);
	throw new Exception($path.': Cannot mount - '.$e->getMessage());
	}

return $mnt;
}

//-----
/**
* Checks the PHK version this package requires against the current version.
* Then, retrieves the 'options' and 'build_info' arrays.
*
* This function is separated from mount() to mimic the behavior of the PHK
* extension, where this data is cached in persistent memory.
*
* @param string $mnt the mount point
* @param array $options on return, contains the options array
* @param array $build_info on return, contains the build_info array
* @return void
*/

private static function get_store_data($mnt,&$options,&$build_info)
{
$caching=(is_null(self::$caching) ? true : self::$caching);

// Must check this first

$mv=PHK_Util::get_min_version($mnt,$caching);

if (version_compare($mv,PHK::VERSION) > 0)
	{
	PHK_Util::format_error('Cannot understand this version. '
		.'Requires at least PHK version '.$mv);
	}

$options=PHK_Util::get_options($mnt,$caching);
$build_info=PHK_Util::get_build_info($mnt,$caching);
}

//---------------------------------
/**
* Computes the mount point corresponding to a given path.
*
* Also returns the parent mount point (for sub-packages), and the modification
* time (allows to call stat() only once).
*
* Mount point uniqueness is based on a combination of device+inode+mtime.
*
* When dealing with sub-packages, the input path is a PHK URI.
*
* Sub-packages inherit their parent's modification time.
*
* @param string $path The path to be mounted
* @param $parent_mnt string|null returns the parent mount point. Not
* null only for sub-packages.
* @param string $mnt returns the computed mount point
* @param int $mtime returns the modification time
* @return void
* @throws Exception with message 'File not found' if unable to stat($path).
*/

private static function compute_mnt($path,&$parent_mnt,&$mnt,&$mtime)
{
if (self::is_a_phk_uri($path)) // Sub-package
	{
	$dummy1=$dummy2=$subpath=$parent_mnt=null;
	PHK_Stream::parse_uri($path,$dummy1,$dummy2,$parent_mnt,$subpath);
	self::validate($parent_mnt);
	$mnt=$parent_mnt.'#'.str_replace('/','*',$subpath);
	$mtime=self::instance($parent_mnt)->mtime(); // Inherit mtime
	}
else
	{
	$mnt=PHK_Util::path_unique_id('p',$path,$mtime);
	$parent_mnt=null;
	}
}

//---------------------------------
/**
* Umounts a mounted package and any mounted descendant.
*
* We dont use __destruct because :
*	1. We don't want this to be called on script shutdown
*	2. Exceptions cannot be caught when sent from a destructor.
*
* Accepts to remove a non registered mount point without error
*
* @param string $mnt The mount point to umount
*/

public static function umount($mnt)
{
if (self::is_mounted($mnt))
	{
	// Umount children

	foreach (array_keys(self::$phk_tab) as $dmnt)
		{
		if (isset(self::$phk_tab[$dmnt])
			&& self::$phk_tab[$dmnt]->parent_mnt()===$mnt)
				self::umount($dmnt);
		}

	// Call instance's umount procedure

	self::$phk_tab[$mnt]->umount();

	// Remove from the list

	unset(self::$phk_tab[$mnt]);
	unset(self::$proxy_tab[$mnt]);
	}
}

//---------
/**
* Builds a 'phk://' uri, from a mount directory and a path
*
* @param string $mnt The mount point
* @param string $path The path
* @return string The computed URI
*/

public static function uri($mnt,$path)
{
return self::base_uri($mnt).ltrim($path,'/');
}

//-----
/** Checks if a string is a PHK URI
*
* @param string $uri
* @return boolean
*/

public static function is_a_phk_uri($uri)
{
$u=$uri.'      ';

// Much faster this way

return ($u{0}=='p' && $u{1}=='h' && $u{2}=='k' && $u{3}==':'
	&& $u{4}=='/' && $u{5}=='/'); 

//return (strlen($uri) >= 6) && (substr($uri,0,6)=='phk://');
}

//-----
/**
* Returns the base string used to build URIs for a given mount point.
*
* The base URI has the form : phk://<mount point>
*
* @param string $mnt A mount point
* @return string
*/

public static function base_uri($mnt)
{
return 'phk://'.$mnt.'/';
}

//---------
/**
* Returns a 'command' URI, given a mount point and a 'command' string
*
* Command URIs have the form : phk://<mount point>/?<command>
*
* @param string $mnt A mount point
* @param string $command Command string
* @return string
*/

public static function command_uri($mnt,$command)
{
return self::uri($mnt,'?'.$command);
}

//---------
/**
* Returns the URI allowing to retrieve a section.
*
* Section URIs have the form : phk://<mount point>/?section&name=<section>
*
* @param string $mnt A mount point
* @param string $section The section to retrieve
* @return string
*/

public static function section_uri($mnt,$section)
{
return self::command_uri($mnt,'section&name='.$section);
}

//-----
/**
* Returns the URI of the Automap map if it is defined
*
* @param string $mnt A mount point
* @return string|null returns null if the package does not define an automap.
*/

public static function automap_uri($mnt)
{
if ((!self::is_mounted($mnt))||(!self::instance($mnt)->map_defined()))
	return null;

return self::section_uri($mnt,'AUTOMAP');
}

//---------------------------------
/**
* Replaces '\' characters by '/' in a URI.
*
* @param string $uri
* @return string
*/

public static function normalize_uri($uri)
{
return str_replace('\\','/',$uri);
}

//-----
/**
* Returns the mount directory of a subfile's phk uri.
* Allows to reference other subfiles in the same package if you don't want
* or cannot use Automap (the preferred method) or a relative path.
* Example : include(PHK_Mgr::uri(PHK_Mgr::uri_to_mnt(__FILE__),<path>));
*
* @param string $uri
* @return string a mount point
* @throws Exception if the input URI is not a PHK URI
*/

public static function uri_to_mnt($uri)
{
if (! self::is_a_phk_uri($uri))
	throw new Exception($uri.': Not a PHK URI');

$buf=substr(self::normalize_uri($uri),6);
$buf=substr($buf,0,strcspn($buf,'/'));
return trim($buf);
}

//---------
/**
* Check if the current PHP version is supported.
*
* Note that, if PHP version < 5.1, parsing fails and we don't even start
* execution. So, this test is only executed when PHP version >= 5.1
*
* As a side effect, until we request a version > 5.1, this function
* will never fail.
*
* Calls exit(1) if PHP version is not supported by the PHK runtime
*
* @return void
*/

public static function php_version_check()
{
if (version_compare(PHP_VERSION,'5.1.0') < 0)
	{
	echo PHP_VERSION.': Unsupported PHP version '
		.'- PHK needs at least version 5.1.0';
	exit(1);
	}
}

//---------------------------------
} // End of class PHK_Mgr
//-------------------------
} // End of class_exists('PHK_Mgr')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Base',false))
{
//=============================================================================
/**
* A mounted PHK archive file
*
* This file contains the front-end class for PHK object. This class gets its
* data from the stream wrapper, which retrieves them from the cache or from
* PHK_Proxy. This class is also used as base class for PHK_Creator instances.
*
* This class does never access the package file directly.
*
* Note: When dealing with a sub-package, the mounted archive file is a 'phk://'
* virtual file contained in a higher-level PHK archive (which, itself, can be
* virtual). There is no limit to the recursion level of sub-packages.
*
* Runtime code -> 100% read-only
*
* PHK objects are created and destructed from the PHK manager (PHK_Mgr class).
*
* You get the PHK object instance by calling PHK_Mgr::instance with a mount
* point. This mount point is generally returned either by an include,
* when including a package, or by PHK_Mgr::uri_to_mnt().
*
* @see PHK_Mgr
* @see PHK_Proxy
* @package PHK
*/

abstract class PHK_Base
{
//========== Class constants ===============

/** Class version */

const VERSION='1.4.0';

//-----
// Mount flags
/* The values defined here must be the same as in the accelerator extension */

/** Mount flag - If set, force a CRC check when creating the PHK instance */

const F_CRC_CHECK=4;

/** Mount flag - If set, don't call mount/umount scripts */

const F_NO_MOUNT_SCRIPT=8;

/** Mount flag - If set, create a PHK_Creator object, instead of a PHK object */

const F_CREATOR=16;

//========== Class properties ===============

/** @var string		Current mount point */

protected $mnt;

/** @var string		Parent mount point (for a subpackage) or null */

protected $parent_mnt;

/** @var array		Package options */

protected $options=null;	// Array

/** @var array		Build-time information */

protected $build_info=null;

/** @var integer	Mount flags */

protected $flags;

/** @var integer	Package path (URI when subpackage) */

protected $path;

/** @var Object|null	Plugin object, if defined */

protected $plugin=null;

/** @var boolean|null Allows to temporarily enable/disable caching */

protected $caching=null;

/** @var int The modification time for every subfiles */

protected $mtime;

/** @var PHK_Backend The slow backend object (created only when needed) */

protected $backend=null;

/** @var array	File extension to mime type (constant)
*
* Would be cleaner if PHP class constants could contain arrays */

protected static $mime_table=array(
	''     => 'text/plain',
	'gif'  => 'image/gif',
	'jpeg' => 'image/jpeg',
	'jpg'  => 'image/jpeg',
	'png'  => 'image/png',
	'psd'  => 'image/psd',
	'bmp'  => 'image/bmp',
	'tif'  => 'image/tiff',
	'tiff' => 'image/tiff',
	'iff'  => 'image/iff',
	'wbmp' => 'image/vnd.wap.wbmp',
	'ico'  => 'image/x-icon',
	'xbm'  => 'image/xbm',
	'txt'  => 'text/plain',
	'htm'  => 'text/html',
	'html' => 'text/html',
	'css'  => 'text/css',
	'php'  => 'application/x-httpd-php',
	'phk'  => 'application/x-httpd-php',
	'pdf'  => 'application/pdf',
	'js'   => 'application/x-javascript',
	'swf'  => 'application/x-shockwave-flash',
	'xml'  => 'application/xml',
	'xsl'  => 'application/xml',
	'xslt' => 'application/xslt+xml',
	'mp3'  => 'audio/mpeg',
	'ram'  => 'audio/x-pn-realaudio',
	'svg'  => 'image/svg+xml'
	);

//========== Class methods ===============

//-----

public function __construct($parent_mnt,$mnt,$path,$flags,$mtime)
{
$this->parent_mnt=$parent_mnt;
$this->mnt=$mnt;
$this->path=$path;
$this->flags=$flags;
$this->mtime=$mtime;
}

//-----

public function init($options,$build_info)
{
try
{
$this->options=$options;
$this->build_info=$build_info;

$this->supports_php_version();

if ($this->option('crc_check') || ($this->flags & self::F_CRC_CHECK))
	$this->crc_check();

// As required extensions are added to the enclosing package when a subpackage
// is inserted, we don't have to check subpackages for required extensions.

if (is_null($this->parent_mnt))
	{
	if (!is_null($extensions=$this->option('required_extensions')))
		PHK_Util::load_extensions($extensions);
	}

if ($this->map_defined())
	{
	Automap::mount($this->automap_uri(),$this->base_uri(),$this->mnt);
	}

//-- Call the mount script - if the mount script wants to refuse the mount,
//-- it throws an exception.

if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT)
	&& (!is_null($mpath=$this->option('mount_script'))))
		{ require $this->uri($mpath); }

//-- Create the plugin_object

if (!is_null($c=$this->option('plugin_class')))
	$this->plugin=new $c($this->mnt);
}
catch (Exception $e)
	{
	throw new Exception('While initializing PHK instance - '.$e->getMessage());
	}
}

//---------

public function map_defined()
{
if ($this->flags & PHK::F_CREATOR) return false;

return $this->build_info('map_defined');
}

//---------

public function mtime()
{
return $this->mtime;
}

//---------

public function set_cache($toggle)
{
$this->caching=$toggle;
}

//---------
/**
* Check if a given path contains a PHK package
*
* @param string $path	path to check (can be virtual)
* @return boolean
*/

public static function file_is_package($path)
{
return PHK_Proxy::file_is_package($path);
}

//---------
/**
* Check if a data buffer contains a PHK package
*
* @param string $data	data buffer to check
* @return boolean
*/

public static function data_is_package($data)
{
return PHK_Proxy::data_is_package($data);
}

//-----

public function cache_enabled($command,$params,$path)
{
if ($this->flags & PHK::F_CREATOR) return false;

if ($this->option('no_cache')===true) return false;

if (!PHK_Cache::cache_present()) return false;

if (!is_null($this->caching)) return $this->caching;

return true;
}

//-----
// Umount this entry.
// We dont use __destruct because :
//	1. We don't want this to be called on script shutdown
//	2. Exceptions cannot be caught when sent from a destructor.

public function umount()
{
//-- Destroy the plugin

if (!is_null($this->plugin)) unset($this->plugin);

//-- Call the umount script

if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT))	// Call the umount script
	{
	if (!is_null($upath=$this->option('umount_script')))
		{ require($this->uri($upath)); }
	}

//-- Unload the automap

if ($this->map_defined()) Automap::umount($this->mnt);
}

//-----

public function mnt()
{
return $this->mnt;
}

//-----

public function flags()
{
return $this->flags;
}

//-----

public function path()
{
return $this->path;
}

//-----

public function uri($path)
{
return PHK_Mgr::uri($this->mnt,$path);
}

//-----

public function section_uri($section)
{
return PHK_Mgr::section_uri($this->mnt,$section);
}

//-----

public function command_uri($command)
{
return PHK_Mgr::command_uri($this->mnt,$command);
}

//-----

public function base_uri()
{
return PHK_Mgr::base_uri($this->mnt);
}

//-----
/**
* Returns the URI of the Automap
*
* @return string
*/

public function automap_uri()
{
return PHK_Mgr::automap_uri($this->mnt);
}

//-----
/**
* Returns an option
*
* If the option is not set, returns null.
*
* The 'OPTIONS' section is mandatory in a package.
*
* @param string $key The option name
* @return any|null Option value or null if the requested option is not set
*/


public function option($key)
{
return (isset($this->options[$key]) ? $this->options[$key] : null);
}

//-----
/**
* Returns the whole options array
*
* The 'OPTIONS' section is mandatory in a package.
*
* @return array
*/


public function options()
{
return $this->options;
}

//-----

public function parent_mnt()
{
return $this->parent_mnt;
}

//---------------------------------

public function web_access_allowed($path)
{
$plen=strlen($path);

foreach(PHK_Util::mk_array($this->option('web_access')) as $apath)
	{
	if ($apath=='/') return true;
	$alen=strlen($apath);
	if (($plen >= $alen) && (substr($path,0,$alen)==$apath)
		&& (($alen==$plen)||($path{$alen}=='/')))
		return true;
	}

return false;
}

//---------------------------------
// Transfer control to main script (web mode)
// Two methods: redirect or transparently execute main script.

private function goto_main($web_run_script)
{
if ($this->option('web_main_redirect'))
	{
	PHK_Util::http_301_redirect($web_run_script);
	}
else return 'require(\''.$this->uri($web_run_script).'\');';
}

//---------------------------------
// Returns the code to display or execute a subfile from the calling code. We
// cannot directly include the subfile from this function because the variable
// scope must be the calling one.
// Use as : eval($phk->web_tunnel([$path [,webinfo mode]]));
// This function is supposed to transfer control in as transparent a manner as
// possible.
// If the given path is a directory, tries to find an index.[htm|html|php] file.
// This function does not support subpaths in PHK subfiles.

public function web_tunnel($path=null,$webinfo=false)
{
if (is_null($path)) $path=PHK::get_subpath();
$last_slash=(substr($path,-1)=='/');
if ($path!='/') $path=rtrim($path,'/');
$web_run_script=$this->option('web_run_script');
$mnt=$this->mnt();

if ($path=='')
	{
	if (!is_null($web_run_script)) return $this->goto_main($web_run_script); 
	else PHK_Util::http_301_redirect('/'); // Redirect to the virtual root dir
	}

// If a package use a path as both file and http paths, we can receive
// a PHK URI. Handle this. Ugly: to be suppressed when PHP makes
// current directory compatible with stream wrappers.
// We check for one or two '/' between 'phk:' and $mnt because Apache removes
// the 2nd '/'.
// Suppressed in v 1.4.0: don't know if still useful ?

//$path=str_replace('phk:/'.$mnt.'/','',$path);
//$path=str_replace('phk://'.$mnt.'/','',$path);

// Access enabled ? If not in the enabled paths, go to the main script
// Allows to support a mod_rewrite-like feature where a single entry point
// gets every request.

if ((!$webinfo) && (!$this->web_access_allowed($path))
	&& ($path!==$web_run_script))
	{
	if (!is_null($web_run_script)) return $this->goto_main($web_run_script); 
	else PHK_Util::http_403_fail();	// Returns 'Forbidden'
	}

// File exists ?

$uri=$this->uri($path);

if (($a=@stat($uri))===false) PHK_Util::http_404_fail();

if (($a['mode'] & 0170000) == 040000)	// Special case for directory
	{
	$file_path=null;
	if ($last_slash)	// Search a DirectoryIndex
		{
		foreach(array('index.htm', 'index.html', 'index.php') as $fname)
			{
			if (is_file($this->uri($path.'/'.$fname)))
				{
				$file_path=$path.'/'.$fname;
				break;
				}
			}
		if (is_null($file_path)) PHK_Util::http_404_fail(); // No Directory Index
		}
	else PHK_Util::http_301_redirect($path.'/');
	}
else $file_path=$path;

// Now, we return the string which will be used by the calling environment
// to execute the file if it is a PHP source, or to output its content
// with the correct mime type. Execution is disabled in webinfo mode

if ((!$webinfo) && ($this->is_php_source_path($file_path)))
	{
	return "require('".$this->uri($file_path)."');";
	}
else
	{
	return "PHK_Mgr::instance('".$this->mnt."')->mime_header('$file_path');\n"
		."readfile('".$this->uri($file_path)."');";
	}
}

//---------------------------------
/**
* Sends a mime header corresponding to a path
*
* Actually, we use only the file suffix (the path can correspond to an existing
*	node or not).
*
* If the suffix does not correspond to anything we know, nothing is sent
*	(defaults to text/html on Apache, don't know if it can change on another
*	SAPI).
*
* @param string $path
* @return void
*/

public function mime_header($path)
{
if (!is_null($type=$this->mime_type($path))) header('Content-type: '.$type);
}

//---------
/**
* Returns the mime-type corresponding to a given path, or null if the
* suffix does not correspond to anything we know
*
* Searches :
*
* 1. The 'mime-types' option
* 2. The built-in mime table
* 3. If the suffix contains 'php', sets the type to 'application/x-httpd-php'
*
* @param string $path
* @return string|null The mime type or null if file suffix is unknown
*/

public function mime_type($path)
{
$ext=PHK_Util::file_suffix($path);

if ((!is_null($mtab=$this->option('mime_types'))) && isset($mtab[$ext]))
	return $mtab[$ext];

if (isset(self::$mime_table[$ext])) return self::$mime_table[$ext];

if (strpos($ext,'php')!==false)	return 'application/x-httpd-php';

return null;
}

//---------
/**
* Should we consider this path as a PHP source file ?
*
* In order to be identified as PHP source, a path must be associated with Mime
* type 'application/x-httpd-php'.
*
* @param string $path
* @return boolean
*/

public function is_php_source_path($path)
{
return ($this->mime_type($path)==='application/x-httpd-php');
}

//---------

public function proxy()
{
return PHK_Mgr::proxy($this->mnt);
}

//---------
/**
* Checks the CRC of the PHK archive file
*
* Generates an exception if the check fails
*
* @return void
* @throws Exception
*/

public function crc_check()
{
$this->proxy()->crc_check();
}

//---------

public function supports_php_version()
{
if ((!is_null($minv=$this->option('min_php_version')))
	&& (version_compare(PHP_VERSION,$minv) < 0))
		throw new Exception("PHP minimum supported version: $minv (current is ".PHP_VERSION.")");

if ((!is_null($maxv=$this->option('max_php_version')))
	&& (version_compare(PHP_VERSION,$maxv) > 0))
		throw new Exception("PHP maximum supported version: $maxv (current is ".PHP_VERSION.")");
}

//---------------------------------
/**
* Returns the associated plugin object if defined, or null if not
*
* @return plugin_object|null
*/

public function plugin()
{
return $this->plugin;
}

//-----
/**
* Is the PHK accelerator in use or not ?
*
* @return boolean
*/

public static function accelerator_is_present()
{
return false;
}

//-----
/**
* Returns a build-time information field or the whole array
*
* Unlike options, an unknown key throws an error
*
* @param string|null $name Field name
* @return array|string|null The field's content or null if it does not exist
*/

public function build_info($name=null)
{
if (is_null($name)) return $this->build_info;

if (!isset($this->build_info[$name]))
	throw new Exception($name.': unknown build info');

return $this->build_info[$name];
}

//---------------------------------

public static function subpath_url($path)
{
return PHK_Backend::subpath_url($path);
}

//---------------------------------
// Get the sub-path from an URL. Because of the problems with CGI mode, we
// have to support 2 syntaxes :
// http://<site>/.../<phk_file><path>
// http://<site>/.../<phk_file>?_PHK_path=<path>

public static function get_subpath()
{
$path='';

if (isset($_REQUEST['_PHK_path'])) $path=urldecode($_REQUEST['_PHK_path']);
else
	{
	$path=isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : '';
	if ($path=='' && isset($_SERVER['ORIG_PATH_INFO']))
		$path=$_SERVER['ORIG_PATH_INFO'];
	}

if (($path!='') && ($path{0}!='/')) $path='/'.$path;

return $path;
}

//----
// Undocumented

private function backend()
{
if (is_null($this->backend)) $this->backend=new PHK_Backend($this);

return $this->backend;
}

//--------------
// Forward unknown method calls to the slow backend

public function __call($method,$args)
{
return PHK_Util::call_method($this->backend($this),$method,$args);
}

//---------

public static function prolog($file,&$cmd,&$ret)
{
# Do we run in CLI mode ?

if ($cli=(!PHK_Util::is_web()))
	{
	ini_set('display_errors',true);
	ini_set('memory_limit','1024M'); // Only in CLI mode
	}

PHK_Mgr::php_version_check();	//-- Check PHP version - if unsupported, no return

//-----
// Mount the PHK file (or get the mount point if previously mounted)

try {
	$mnt=PHK_Mgr::mount($file);
	$phk=PHK_Mgr::instance($mnt);
	}
catch (Exception $e)
	{		
	if (getenv('PHK_DEBUG')!==false) throw $e;
	echo '** Fatal error: Cannot mount PHK file - '.$e->getMessage()."\n";
	exit(1);
	}
//PHK_Util::trace("Prolog mounted $file on $mnt");//TRACE

//-----
// Am I a main script ?
// When there are symbolic links in the path, get_included_files() returns
// 2 paths, the logical one first, and then the real one.

$tmp=get_included_files();
$main=(($tmp[0]===$file) || (realpath($tmp[0]) === $file));

if (!$main)	// Not main script
	{
	if (!is_null($script=$phk->option('lib_run_script')))
		{ require($phk->uri($script)); }

	if ($phk->option('auto_umount'))
		{
		PHK_Mgr::umount($mnt);
		$ret='';
		}
	else $ret=$mnt;
	return;
	}

//-----------------
// Main script - Dispatch

if ($cli)
	{
	if (($_SERVER['argc']>1) && ($_SERVER['argv'][1]!='')
		&& ($_SERVER['argv'][1]{0}=='@'))
		{
		$ret=$phk->builtin_prolog($file);
		return;
		}

	// Not a command: call cli_run

	if (!is_null($run_path=$phk->option('cli_run_script')))
		{
		$cmd="require('".$phk->uri($run_path)."');";
		}
	return;
	}
else	// HTTP mode
	{
	if (file_exists($file.'.webinfo'))	// Slow path
		{
		PHK_Util::run_webinfo($phk);
		}
	else
		{
		$cmd=$phk->web_tunnel();
		}
	}
}

//---------------------------------
} // End of class PHK_Base
//-------------------------
} // End of class_exists('PHK_Base')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK',false))
{
// /---------------

//=============================================================================
/**
* This class is just an empty extension of the PHK_Base class. This is done
* this way so that PHK_Creator uses the PHP code even if the extension
* is present.
*
* @see PHK_Base
*/

class PHK extends PHK_Base
{

//---------------
// If we get here, the PHP runtime is already loaded.
// But the method has to exist.

public static function need_php_runtime()
{
}

//---------------------------------
} // End of class PHK
//-------------------------
} // End of class_exists('PHK')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Backend',false))
{
//=============================================================================
/**
* This class contains the non-accelerated runtime code. This code must
* never be called by the 'fast path' scenarios.
*
* Each PHK_Backend instance is associated with a 'front-end' PHK instance
* (accelerated or not).
*/

class PHK_Backend
{

private $front; // PHK front-end

//--------------

public function __construct($front)
{
$this->front=$front;
}

//---------------------------------

public function __get($name)
{
return $this->front->$name();
}

//---------------------------------

public function __call($method,$args)
{
return call_user_func_array(array($this->front,$method),$args);
}

//---------------------------------

public function test()
{
// Remove E_NOTICE messages if the test script is a package - workaround
// to PHP bug #39903 ('__COMPILER_HALT_OFFSET__ already defined')

error_reporting(($errlevel=error_reporting()) & ~E_NOTICE);

if (!is_null($test_script=$this->option('test_script')))
	{
	$test_uri=$this->uri($test_script);
	require($test_uri);
	}
elseif (!is_null($phpunit_test_package=$this->option('phpunit_test_package')))
	{
	if (!is_null($phpunit_package=$this->option('phpunit_package')))
		{ $phpunit_package_mnt=require $this->uri($phpunit_package); }
	else $phpunit_package_mnt=null;

	$phpunit_test_package_mnt=require $this->uri($phpunit_test_package);

	_phk_load_phpunit_interface();
	define('PHPUnit_MAIN_METHOD', 'PHPUnit_TextUI_PHK::main');
	PHPUnit_TextUI_PHK::main();

	if (!is_null($phpunit_package_mnt)) PHK_Mgr::umount($phpunit_package_mnt);

	if (!is_null($phpunit_test_package_mnt))
		PHK_Mgr::umount($phpunit_test_package_mnt);
	}
else echo "No unit tests\n";

error_reporting($errlevel);
}

//---------------------------------
// Display the environment
// This function cannot be cached

public function envinfo()
{
$html=PHK_Util::is_web();

//-- Accelerator

self::info_section($html,'PHK Accelerator');

self::start_info_table($html);
if (PHK::accelerator_is_present()) PHK::accel_techinfo();
else self::show_info_line($html,'PHK Accelerator','No');

self::info_section($html,'Automap Accelerator');

self::start_info_table($html);
if (Automap::accelerator_is_present()) Automap::accel_techinfo();
else self::show_info_line($html,'Automap Accelerator','No');

self::info_section($html,'Cache');

self::show_info_line($html,'Cache system used',PHK_Cache::cache_name());
self::end_info_table($html);

//-- Environment

self::info_section($html,'Environment');

self::start_info_table($html);
self::show_info_line($html,'PHP SAPI',php_sapi_name());
self::show_info_line($html,'Mount point',$this->mnt);

//-- Mount options

$string='';
$class=new ReflectionClass('PHK');
foreach($class->getConstants() as $name => $value)
	{
	if ((strlen($name)>1) && (substr($name,0,2)=='F_')
		&& ($this->flags & $value)) $string .= ','.strtolower(substr($name,2));
	}
unset($class);
$string=trim($string,',');
self::show_info_line($html,'Current mount options'
	,$string=='' ? '<none>' : $string);
self::end_info_table($html);
}

//---------------------------------
// Display the file tree

public function showfiles()
{
$this->proxy()->showfiles();
}

//---------------------------------
// Display Automap map content or <empty> message

public function showmap($subfile_to_url_function=null)
{
if ($this->map_defined())
	Automap::instance($this->mnt)->show($subfile_to_url_function);
else echo "Automap not defined\n";
}

//-----
/**
* <Info> Displays information about the plugin
*
* If the plugin object defines a method name '_webinfo', this method is called
* with the $html parameter.
*
* If the plugin is not defined, just displays a small informative message
*
* @param boolean $html Whether to display in html or raw text
* @return void
*/

private function plugin_info($html)
{
self::info_section($html,'Plugin');

if (is_null($class=$this->option('plugin_class')))
	{
	echo ($html ? '<p>' : '')."Not defined\n";
	return;
	}

if ($this->is_callable_plugin_method('_webinfo'))
	{
	$this->call_plugin_method('_webinfo',$html);
	echo $html ? '<p>' : "\n";
	}

self::start_info_table($html);

self::show_info_line($html,'Class',$class);

$rc=new ReflectionClass($class);

foreach ($rc->getMethods() as $method)
	{
	if ((!$method->isPublic())||($method->isStatic())
		||($method->isConstructor())||($method->isDestructor())
		||($method->getName()==='_webinfo')) continue;
	$name=$method->getName();
	$a=array();
	foreach($method->getParameters() as $param)
		{
		$s='$'.$param->getName();
		if ($param->isPassedByReference()) $s='&'.$s;
		if ($param->isArray()) $s = 'Array '.$s;
		if ($param->isOptional())
			{
			if ($param->isDefaultValueAvailable())
				$s .= ' = '.var_export($param->getDefaultValue(),true);
			$s = '['.$s.']';
			}
		$a[]=$s;
		}
	self::show_info_line($html,'Method',$name.' ( '.implode(', ',$a).' )');
	}
		
self::end_info_table($html);
}

//-----
/**
* <Info> Displays an option and its value
*
* An URL can be set in an option. Syntax: 'text to display <url>'
* In HTML mode, only the text is displayed and an hyperlink is generated
* In text mode, it is displayed as-is.
* URLs starting with 'http://' are automatically recognized

* @param boolean $html Whether to display in html or raw text
* @param string $opt Option name
* @return void
*/

private function show_option($html,$opt,$default=null)
{
$str1=ucfirst(str_replace('_',' ',$opt));

$url=null;
$newwin=true;
if (is_null($val=$this->option($opt))) $val=$default;

if ($html && ereg('^(.*)[ 	]<([^ 	]+)>.*$',$val,$regs))
	{	// If the value contains an URL
	$str2=trim($regs[1]);
	$url=$regs[2];
	if ($str2=='') $str2=$url;
	}
else
	{
	$str2=$val;
	$vlen=strlen($val);
	if (($vlen>=7)&&(substr($val,0,7)=='http://')) $url=$val;
	elseif (($vlen>=1) && ($val{0}=='/') && file_exists($this->uri($val)))
		{
		// Warning: We build an HTTP URL going to PHK_Webinfo, not a
		// stream wrapper URI.
		$url=PHK::subpath_url('/view/'.trim($val,'/'));
		$newwin=false;
		}
	}

self::show_info_line($html,$str1,$str2,$url,$newwin);
}

//-----
/**
* <Info> Start a new information section
*
* @param boolean $html Whether to display in html or raw text
* @param string $title The title to display
* @return void
*/

public static function info_section($html,$title)
{
echo $html ? '<h2>'.htmlspecialchars($title).'</h2>'
	: "\n==== ".str_pad($title.' ',70,'='). "\n\n";
}

//-----
/**
* <Info> Displays an information line
*
* In html mode, the information is displayed in a table. This table must
* have been opened by a previous call to PHK::start_info_table().
*
* Note: The URLs starting with a '/' char are internal (generated by PHK_Webinfo
* ) and, so, are displayed in html mode only.
*
* @param boolean $html Whether to display in html or raw text
* @param string $string The left side (without ':')
* @param string|boolean $value The value to display. If boolean, displays 'Yes'
*    or 'No'.
* @param string|null $url An URL to associate with this value. Null if no URL.
* @param boolean $newwin Used in html mode only. Whether the URL link opens
*    a new window when clicked.
* @return void
*
* @see start_info_table()
* @see end_info_table()
*/

public static function show_info_line($html,$string,$value,$url=null
	,$newwin=true)
{
if (is_null($value)) $value='<>';
if (is_bool($value)) $value=PHK_Util::bool2str($value);

if ($html)
	{
	echo '<tr><td>'.htmlspecialchars($string).':&nbsp;</td><td>';
	if ($url)
		{
		echo '<a href="'.$url.'"';
		if ($newwin) echo ' target="_blank"';
		echo '>';
		}
	echo htmlspecialchars($value);
	if ($url) echo '</a>';
	echo '</td></tr>';
	}
else
	{
	echo "$string: $value";
	if ((!is_null($url)) && ($url{0}!='/')) echo " <$url>";
	echo "\n";
	}
}

//-----
/**
* <Info> Starts an HTML table
*
* In text mode, does nothing.
*
* This function is public because it can be called from the plugin's _webinfo
* method.
*
* @param boolean $html Whether to display in html or raw text
* @return void
*/

public static function start_info_table($html)
{
echo $html ? '<table border=0>' : '';
}

//-----

public static function end_info_table($html)
{
echo $html ? '</table>' : '';
}

//-----
// Display non technical information
// Webinfo default welcome page

public function info()
{
$html=PHK_Util::is_web();

if ($html && (!is_null($info_script=$this->option('info_script'))))
	{ require($this->uri($info_script)); }
else
	{
	self::start_info_table($html);
	$this->show_option($html,'name');
	$this->show_option($html,'summary');
	$this->show_option($html,'version');
	$this->show_option($html,'release');
	$this->show_option($html,'distribution');
	$this->show_option($html,'license');
	$this->show_option($html,'copyright');
	$this->show_option($html,'url');
	$this->show_option($html,'author');
	$this->show_option($html,'packager');
	$this->show_option($html,'requires');

	$req=implode(' ',PHK_Util::mk_array($this->option('required_extensions')));
	if ($req=='') $req='<none>';
	self::show_info_line($html,'Required extensions',$req);

	self::end_info_table($html);
	}
}

//-----

public function techinfo()
{
$html=PHK_Util::is_web();

self::info_section($html,'Package');

self::start_info_table($html);
$this->show_option($html,'name');
$this->show_option($html,'summary');
$this->show_option($html,'version');
$this->show_option($html,'release');
$this->show_option($html,'distribution');
$this->show_option($html,'license');
$this->show_option($html,'copyright');
$this->show_option($html,'url');
$this->show_option($html,'author');
$this->show_option($html,'packager');
$this->show_option($html,'requires');
self::show_info_line($html,'Signed',$this->proxy()->signed());
self::show_info_line($html,'Automap defined',$this->map_defined());
self::show_info_line($html,'File path',$this->path);
self::show_info_line($html,'File size',filesize($this->path));

$req=implode(', ',PHK_Util::mk_array($this->option('required_extensions')));
if ($req=='') $req='<none>';
self::show_info_line($html,'Required extensions',$req);

self::show_info_line($html,'Build date'
	,PHK_Util::timestring($this->build_info('build_timestamp')));
$this->show_option($html,'icon');
$this->show_option($html,'crc_check',false);
$this->show_option($html,'help_prefix');
$this->show_option($html,'license_prefix');
$this->show_option($html,'auto_umount',false);
$this->show_option($html,'no_cache',false);
$this->show_option($html,'no_opcode_cache',false);
$this->show_option($html,'prolog_code_creator',false);
$this->show_option($html,'plain_prolog',false);
self::show_info_line($html,'File count',count($this->path_list()));
self::end_info_table($html);

$this->plugin_info($html);

self::info_section($html,'Package scripts');

self::start_info_table($html);
$this->show_option($html,'cli_run_script');
$this->show_option($html,'web_run_script');
$this->show_option($html,'lib_run_script');
$this->show_option($html,'info_script');
$this->show_option($html,'mount_script');
$this->show_option($html,'umount_script');
$this->show_option($html,'test_script');
$this->show_option($html,'phpunit_package');
$this->show_option($html,'phpunit_test_package');

self::end_info_table($html);

self::info_section($html,'Module versions');

self::start_info_table($html);
self::show_info_line($html,'PHK_Creator',$this->build_info('PHK_Creator_version'));
self::show_info_line($html,'PHK min version',$this->build_info('PHK_min_version'));
self::show_info_line($html,'Automap_Creator class',$this->build_info('Automap_creator_version'));
self::show_info_line($html,'Automap min version',$this->build_info('Automap_min_version'));
self::show_info_line($html,'PHK_PSF class',$this->build_info('PHK_PSF_version'));
self::end_info_table($html);

self::info_section($html,'Sub-packages');

ob_start();
$this->proxy()->display_packages();
$data=ob_get_clean();
if ($data==='')	echo ($html ? '<p>' : '')."None\n";
else echo $data;

self::info_section($html,'Web direct access');

self::start_info_table($html);
$list=PHK_Util::mk_array($this->option('web_access'));
self::show_info_line($html,'State',count($list) ? 'Enabled' : 'Disabled');
$this->show_option($html,'web_main_redirect',false);
foreach($list as $path) self::show_info_line($html,'Path',$path);
self::end_info_table($html);

//-- Options

self::info_section($html,'Package options');

$a=$this->options();
$data=(is_null($a) ? '<>' : print_r($a,true));
echo ($html ? ('<pre>'.htmlspecialchars($data).'</pre>') : $data);

//-- Sections

self::info_section($html,'Sections');
$this->proxy()->stree()->display(false);
}

//-----
/**
* Returns a subfile content for a multi-type metafile
*
* File name : <prefix>.<type> - Type is 'txt' or 'htm'.
*
* A text file can be transformed to html, but the opposite is not possible.
*
* Type is determined by the SAPI type (CLI => txt, else => htm).
*
* @param string $prefix Prefix to search for
* @return string|null The requested content or null if not found
*/

public function auto_file($prefix)
{
$html=PHK_Util::is_web();
$txt_suffixes=array('.txt','');
$suffixes=($html ? array('.htm','.html') : $txt_suffixes);

$base_path=$this->uri($prefix);
foreach($suffixes as $suffix)
	{
	if (is_readable($base_path.$suffix))
		{
		return PHK_Util::readfile($base_path.$suffix);
		break;
		}
	}

// If html requested and we only have a txt file, tranform it to html

if ($html)
	{
	foreach ($txt_suffixes as $suffix)
		if (is_readable($base_path.$suffix))	
			return '<pre>'.htmlspecialchars(PHK_Util::readfile($base_path.$suffix))
				.'</pre>';
	}

return null;
}

//-----
/**
* Returns a multi-type content from an option name
*
* Option ($name.'_prefix') gives the prefix to send to auto_file()
*
* @param string $name Option prefix
* @return string Requested content or an informative error string.
*/

public function auto_option($name)
{
$data=null;

$prefix=$this->option($name.'_prefix');

if (!is_null($prefix)) $data=$this->auto_file($prefix);

if (is_null($data))
	{
	$data='<No '.$name.' file>'."\n";
	if (PHK_Util::is_web()) $data=htmlspecialchars($data);
	}

return $data;
}

//-----
/**
* Checks if the plugin class is defined and contains a given method
*
* @param string $method
* @return boolean
*/

public function is_callable_plugin_method($method)
{
return (is_null($this->plugin)) ? false
	: is_callable(array($this->plugin,$method));
}

//-----
/**
* Calls a given method in the plugin object
*
* @param string method
* @return * the method's return value
* @throws Exception if the plugin or the method does not exist
*/

public function call_plugin_method($method)
{
if (!$this->is_callable_plugin_method($method))
	throw new Exception($method.': Undefined plugin method');

$args=func_get_args();
array_shift($args);

return call_user_func_array(array($this->plugin,$method),$args);
}

//-----

public function path_list()
{
return unserialize(file_get_contents($this->command_uri(__FUNCTION__)));
}

//-----

public function section_list()
{
return unserialize(file_get_contents($this->command_uri(__FUNCTION)));
}

//---------------------------------
// Workaround for PHP bug/issue when trying to use PATH_INFO when PHP is
// run as an Apache CGI executable. In this mode, an url in the form of
// 'http://.../.../file.php/args' does not go to file.php but returns
// 'No input file specified'. There, we have to pass args the 'usual'
// way (via $_REQUEST).
// Drawback: as the URL now contains a '?' char, most browsers refuse to cache
// it, even with the appropriate header fields, causing some useless traffic
// when navigating in the tabs and flicking on the screen. So, the preferred
// method is via PATH_INFO.
// Allows a PHK package to become fully compatible with CGI mode by computing
// every relative URLs through this method.

public static function subpath_url($path)
{
if ($path{0}!='/') $path=PHK::get_subpath().'/'.$path; //-- Make path absolute
$path=ereg_replace('//+','/',$path);

return PHK_Util::http_base_url().((php_sapi_name()=='cgi')
	? ('?_PHK_path='.urlencode($path)) : $path);
}

//-----

private static function cmd_usage($msg=null)
{
if (!is_null($msg)) echo "** ERROR: $msg\n";

echo "\nAvailable commands:\n\n";
echo "	- @help             Display package help\n";
echo "	- @license          Display license\n";
echo "	- @get <path>       Display a subfile content\n";
echo "	- @showmap          Display automap, if present\n";
echo "	- @showfiles        List subfiles\n";
echo "	- @option <name>    Display a package option\n";
echo "	- @set_interp <string>  Set the first line of the PHK to '#!<string>'\n";
echo "	- @info             Display information about the PHK file\n";
echo "	- @techinfo         Display technical information\n";
echo "	- @dump <directory> Extracts the files\n";
echo "	- @test [switches] [UnitTest]  Run the package's unit tests\n";

if (!is_null($msg)) exit(1);
}

//-----

public function builtin_prolog($file)
{
$retcode=0;

try
{
$this->proxy()->crc_check();

$command=PHK_Util::substr($_SERVER['argv'][1],1);
array_shift($_SERVER['argv']);
$param=isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : null;

switch($command)
	{
	case 'get':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");
		$uri=$this->uri($param);
		if (is_file($uri)) readfile($uri);
		else throw new Exception("$param: file not found");
		break;

	case 'test':
		$this->test();
		break;

	case 'showmap':
	case 'info':
	case 'techinfo':
	case 'showfiles':
		$this->$command();
		break;

	case 'option':
		$res=$this->$command($param);
		if (is_null($res)) throw new Exception('Option not set');
		echo "$res\n";
		break;

	case 'set_interp':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");

		//-- This is the only place in the runtime code where we write something
		//-- into an existing PHK archive.

		if (file_put_contents($file
			,PHK_Proxy::set_buffer_interp($file,$param))===false)
			throw new Exception('Cannot write file');
		break;

	case 'license':
	case 'help':
		echo $this->auto_option($command);
		break;

	case 'dump':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");
		$this->proxy()->ftree()->dump($param);
		break;

	case '':
		self::cmd_usage();
		break;

	default:
		self::cmd_usage($command.': Unknown command');
	}

PHK_Util::display_slow_path();
}
catch (Exception $e)
	{
	if (getenv('PHK_DEBUG')!==false) throw $e;
	echo "** ERROR: Command failed ($command) - ".$e->getMessage()."\n";
	$retcode=1;
	}

return $retcode;
}

//---------------------------------
} // End of class PHK_Backend
//-------------------------
} // End of class_exists('PHK_Backend')
//=============================================================================

//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Stream',false))
{
// /---------------

/**
* The PHK stream wrapper
*
* Handles every file access to an 'phk://...' URI
*
* Note: Always catch exceptions before returning to PHP.
*/

class PHK_Stream extends PHK_Util
{

private $uri;

private $mnt;		// Mount point (string)
private $path;		// File path in PHK (string|null)
private $command;	// Command (string|null)
private $params;	// Command parameter (array|null)

private $data;	// File data (regular file) or dir content
private $size;	// Size of buffer or number of dir entries
private $position; // Byte position or position in array

private $raise_errors=true;

//---------------------------------
// Display a warning if they are allowed

private function raise_warning($msg)
{
if ($this->raise_errors) trigger_error("PHK: $msg",E_USER_WARNING);
}

//---------------------------------

public static function get_file($dir,$uri,$mnt,$command,$params,$path,$cache=null)
{
$cache_id=PHK_Cache::cache_id('node',$uri);
//PHK_Util::trace("Cache ID : <$cache_id>");//TRACE

if (is_null($data=PHK_Cache::get($cache_id)))	// Miss
	{
	$can_cache=true;
	
	if (is_null($data=($dir ?
		PHK_Stream_Backend::get_dir_data($mnt,$command,$params,$path)
		: PHK_Stream_Backend::get_file_data($mnt,$command,$params,$path
			,$can_cache)))) throw new Exception("$uri: File not found");

	if ($can_cache && (($cache===true) || (is_null($cache)
		&& PHK_MGR::cache_enabled($mnt,$command,$params,$path))))
			PHK_Cache::set($cache_id,$data);
	}

if ($dir && (!is_array($data))) throw new Exception('Not a directory');
if ((!$dir) && (!is_string($data))) throw new Exception('Not a regular file');

return $data;
}

//---------------------------------
// Open a file - only read mode is supported
// STREAM_USE_PATH is ignored
// Fast path: Yes (only when data is found in the cache)
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function stream_open($uri,$mode,$options,&$opened_path)
{
//echo "<br>Starting stream_open: uri=$uri\n";//TRACE

try
{
$this->uri=$uri;
$this->raise_errors=($options & STREAM_REPORT_ERRORS);
if ($options & STREAM_USE_PATH) $opened_path=$uri;

if (($mode!='r')&&($mode!='rb'))
	throw new Exception($mode.': unsupported mode (Read only)');

self::parse_uri($uri,$this->command,$this->params,$this->mnt,$this->path);

if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);

$this->data=self::get_file(false,$uri,$this->mnt,$this->command
	,$this->params,$this->path);

$this->size=strlen($this->data);
$this->position=0;
}
catch (Exception $e)
	{
	$msg=$uri.': Open error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
//PHK_Util::trace("Exiting stream_open: uri=$uri");//TRACE
return true;
}

//---------------------------------
// Read on an open file

public function stream_read($nb)
{
//echo "Starting stream_read: uri=".$this->uri." - nb=$nb - position="
//	.$this->position." size=".$this->size."\n";//TRACE

if ($this->position==$this->size) return false;
$max=$this->size-($pos=$this->position);
if ($nb > $max) $nb=$max;
$this->position+=$nb;

return substr($this->data,$pos,$nb);
}

//---------------------------------
// Are we at the end of an open file ?

public function stream_eof()
{
return ($this->position==$this->size);
}

//---------------------------------
// Return current position in an open stream

public function stream_tell()
{
return $this->position;
}

//---------------------------------
// Seek on an open file

public function stream_seek($offset,$whence)
{
//echo "Starting stream_seek: uri=".$this->uri." - offset=$nb - whence=$whence\n";//TRACE

switch($whence)
	{
	case SEEK_CUR: $this->position+=$offset; break;
	case SEEK_END: $this->position=$this->size+$offset; break;
	default: $this->position=$offset; break;
	}
if ($this->position > $this->size) $this->position=$this->size;
if ($this->position < 0) $this->position=0;
return true;
}

//---------------------------------
// Open a directory
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function dir_opendir($uri,$options)
{
try
{
$this->uri=$uri;
$this->raise_errors=($options & STREAM_REPORT_ERRORS);

self::parse_uri($uri,$this->command,$this->params,$this->mnt
	,$this->path);

if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);

$this->data=self::get_file(true,$uri,$this->mnt,$this->command
	,$this->params,$this->path);

$this->size=count($this->data);
$this->position=0;
}
catch (Exception $e)
	{
	$msg=$uri.': PHK opendir error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
return true;
}

//---------------------------------
// Get next directory entry

public function dir_readdir()
{
if ($this->position==$this->size) return false;
return $this->data[$this->position++];
}

//---------------------------------
// Set open directory index to 0

public function dir_rewinddir()
{
$this->position=0;
}

//---------------------------------
// Utility function called by stream_stat and url_stat

private static function stat_array($mode,$size,$mtime)
{
return array(
	'dev' => 0,
	'ino' => 0,
	'mode' => $mode,
	'nlink' => 1,
	'uid' => 0,
	'gid' => 0,
	'rdev' => -1,
	'size' => $size,
	'atime' => $mtime,
	'mtime' => $mtime,
	'ctime' => $mtime,
	'blksize' => 8192,
	'blocks' => 1);
}

//---------------------------------
// Stat an open file (fstat)

public function stream_stat()
{
return $this->url_stat($this->uri,0,true);
}

//---------------------------------
// Stat an open or closed path - PHP streams API
//
// url_stat does not throw exceptions. It must just return false.
//
// This method must not modify properties (except for parsing the URI),
// because it can be called on an open path.
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function url_stat($uri,$flags,$fstat=false)
{
//PHK_Util::trace("Entering url_stat($uri,$flags,$fstat)";//TRACE

try
{
$this->raise_errors=!($flags & STREAM_URL_STAT_QUIET);

// If we are coming from stream_fstat(), the uri is already parsed.

if (!$fstat)
	{
	self::parse_uri($uri,$this->command,$this->params,$this->mnt
		,$this->path);

	if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);
	}

$cache_id=PHK_Cache::cache_id('stat',$uri);
if (is_null($data=PHK_Cache::get($cache_id)))	// Miss - Slow path
	{
	//PHK_Util::trace("url_stat($uri): not found in cache";//TRACE
	try
		{
		$cache=true;
		$mode=$size=$mtime=null;
		PHK_Stream_Backend::get_stat_data($this->mnt,$this->command
			,$this->params,$this->path,$cache,$mode,$size,$mtime);
		$data=array($mode,$size,$mtime);
		}
	catch (Exception $e) // Mark entry as non-existent
		{
		//PHK_Util::trace("url_stat($uri): lookup failed");//TRACE
		$data='';
		}

	if ($cache && (!is_null($this->mnt)) && PHK_MGR::cache_enabled($this->mnt
		,$this->command,$this->params,$this->path))
		{
		PHK_Cache::set($cache_id,$data);
		}
	}

if (is_array($data))
	{
	list($mode,$size,$mtime)=$data;
	return self::stat_array($mode,$size,$mtime);
	}
else throw new Exception('File not found');	// Negative hit
}
catch (Exception $e)
	{
	$msg=$uri.': PHK Stat error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
}

//---------------------------------
/**
* Parses an URI and splits it into four sub-parts : mount point, command name,
* command parameters, and path. Each of these components is optional.
*
* URI syntax: phk://[<mnt>[/path]][?command[&par=val&...]]
*
* On return, if no command: command=params=null
* Global command: phk://?command[&par=val&...] => path=mnt=null
* mnt=null => global command
*
* Test cases :
* phk://   Error
* phk://mnt1   mnt=mnt1, path='', command=params=null
* phk://mnt1/p1/p2	  mnt=mnt1, path=p1/p2, command=params=null
* phk://mnt1/p1/p2?cmd&par1=2&par2=3   mnt=mnt1, path=p1/p2, command=cmd,
*	  params=array(par1 => 2, par2 => 3)
* phk://?gcmd  mnt=path=null, command=gcmd, params=null
*
* @param string $uri
* @param string|null $command Return value
* @param array|null $params Return value
* @param string|null $mnt Return value - Null only if global command
* @param string|null $path Return value - Null only if global command
* @return void
* @throws Exception on invalid syntax
*/

public static function parse_uri($uri,&$command,&$params,&$mnt,&$path)
{
if (! PHK_Mgr::is_a_phk_uri($uri=str_replace('\\','/',$orig_uri=$uri)))
	throw new Exception('Not a PHK URI');
$uri=substr($uri,6);	// Remove 'phk://'

if (($pos=strpos($uri,'?'))!==false)	// If the uri contains a command
	{
	$cmd=PHK_Util::substr($uri,$pos+1);
	$uri=substr($uri,0,$pos);
	if (($pos=strpos($cmd,'&'))!==false)	// params present
		{
		$command=substr($cmd,0,$pos);
		parse_str(PHK_Util::substr($cmd,$pos+1),$params); // Get parameters
		}
	else $command=$cmd;
	if ($command=='') throw new Exception('Empty command');
	}

$uri=trim($uri,'/');	// Suppress leading and trailing '/'
if ($uri!='') // Not a global command
	{
	$a=explode('/',$uri,2);	//-- Separate mnt and path
	$mnt=$a[0];
	$path=isset($a[1]) ? $a[1] : '';
	}

if (is_null($command) && is_null($mnt)) throw new Exception('Empty URI');
}

//---------------------------------
} // End of class PHK_Stream
//=============================================================================
// Register the PHK wrapper

stream_wrapper_register('phk','PHK_Stream');

//=============================================================================
} // End of class_exists('PHK_Stream')
//=============================================================================

//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Stream_Backend',false))
{
//=============================================================================
/**
* The 'slow' backend to PHK_Stream
*
* This class is called when PHK_Stream cannot retrieve the information it needs
* from the cache or for uncacheable information.
*
* Note (30-NOV-2007): As long as the extension does not trap exceptions
* correctly, we trap them here and return null instead.
*/

class PHK_Stream_Backend
{

/** @var string		Used as temp storage by string_include() */

private static $tmp_data=null;

//---------------------------------
// Returns pseudo-file data string.
// If a command does not want to be cached, it sets $cache to false.
// stat() calls are used mainly for file existence/type. Size is less
// important.

private static function command_open_or_stat($stat_flag,$mnt,$command,$params
	,$path,&$cache)
{
$cache=true; // Default

try
{
if (is_null($mnt))	// Global command
	{
	switch($command)
		{
		case 'test':
			return "Test line 1/3\nTest line2/3\nTest line 3/3\n";
			break;

		case 'tmp':	// Special: Used by PHK::string_include();
			$cache=false;
			return self::$tmp_data;
			break;

		default:
			throw new Exception($command.': Unknown global command');
		}
	}
else // Slow path
	{
	$proxy=PHK_Mgr::proxy($mnt);

	switch ($command)
		{
		// These commands :
		//	- go to the proxy
		//	- are cached
		//	- take a mandatory 'name' argument and send it to the method
		//	- take the data returned by the method

		case 'section':
 		case 'magic_field':
			if (!isset($params['name']))
				throw new Exception($command
					.': command needs this argument: name');
			return $proxy->$command($params['name']);

		// These commands :
		//	- go to the proxy
		//	- are cached
		//	- serialize the data returned by the method

		case 'path_list':
		case 'section_list':
			return serialize($proxy->$command());

		default:
			throw new Exception($command.': Unknown command');
		}
	}
}
catch (Exception $e)
	{
	throw new Exception($command.': Error during command execution - '
		.$e->getMessage());
	}
}

//---------------------------------
// Segfault in extension if this function throws an exception. As long as
// this bug is not corrected, trap the exception before returning to PHK_Stream

public static function get_file_data($mnt,$command,$params,$path,&$cache)
{
$cache=true;

try
{
if (is_null($command))
	{
	$node=PHK_Mgr::proxy($mnt)->ftree()->lookup_file($path,false);
	if (is_null($node)) return null;
	return $node->read();
	}
else
	{
	return self::command_open_or_stat(false,$mnt,$command,$params,$path,$cache);
	}
}
catch (Exception $e) { return null; }
}

//---------------------------------
// Must accept the same parameters as get_file_data()

public static function get_dir_data($mnt,$command,$params,$path)
{
try
{
if (!is_null($command)) return null;

$node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path,false);
if (is_null($node)) return null;
return $node->getdir();
}
catch (Exception $e) { return null; }
}

//---------------------------------

public static function get_stat_data($mnt,$command,$params,$path,$cache
	,&$mode,&$size,&$mtime)
{
if (!is_null($command))
	{
	$mode=0100444;	// Pseudo regular file
	// Throws exception if command invalid or no target
	$size=strlen(self::command_open_or_stat(true,$mnt,$command,$params
		,$path,$cache));
	}
else
	{
	$node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path);

	$mode=$node->mode();
	$size=$node->size();
	}
$mtime=(is_null($mnt) ? time() : PHK_Mgr::instance($mnt)->mtime());
}

//----
// Undocumented
// Applies php_strip_whitespace() to a string

public static function _strip_string($str)
{
if (getenv('PHK_NO_STRIP')!==false) return $str;

$save=self::$tmp_data;
self::$tmp_data=$str;
$res=php_strip_whitespace('phk://?tmp');
self::$tmp_data=$save;
return $res;
}

//----
// Undocumented
// Include a string as if it was in a source file

public static function _include_string($str)
{
$save=self::$tmp_data;
self::$tmp_data=$str;
$res=require('phk://?tmp');
self::$tmp_data=$save;
return $res;
}

} // End of class PHK_Stream_Backend
//=============================================================================
} // End of class_exists('PHK_Stream_Backend')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* Data container
*
* Contains string data and supports compression.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_DC',false))
{
//============================================================================

class PHK_DC	// Data Container
{

private $csz;	// Compressed size
private $rsz;	// Real size
private $flags;	// Compression method
private $off;	// Offset
private $data=null;	// Data cache (null if unset)
private $fspace=null;

//---------

const COMPRESS_TYPE=7;	// Space reserved for 8 compression types

const COMPRESS_NONE=0;
const COMPRESS_GZIP=1;
const COMPRESS_BZIP2=2;

private static $compression_method_names=array('none','gzip','bzip2');

private static $compression_needed_extensions=array(null,'zlib','bz2');

//---------
// Clears the data cache

public function clear_cache()
{
$data=null;
}

//---------

public function set_fspace($fspace)
{
$this->fspace=$fspace;
}

//---------

private function compression_type()
{
return $this->flags & self::COMPRESS_TYPE;
}

//---------
// Uncompress a buffer, given the compression method

private function expand($buf)
{
$ctype=$this->compression_type();

if ($buf==='' || $ctype==self::COMPRESS_NONE) return $buf;

switch($ctype)
	{
	case self::COMPRESS_BZIP2:
		if(is_int($rbuf=bzdecompress($buf)))
			throw new Exception("Cannot bzdecompress data - Error code $buf");
		break;

	case self::COMPRESS_GZIP:
		if(($rbuf=gzuncompress($buf))===false)
			throw new Exception("Cannot gzuncompress data");
		break;

	default:
		throw new Exception("Unknown compression method : $ctype");
	}
return $rbuf;
}

//---
// Read/uncompress/verify and cache data

public function read()
{
if (is_null($this->data))
	{
	if ($this->rsz==0) $this->data='';	// Empty file
	else
		{
		$rbuf=$this->expand($this->fspace->read_block($this->off,$this->csz));
		if (strlen($rbuf)!=$this->rsz) throw new Exception('Wrong expanded size');
		$this->data=$rbuf;
		}
	}
return $this->data;
}

//---

private static function compression_ratio($rsz,$csz)
{
return ($rsz==0) ? '-' : (round(($csz/$rsz)*100));
}

//---

public function flag_string()
{
if ($ctype=$this->flags & self::COMPRESS_TYPE)
	return 'compress/'.self::$compression_method_names[$ctype]
		.' ('.self::compression_ratio($this->rsz,$this->csz).'%)';

return '';
}

//---

public function size() { return $this->rsz; }

//---

public function import($edata)
{
list($this->flags,$this->csz,$this->rsz,$this->off)
	=array_values(unpack('va/V3b',$edata));
	
$this->data=null; // Must be reset as the object is created as an empty file
}

//---

public function __construct()
{
$this->set_flags(0);
$this->set_data('');
$this->csz=$this->off=null;
}

//---
// Set only the DC flags

public function set_flags($flags)
{
$this->flags=($flags & PHK_TNode::TN_DC_FLAG_MASK);
}

//---

public function set_data($data)
{
$this->rsz=strlen($this->data=$data);
}

// <CREATOR> //---------------

public function get_needed_extensions(PHK_Creator $phk
	,PHK_ItemLister $item_lister)
{
if (!is_null($ext=self::$compression_needed_extensions
	[$this->flags & self::COMPRESS_TYPE]))
		$item_lister->add($ext,true);
}

//---

public function append_data($data)
{
$this->data.=$data;
$this->rsz+=strlen($data);
}

//---

public function export(PHK_Creator $phk,PHK_DataStacker $stacker)
{
$cbuf=$this->compress($this->data,$phk);
$this->csz=strlen($cbuf);
$this->off=$stacker->offset;
$stacker->push($cbuf);

return pack('vV3',$this->flags,$this->csz,$this->rsz,$this->off);
}

//------

private function deny_compress($msg,$buf)
{
PHK_Util::msg("	No compression: $msg");
$this->flags &= ~self::COMPRESS_TYPE; // Set to COMPRESS_NONE
return $buf;
}

//------

private function compress($buf,PHK_Creator $phk)
{
if (!($ctype=$this->compression_type())) return $buf;

$comp_min_size=$phk->option('compress_min_size');
$comp_max_size=$phk->option('compress_max_size');
$comp_ratio_limit=$phk->option('compress_ratio_limit');

if ($buf==='') return $this->deny_compress('Empty file',$buf);
if ((!is_null($comp_min_size)) && (strlen($buf) < $comp_min_size))
		return $this->deny_compress('File too small',$buf);
if ((!is_null($comp_max_size)) && (strlen($buf) > $comp_max_size))
		return $this->deny_compress('File too large',$buf);

switch($ctype)
	{
	case self::COMPRESS_BZIP2:
		PHK_Util::load_extension('bz2');
		PHK_Util::msg("	Compressing (bzip2)");
		if(is_int($cbuf=bzcompress($buf,9)))
			throw new Exception("Cannot bzcompress data - Error code $buf");
		break;

	case self::COMPRESS_GZIP:
		PHK_Util::load_extension('zlib');
		PHK_Util::msg("	Compressing (gzip)");
		if(($cbuf=gzcompress($buf))===false) 
			throw new Exception("Cannot gzcompress data");
		break;

	default:
		throw new Exception("Unknown compression method : $ctype");
	}

// Default: Deny if compressed buffer is larger than 90% of original

if (is_null($comp_ratio_limit)) $comp_ratio_limit=90;
if (($r=self::compression_ratio(strlen($buf),strlen($cbuf))) >$comp_ratio_limit)
	return $this->deny_compress("Compression ratio exceeded ($r%)",$buf);

return $cbuf;
}

// </CREATOR> //---------------

}	// End of class PHK_DC
//-------------------------
} // End of class_exists('PHK_DC')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Tree class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Tree',false))
{
// /---------------

//============================================================================

class PHK_Tree
{

public $fspace;		// Associated filespace

private $edata; // Exported data. Always contains a key for every node, even
				// in creator mode.

private $nodes;	// Tree nodes (key=path, value=PHK_TNode object). Contains
				// only the unserialized nodes. In creator mode, contains
				// every node.

private static $eclasses=array( 'D' => 'PHK_TDir', 'F' => 'PHK_TFile');

//---
// Create a tree from the edata stored in the PHK archive

public static function create_from_edata($serial_edata
	,PHK_FileSpace $fspace)
{
$tree=new self($fspace);

$tree->edata=unserialize($serial_edata);

return $tree;
}

//---

public function path_list()
{
return array_keys($this->edata);
}

//---

public function path_exists($rpath)
{
return array_key_exists($rpath,$this->edata);
}

//---

public function count()
{
return count($this->edata);
}

//---

public function walk($method)
{
$args=func_get_args();
array_shift($args);

foreach($this->path_list() as $path)
	{
	$node=$this->rlookup($path);
	call_user_func_array(array($node,$method),$args);
	}
}

//---
// Reduce the path to a canonical path - suppress '..' and '.' components
// Root=''
// Non-root: /xxx[/yyy...]

private function realpath($path)
{
$a=explode('/',trim($path,'/'));
$ra=array();
foreach($a as $comp)
	{
	switch($comp)
		{
		case '':
		case '.':
			break;
		case '..':
			if (count($ra)) array_pop($ra);
			break;
		default:
			$ra[]=$comp;
		}
	}
if (!count($ra)) return '';
return '/'.implode('/',$ra);
}

//---

public function lookup($path,$exception_flag=true)
{
return $this->rlookup(self::realpath($path),$exception_flag);
}

//---
// Lookup without path canonicalization - faster if self::realpath() has
// already been called

private function rlookup($path,$exception_flag=true)
{
if (array_key_exists($path,$this->edata))
	{
	if (!array_key_exists($path,$this->nodes))
		{
		$edata=$this->edata[$path];
		$class=self::$eclasses[$edata{0}];
		$node=$this->nodes[$path]=new $class($path,$this);
		$node->import(substr($edata,1));
		}
	return $this->nodes[$path];
	}

//echo "Lookup failed : <$path> <$rpath>\n";//TRACE
//print_r(array_keys($this->nodes));//TRACE
	
if ($exception_flag) throw new Exception($path.': path not found');
else return null;
}

//---

public function lookup_file($path,$exception_flag=true)
{
$f=$this->lookup($path,$exception_flag);

if ((!is_null($f)) && (!($f instanceof PHK_TFile)))
	{
	if ($exception_flag) throw new Exception($path.': No such file');
	else return null;
	}

return $f;
}

//---

public function display_header($html)
{
if ($html) echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 '
	.'cellspacing=0 style="border-collapse: collapse"><tr><th>T</th>'
	.'<th>Name</th><th>Size</th><th>Flags</th></tr>';
}

//---

public function display_footer($html)
{
if ($html) echo '</table>';
}

//---
// $link = wether we display an hyperlink on file names (in HTML mode)

public function display($link)
{
$html=PHK_Util::is_web();

$this->display_header($html);
$this->walk('display',$html,$link);
$this->display_footer($html);
}

//---

public function display_packages()
{
$html=PHK_Util::is_web();

ob_start();
$this->walk('display_package',$html);
$data=ob_get_clean();

if ($data!=='')
	{
	$this->display_header($html);
	$this->walk('display_package',$html);
	$this->display_footer($html);
	}
}

//---

public function dump($base)
{
$this->walk('dump',$base);
}

//---
// Same as dirname() function except:
// - Always use '/' as separator
// - Returns '' for 1st level paths ('/xxx')

public static function dir_base_name($path)
{
$dir=ereg_replace('/[^/]*$','',$path);
$base=ereg_replace('^.*/','',$path);
return array($dir,$base);
}

//---
// called from create_empty() or create_from_edata() only => private

private function __construct($fspace)
{
$this->fspace=$fspace;
$this->nodes=array();
}

// <CREATOR> //---------------

// Check for a list of forbidden chars in node names. Especially important for
// '#*' which can create conflicts in mount points (for subpackages), and ';'
// which is used as separator when exporting the list of dir children.

public function add_node($path,$node)
{
$path=self::realpath($path);

if (strpbrk($path,'#*?!&~"|`\^@[]={}$;,<>')!==false)
	throw new Exception("$path: Invalid characters in path");

if ($path != '')
	{
	list($dir,$basename)=self::dir_base_name($path);

	$dirnode=$this->rlookup($dir,false);
	if (is_null($dirnode)) $dirnode=$this->mkdir($dir);

	if (!($dirnode instanceof PHK_TDir))
		throw new Exception("Cannot add node over a non-directory node ($dir)");

	$dirnode->add_child($basename);
	}

// Add the node

$this->edata[$path]=null;
$this->nodes[$path]=$node;
}

//---
// Create an empty tree

public static function create_empty()
{
$tree=new self(null);
$tree->add_node('',new PHK_TDir('',$tree));

return $tree;
}

//---

public function export(PHK_Creator $phk,$map=null)
{
$edata=array();
$stacker=new PHK_DataStacker();

foreach($this->nodes as $path => $node)
	{
	$edata[$path]=array_search(get_class($node),self::$eclasses)
		.$node->export($phk,$stacker,$map);
	}
ksort($edata); // To display files in the right order

return array(serialize($edata),$stacker->data);
}

//---

public function add_file_tree($target_path,$source,$modifiers)
{
$target_path=self::realpath($target_path);
$this->remove($target_path);

// Don't use filetype() here because we want to follow symbolic links

if (!file_exists($source))
	{
	echo "$source : File does not exist - Ignored";
	}
elseif (is_file($source))
	{
	$this->mkfile($target_path,PHK_Util::readfile($source),$modifiers);
	}
elseif (is_dir($source))
	{
	$node=$this->mkdir($target_path,$modifiers);

	foreach(PHK_Util::scandir($source) as $subname)
		$this->add_file_tree($node->subpath($subname)
			,$source.DIRECTORY_SEPARATOR.$subname,$modifiers);
	return;
	}
else echo "$source : Unsupported file type (".filetype($source).") - Ignored\n";
}

//---

public function merge_file_tree($target_dir,$source_dir,$modifiers)
{
if (!is_dir($source_dir))
	throw new Exception($source_dir.': Should be an existing directory');

$target_dir=self::realpath($target_dir);
$tnode=$this->mkdir($target_dir,$modifiers);

foreach(PHK_Util::scandir($source_dir) as $subname)
	{
	$source=$source_dir.DIRECTORY_SEPARATOR.$subname;
	$target=$tnode->subpath($subname);
	if (is_file($source))
		{
		$this->mkfile($target,PHK_Util::readfile($source),$modifiers);
		}
	elseif (is_dir($source))
		{
		$this->merge_file_tree($target,$source,$modifiers);
		}
	else echo "$source : Unsupported file type (".filetype($source).") - Ignored\n";
	}
}

//---

private function get_subtree($path)
{
$rpath=self::realpath($path);

if ($rpath=='') return $this->path_list();

$result=array();
$prefix=$rpath.'/';
$len=strlen($prefix);
foreach($this->path_list() as $p)
	{
	if (($p==$rpath)||((strlen($p)>=$len)&&(substr($p,0,$len)==$prefix)))
		$result[]=$p;
	}
return $result;
}

//---

public function modify($path,$modifiers)
{
$path=self::realpath($path);

foreach ($this->get_subtree($path) as $subpath)
	{
	$this->lookup($subpath)->modify($modifiers);
	}
}

//---
// If parent dir does not exist, add_node() will call us back to create it,
// and it goes on recursively until the root node is reached.

public function mkdir($path,$modifiers=array())
{
$rpath=self::realpath($path);

if (is_null($node=$this->rlookup($rpath,false))) // If node does not exist
	{
	$node=new PHK_TDir($path,$this);
	$node->modify($modifiers);
	$this->add_node($path,$node);
	}
else // If node already exists, check that it is a directory
	{
	if (($type=$node->type())!='dir')
		throw new Exception("mkdir: $path is already a $type");
	}
return $node;
}

//---

public function mkfile($path,$data,$modifiers=array())
{
$rpath=self::realpath($path);

$node=new PHK_TFile($rpath,$this);
$node->set_data($data);
$node->modify($modifiers);

$this->add_node($rpath,$node);

return $node;
}

//---

public function remove($path)
{
$rpath=self::realpath($path);
if ($rpath=='') throw new Exception('Cannot remove root directory');

if (is_null($this->rlookup($rpath,false))) return; // Path does not exist

foreach($this->get_subtree($rpath) as $p)
	{
	unset($this->nodes[$p]);
	unset($this->edata[$p]);
	}

list($dir,$name)=self::dir_base_name($rpath);
$this->rlookup($dir)->remove_child($name);
}

// </CREATOR> //---------------

} // End of class PHK_Tree
//-------------------------
} // End of class_exists('PHK_Tree')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TNode_Backend class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TNode',false))
{
//============================================================================

abstract class PHK_TNode		// Base class - never instantiated
{
protected $flags;

protected $path;

protected $tree=null;	// Back pointer to the tree

//---- Flags

const TN_DC_FLAG_MASK=PHK_DC::COMPRESS_TYPE; // Low bits reserved for compr type

const TN_STRIP_SOURCE=8;	// Strip source files
const TN_NO_AUTOLOAD=16;	// Don't register symbols in Automap
const TN_PKG=32;			// File is a PHK package

//---

abstract public function type(); // returns type string

//---
// Default: do nothing

public function display_package($html) {}

//---

public function is_package()
{
return ($this->flags & self::TN_PKG);
}

//---
// Default: error if the method is not overloaded

public function getdir()
{
throw new Exception($this->path.': Cannot getdir() on a '.$this->type());
}

//---
// Default: error

public function read()
{
throw new Exception($this->path.': Cannot read() a '.$this->type());
}

//---

protected function flag_string()
{
$flag_string='';
if ($this->flags & self::TN_PKG) $flag_string .=',package';
else
	{
	if ($this->flags & self::TN_STRIP_SOURCE) $flag_string .=',strip';
	if ($this->flags & self::TN_NO_AUTOLOAD) $flag_string .=',no_autoload';
	}

return $flag_string;
}

//---

// Cannot call set_flags() here, as it will call the derived
// method when it is defined (as in PHK_TFile)

protected function __construct($path,$tree)
{
$this->path=$path;
$this->tree=$tree;
$this->flags=0;
}

//---

protected function import($edata)
{
list($this->flags)=array_values(unpack('va',$edata));
return substr($edata,2);
}

// <CREATOR> //---------------

abstract public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map);

//---

protected function tnode_export($derived_edata)
{
return pack('v',$this->flags).$derived_edata;
}

//---

public function set_flags($flags)
{
$this->flags=$flags;
}

//---

private static function compute_flags(array $modifiers,$flags=0)
{
foreach($modifiers as $name => $value)
	{
	$name=strtolower($name);
	if ($name==='autoload')
		{
		if ($value==='true') $flags &= ~self::TN_NO_AUTOLOAD;
		else $flags |= self::TN_NO_AUTOLOAD;
		}
	elseif ($name==='strip')
		{
		if ($value==='true') $flags |= self::TN_STRIP_SOURCE;
		else $flags &= ~self::TN_STRIP_SOURCE;
		}
	elseif ($name==='compress')
		{
		if ($value=='none') $c=PHK_DC::COMPRESS_NONE;
		elseif ($value=='gzip') $c=PHK_DC::COMPRESS_GZIP;
		elseif ($value=='bzip2') $c=PHK_DC::COMPRESS_BZIP2;
		else throw new Exception($value.': Unknown compression method');
		$flags = ($flags & ~PHK_DC::COMPRESS_TYPE) | $c;
		}
	else throw new Exception($name.': Unknown modifier');
	}
return $flags;
}

//---

public function modify($modifiers)
{
$this->set_flags(self::compute_flags($modifiers,$this->flags));
}

// </CREATOR> //---------------

//---
} // End of class PHK_TNode
//-------------------------
} // End of class_exists('PHK_TNode')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TDir class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TDir',false))
{
//============================================================================

class PHK_TDir extends PHK_TNode
{

private $children; // array of basenames

//---

public function type() { return 'dir'; }
public function mode() { return 040555; }
public function size() { return count($this->children); }
public function get_needed_extensions() {}

//---

public function display($html,$link)
{
$path=$this->path;
if ($path=='') $path='/';

if ($html) echo '<tr><td nowrap colspan=4>&nbsp;<b><i>'.$path
		.'</i></b></td></tr>';
else echo "D $path\n";
}

//---

public function getdir()
{
return $this->children;
}

//---

public function dump($base)
{
$path=$base.$this->path;
if (mkdir($path)===false) throw new Exception($path.': cannot create directory');
}

//---

public function import($edata)
{
$this->children=explode(';',parent::import($edata));
}

//---

public function __construct($path,$tree)
{
parent::__construct($path,$tree);

$this->children=array();
}

//---

public function subpath($name)
{
return $this->path.'/'.$name;
}

// <CREATOR> //---------------

public function add_child($name)
{
if (array_search($name,$this->children)===false) $this->children[]=$name;
}

//---

public function remove_child($name)
{
if (($key=array_search($name,$this->children))===false)
	unset ($this->children[$key]);
}

//---

public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map)
{
return $this->tnode_export(implode(';',$this->children));
}

// </CREATOR> //---------------

} // End of class PHK_TDir
//-------------------------
} // End of class_exists('PHK_TDir')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TFile class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TFile',false))
{
//============================================================================

class PHK_TFile extends PHK_TNode // Regular file
{

private $dc;	// Data container

//---

public function type() { return 'file'; }
public function mode() { return 0100444; }

//---
// If a method is unknown, forward to the DC (poor man's multiple inheritance :)

public function __call($method,$args)
{
try { return call_user_func_array(array($this->dc,$method),$args); }
catch (Exception $e)
	{ throw new Exception($this->path.': '.$e->getMessage()); }
}

//---
// Must be defined as __call() is tried after PHK_TNode methods, and read()
// has a default in PHK_TNode.

public function read()
{
return $this->dc->read();
}

//---

public function flag_string()
{
$string=parent::flag_string().','.$this->dc->flag_string();
$string=trim($string,',');

return $string;
}

//---

public function display_package($html)
{
if ($this->flags & self::TN_PKG) $this->display($html);
}

//---
// In HTML, create an hyperlink only for files, not for sections

public function display($html,$link=false)
{
$flag_string=$this->flag_string();
$path=$this->path;

if ($html)
	{
	if ($this->flags & self::TN_PKG) $link=false;
	$field= ($link ? '<a href="'.PHK::subpath_url('/view/'
		.trim($path,'/')).'">'.$path.'</a>' : $path);
	echo '<tr><td nowrap>F</td><td nowrap>'.$field.'</td><td nowrap>'
		.$this->size().'</td><td nowrap>'.$flag_string.'</td></tr>';
	}
else
	{
	if ($flag_string!='') $flag_string = ' ('.$flag_string.')';
	echo 'F '.str_pad($this->size(),11).' '.$path.$flag_string."\n";
	}
}

//---

public function dump($base)
{
$path=$base.$this->path;
if (file_put_contents($path,$this->read())===false)
	throw new Exception($path.': cannot dump file');
}

//---

public function __construct($path,$tree)
{
parent::__construct($path,$tree);

$this->dc=new PHK_DC();
$this->dc->set_fspace($tree->fspace);
}

//---

public function import($edata)
{
$this->dc->import(parent::import($edata));
}

//---

public function set_flags($flags)
{
parent::set_flags($flags);
$this->dc->set_flags($flags);
}

//---
// <CREATOR> //---------------

// If PHK Package, move required extensions up
// Don't umount the package, it will be used later.

public function get_needed_extensions(PHK_Creator $phk
	,PHK_ItemLister $item_lister)
{
if (PHK::data_is_package($this->read()))
	{
	$mnt=require($phk->uri($this->path));
	$source_phk=PHK_Mgr::instance($mnt);
	if (!is_null($elist=$source_phk->option('required_extensions')))
		{
		foreach ($elist as $ext) $item_lister->add($ext,true);
		}
	
	}

return $this->dc->get_needed_extensions($phk,$item_lister);	// Now, ask DC
}

//---------------
// Process PHP scripts (Automap and source stripping)
// Register Automap symbols only if $map is non-null
// Distinction between files and sections: for files, $map is not null

public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map)
{
$path=$this->path;

PHK_Util::msg('Processing '.$path);

if (!is_null($map)) // This is a real file
	{
	if (getenv('PHK_NO_STRIP')!==false)	$this->flags &= ~self::TN_STRIP_SOURCE;

	if (PHK::data_is_package($this->read()))	//-- Package ?
		{
		//-- Set 'package' flag, clear 'strip source', and keep autoload
		$this->flags |= self::TN_PKG;
		$this->flags &= ~self::TN_STRIP_SOURCE;
		}

	//-- If it is a sub-package and autoload is true, merge its symbols
	//-- in the current map, but with different values.

	if ($this->flags & self::TN_PKG)
		{
		if (!($this->flags & self::TN_NO_AUTOLOAD))
			{
			PHK_Util::msg("	Merging Automap symbols");
			$map->register_package($phk->uri($path),$path);
			}
		}
	elseif ($phk->is_php_source_path($path))
		{
		//--- Register in automap
		if (!($this->flags & self::TN_NO_AUTOLOAD))
			{
			PHK_Util::msg("	Registering Automap symbols");
			$map->register_script($phk->uri($path),$path);
			}

		//--- Strip script files

		if ($this->flags & self::TN_STRIP_SOURCE)
			{
			PHK_Util::msg("	Stripping script");

			// We must save the Automap comments from php_strip_whitespace()
			// because we must be able to rebuild the Automap (when upgrading
			// the package, for instance).
			// If there are Automap comments in the file, we put them in a PHP
			// block after the stripped script.

			$comment_buf='';
			foreach(file($phk->uri($path)) as $line)
				{
				$line=trim($line);
				if (ereg(Automap_Creator::AUTOMAP_COMMENT,$line,$regs)===false)
					continue;
				// Warning: keep '//' and '<Automap> separate below or it will be
				// detected as an Automap comment when processing this file.
				$comment_buf .= '//'.' <Automap>:'.$regs[1].$regs[2]."\n";
				}
			// Keep '<?'.'php' or it will be translated when building the
			// runtime code
			if ($comment_buf!='') $comment_buf="<?"."php\n".$comment_buf."?".">";
			$this->set_data(php_strip_whitespace($phk->uri($path)).$comment_buf);
			}
		}
	else
		{
		$this->flags = ($this->flags & ~self::TN_STRIP_SOURCE) 
			| self::TN_NO_AUTOLOAD;
		}
	}

return $this->tnode_export($this->dc->export($phk,$stacker));
}

// </CREATOR> //---------------

} // End of class PHK_TFile
//-------------------------
} // End of class_exists('PHK_TFile')
//=============================================================================

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Webinfo class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Webinfo',false))
{
//============================================================================

class PHK_Webinfo
{
const VERSION='0.2.5';

private $PHK;	// Associated PHK instance

private $cmd_titles=array(
	'info' => 'Home',
	'techinfo' => 'Technical information',
	'showmap' => 'Automap',
	'showfiles' => 'Files',
	'test' => 'Unit tests');

//----

public function __construct($phk)
{
$this->PHK=$phk;

PHK_Mgr::set_cache(false); // Don't cache anything in webinfo mode
}

//----

private static function display_tab($url,$name)
{
echo '<li id="'.$name.'"><a href="'.PHK::subpath_url($url)
	.'"><span>'.$name.'</span></a></li>';
}

//----

private function header($title=null)
{
if (is_null($name=$this->PHK->option('name')))
	$name=basename($this->PHK->path());
$win_title=(is_null($title) ? $name : "$name - $title");

echo '<head>'
	."<title>$win_title</title>"
	.'<link href="'.PHK::subpath_url('/php_section/STATIC/tabs/tabs.css.php')
	.'" rel="stylesheet" type="text/css">'
	."<style type=text/css><!--\n"
	."a,a:active,a:link { color: blue; text-decoration: none; }\n"
	."a:hover { color: blue; text-decoration: underline; }\n"
	.'--></style>'
	."</head>\n";

echo '<table width=100% border=0 cellpadding=0 cellspacing=0>';

//-- Tabs

echo '<tr><td><div class="tabs"><ul>';

self::display_tab('/info','Home');

if (!is_null($this->PHK->option('help_prefix')))
	self::display_tab('/auto_option/help','Help');

if (!is_null($this->PHK->option('license_prefix')))
	self::display_tab('/auto_option/license','License');

self::display_tab('/techinfo','Info');
self::display_tab('/showfiles','Files');

if ($this->PHK->map_defined())
	self::display_tab('/showmap','Automap');

if ((!is_null($this->PHK->option('test_script')))
	||(!is_null($this->PHK->option('phpunit_test_package'))))
	self::display_tab('/test','Tests');

//-- Package specific tabs

if (!is_null($tabs=$this->PHK->option('tabs')))
	foreach($tabs as $n => $url) self::display_tab($url,$n);

echo '</ul></div></td></tr>';

//--

$bg_string=(is_null($opt=$this->PHK->option('icon_bgcolor'))
	? '' : 'bgcolor="'.$opt.'"');

if (is_null($icon_width=$this->PHK->option('icon_width'))) $icon_width='150';
 
echo '<tr><td width=100%><table width=100% border=1 bordercolor="#aaaaaa"'
	.' cellpadding=3 cellspacing=0>';
echo "<tr><td width=$icon_width $bg_string align=center>";

$url=$this->PHK->option('url');
if (!is_null($url)) echo '<a href="'.$url.'" target=_blank>';
if (!is_null($icon_path=$this->PHK->option('icon')))
	echo '<img border=0 src="'.PHK::subpath_url('/file/'.trim($icon_path,'/'))
		.'" alt="Package Home">';
elseif (!is_null($url)) echo '&lt;Website&gt;';
if (!is_null($url)) echo '</a>';
echo "</td>\n";

echo '<td bgcolor="#D7E2FF" align=center><h1>'.$name.'</h1></td>';

echo '<td width=151 align=center><a href="http://phk.tekwire.net"'
	.' target=_blank><img width=151 height=88 border=0 src="'
	.PHK::subpath_url('/section/STATIC/phk_logo.png')
	.'" alt="PHK Home"></a></td>';
echo '</tr>';

echo '</table></td></tr></table>';

// Page title

if (!is_null($title)) echo "<p><h1>$title</h1>";
@flush(); //-- Tries to flush the header as the command can be quite long
}

//----

public function run()
{
#-- Debug mode

if (isset($_REQUEST['debug']))
	{
	echo "<hr>";
	echo "<h2>Environment:</h2>";

	echo "<h3>_REQUEST :</h3>";
	echo "<pre>";
	var_dump($_REQUEST);
	echo "</pre>";

	echo "<h3>_SERVER :</h3>";
	echo "<pre>";
	print_r($_SERVER);
	echo "</pre>";
	}

#-- Get the command and optional arg. Supports both URL formats

$command=trim(PHK::get_subpath(),'/');
if (($pos=strpos($command,'/'))!==false)
	{
	$arg=substr($command,$pos+1);
	$command=substr($command,0,$pos);
	}
else $arg='';

if ($command=='') $command='info'; //-- Default command

#-- Run command

self::send_cache_header();

switch($command)
	{
	case 'view':
		$arg='/'.$arg;
		$this->header("File: $arg");
		$path=$this->PHK->uri($arg);
		if (!is_file($path))
			{
			echo '* ERROR: '.$arg.': File not found<p>';
			break;
			}

		echo "<table border=0>\n";
		echo '<tr><td>Size:</td><td>'.filesize($path).'</td></tr>';
		echo '<tr><td>Storage flags:</td><td>'
			.$this->PHK->proxy()->ftree()->lookup($arg)->flag_string().'</td></tr>';
		echo "</table><hr/>";

		switch($mime_type=$this->PHK->mime_type($arg))
			{
			case 'application/x-httpd-php':
				highlight_file($path);
				break;

			case 'text/html':
				echo PHK_Util::readfile($path);
				break;

			default:
				if (strpos($mime_type,'image/')===0) // Is it an image ?
					echo 'Image: <img src="'.PHK::subpath_url('/file'.$arg).'">';
				else echo '<pre>'.htmlspecialchars(PHK_Util::readfile($path))
					.'</pre>';
			}
		break;

	case 'run':
		$this->header();
		eval($this->PHK->web_tunnel($arg,true));
		break;

	case 'file':	// Bare file
		eval($this->PHK->web_tunnel($arg,true));
		return; // Don't put anything after the file

	case 'info':
	case 'techinfo':
	case 'envinfo':
	case 'showmap':
	case 'showfiles':
	case 'test':
		if (isset($this->cmd_titles[$command])) $t=$this->cmd_titles[$command];
		else $t=ucfirst($command);
		$this->header($t);
		$this->PHK->$command(array(__CLASS__,'view_subfile_url'));
		break;

	case 'auto_file':
		$this->header();
		echo $this->PHK->auto_file('/'.$arg);
		break;

	case 'auto_option':
		$this->header(ucfirst($arg));
		echo $this->PHK->auto_option($arg);
		break;

	case 'php_section':
		require($this->PHK->section_uri($arg));
		return; // Don't put anything after the file

	case 'section':	// Bare section (image, css,...) with PHP source auto-exec
		eval($this->PHK->web_tunnel('/?section&name='.$arg,true));
		return; // Don't put anything after the file

	default:
		echo '<b>'.$command.': Unknown subcommand</b><p>';
	}

self::footer();
}

//----
// Convert a subfile path to an URL. Needed because Automap must not
// directly reference PHK or PHK_Webinfo (to avoid cyclic dependencies).

public static function view_subfile_url($fname)
{
return PHK::subpath_url('/view/'.trim($fname,'/'));
}

//----
// Set headers to cache this url during 10 mins
// Taken from http-conditional (http://alexandre.alapetite.net)
// very important because, if it not sent, tabs background images are not
// cached by the browser.
// Unfortunately, since we had to change the syntax of webinfo URLs to be
// compatible with PHP in CGI mode, most browsers won't cache URLs containing
// a '?' char.

private static function send_cache_header()
{
header('Expires: '.gmdate('D, d M Y H:i:s \G\M\T',time()+600));
header('Cache-Control: public, max-age=600'); //rfc2616-sec14.html#sec14.9
header('Last-Modified: '.gmdate('D, d M Y H:i:s \G\M\T',time()));
}

//----

private static function footer()
{
echo '<hr>';
echo '<font size="-1"><i>For more information about the PHK package format:'
		.' <a href="http://phk.tekwire.net" target="_blank">'
		.'http://phk.tekwire.net</i></font>';
}

}	// End of class PHK_Webinfo
//-------------------------------------------------------------------
} // End of class_exists('PHK_Webinfo')
//-------------------------------------------------------------------

//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
// Please note that most of this file is derived from the code published by
// the PHPUnit project (v 3.2.2).
// As such, please consider the following notice:
/*
 * PHPUnit
 *
 * Copyright (c) 2002-2007, Sebastian Bergmann <sb@sebastian-bergmann.de>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *
 *   * Neither the name of Sebastian Bergmann nor the names of his
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!function_exists('_phk_load_phpunit_interface'))
{
function _phk_load_phpunit_interface()
{
if (!class_exists('PHPUnit_Runner_PHKTestSuiteLoader',false))
{
//=============================================================================
/**
*/
class PHPUnit_Runner_PHKTestSuiteLoader implements PHPUnit_Runner_TestSuiteLoader
{

//-------------------

public function load($suiteClassName, $suiteClassFile = '')
{
if (class_exists($suiteClassName, true))
	{
	return new ReflectionClass($suiteClassName);
	}
else throw new RuntimeException("Class $suiteClassName could not be found");
}

//-------------------

public function reload(ReflectionClass $aClass)
{
return $aClass;
}

//---------------------------------
} // End of class PHPUnit_Runner_PHKTestSuiteLoader
//-------------------------
} // End of class_exists('PHPUnit_Runner_PHKTestSuiteLoader')
//=============================================================================

if (!class_exists('PHPUnit_TextUI_PHK',false))
{
//=============================================================================
/**
*/
class PHPUnit_TextUI_PHK
{
//-------------------

public static function main()
{
PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT');

self::handleLoader('PHPUnit_Runner_PHKTestSuiteLoader');

//----

$arguments=self::handleArguments();

$runner= new PHPUnit_TextUI_TestRunner;

$suite = $runner->getTest($arguments['test'],'',$arguments['syntaxCheck']);

try	{
	if (PHK_Util::is_web()) echo "<pre>\n";

	$result = $runner->doRun($suite,$arguments);

	if (PHK_Util::is_web()) echo "</pre>\n";
	}
catch (Exception $e)
	{
    throw new RuntimeException('Could not create and run test suite: '
		. $e->getMessage());
	}

if (!PHK_Util::is_web())
	{
	if ($result->wasSuccessful()) exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
	else if($result->errorCount() > 0)
		exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
	else exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT);
	}
}

//-------------------
/**
* @access protected
* @static
*/

protected static function handleArguments()
{
$arguments = array('syntaxCheck' => TRUE);

$longOptions = array(
	'configuration=',
	'exclude-group=',
	'filter=',
	'group=',
	'help',
	'loader=',
	'log-json=',
	'log-tap=',
	'log-xml=',
	'repeat=',
	'skeleton',
	'stop-on-failure',
	'tap',
	'testdox',
	'testdox-html=',
	'testdox-text=',
	'no-syntax-check',
	'verbose',
	'version',
	'wait');

if (class_exists('Image_GraphViz', FALSE)) $longOptions[] = 'log-graphviz=';

if (extension_loaded('pdo'))
	{
	$longOptions[] = 'test-db-dsn=';
	$longOptions[] = 'test-db-log-rev=';
	$longOptions[] = 'test-db-log-prefix=';
	$longOptions[] = 'test-db-log-info=';
	}

if (extension_loaded('xdebug'))
	{
	$longOptions[] = 'coverage-html=';
	$longOptions[] = 'coverage-xml=';
	$longOptions[] = 'log-metrics=';
	$longOptions[] = 'log-pmd=';
	$longOptions[] = 'report=';
	}

try
	{
	//-- Tests if argv exists - allows to run in web mode

	$options = PHPUnit_Util_Getopt::getopt(
		isset($_SERVER['argv']) ? $_SERVER['argv'] : array(),'d:',$longOptions);
	}
catch (RuntimeException $e)
	{
	PHPUnit_TextUI_TestRunner::showError($e->getMessage());
	}

$arguments['test']=(isset($options[1][0]) ? $options[1][0] : 'AllTests');

$arguments['testFile'] = '';

foreach ($options[0] as $option)
	{
	switch ($option[0])
		{
		case '--configuration':
			$arguments['configuration'] = $option[1];
			break;

		case '--coverage-xml':
			$arguments['coverageXML'] = $option[1];
			break;

		case 'd':
			$ini = explode('=', $option[1]);
			if (isset($ini[0]))
				{
				if (isset($ini[1]))
					{
					ini_set($ini[0], $ini[1]);
					}
				else ini_set($ini[0], TRUE);
				}
			break;

		case '--help':
			self::showHelp();
			exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
			break;

		case '--filter':
			if (preg_match('/^[a-zA-Z0-9_]/', $option[1]))
				$arguments['filter'] = '/^' . $option[1] . '$/';
			else
				$arguments['filter'] = $option[1];
			break;

		case '--group':
			$arguments['groups'] = explode(',', $option[1]);
			break;

		case '--exclude-group':
			$arguments['excludeGroups'] = explode(',', $option[1]);
			break;

		case '--loader':
			self::handleLoader($option[1]);
			break;

		case '--log-json':
			$arguments['jsonLogfile'] = $option[1];
			break;

		case '--log-graphviz':
			$arguments['graphvizLogfile'] = $option[1];
			break;

		case '--log-tap':
			$arguments['tapLogfile'] = $option[1];
			break;

		case '--log-xml':
			$arguments['xmlLogfile'] = $option[1];
			break;

		case '--log-pmd':
			$arguments['pmdXML'] = $option[1];
			break;

		case '--log-metrics':
			$arguments['metricsXML'] = $option[1];
			break;

		case '--repeat':
			$arguments['repeat'] = (int)$option[1];
			break;

		case '--stop-on-failure':
			$arguments['stopOnFailure'] = TRUE;
			break;

		case '--test-db-dsn':
			$arguments['testDatabaseDSN'] = $option[1];
			break;

		case '--test-db-log-rev':
			$arguments['testDatabaseLogRevision'] = $option[1];
			break;

		case '--test-db-prefix':
			$arguments['testDatabasePrefix'] = $option[1];
			break;

		case '--test-db-log-info':
			$arguments['testDatabaseLogInfo'] = $option[1];
			break;

		case '--coverage-html':
		case '--report':
			$arguments['reportDirectory'] = $option[1];
			break;

		case '--skeleton':
			if (isset($arguments['test']))
				self::doSkeleton($arguments['test'],'');
			else
				{
				self::showHelp();
				exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
				}
			break;

		case '--tap':
			$arguments['printer'] = new PHPUnit_Util_Log_TAP;
			break;

		case '--testdox':
			$arguments['printer'] = new PHPUnit_Util_TestDox_ResultPrinter_Text;
			break;

		case '--testdox-html':
			$arguments['testdoxHTMLFile'] = $option[1];
			break;

		case '--testdox-text':
			$arguments['testdoxTextFile'] = $option[1];
			break;

		case '--no-syntax-check':
			$arguments['syntaxCheck'] = FALSE;
			break;

		case '--verbose':
			$arguments['verbose'] = TRUE;
			break;

		case '--version':
			PHPUnit_TextUI_TestRunner::printVersionString();
			exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
			break;

		case '--wait':
			$arguments['wait'] = TRUE;
			break;
		}
	}

if (!isset($arguments['test']) && isset($arguments['configuration']))
	{
	$configuration= new PHPUnit_Util_Configuration($arguments['configuration']);

	$testSuite = $configuration->getTestSuiteConfiguration();

	if ($testSuite !== NULL) $arguments['test'] = $testSuite;
	}

if ((isset($arguments['testDatabaseLogRevision'])
	&& !isset($arguments['testDatabaseDSN'])))
	{
	self::showHelp();
	exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
	}

return $arguments;
}

/**
* @param  string  $test
* @param  string  $testFile
* @access protected
* @static
*/
protected static function doSkeleton($test, $testFile)
{
if ($test !== FALSE)
	{
	PHPUnit_TextUI_TestRunner::printVersionString();

	try
		{
		$skeleton = new PHPUnit_Util_Skeleton($test, $testFile);
		$skeleton->write();
		}
	catch (Exception $e)
		{
		print $e->getMessage() . "\n";

		printf('Could not write test class skeleton for "%s" to "%s".' . "\n",
			$test,$testFile);

		exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT);
		}

	printf('Wrote test class skeleton for "%s" to "%s".' . "\n",
		$test,$skeleton->getTestSourceFile());

	exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
	}
}

/**
* @param  string  $loaderName
* @access protected
* @static
*/
protected static function handleLoader($loaderName)
{
if (!class_exists($loaderName, FALSE))
	{
	PHPUnit_Util_Fileloader::checkAndLoad(str_replace('_', '/', $loaderName)
		. '.php');
	}

if (class_exists($loaderName, FALSE))
	{
	$class = new ReflectionClass($loaderName);

	if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') &&
		$class->isInstantiable())
		{
		$loader = $class->newInstance();
		}
	}

if (!isset($loader))
	{
	PHPUnit_TextUI_TestRunner::showError(
		sprintf('Could not use "%s" as loader.',$loaderName));
	}

PHPUnit_TextUI_TestRunner::setLoader($loader);
}

/**
* @access public
* @static
*/
public static function showHelp()
{
PHPUnit_TextUI_TestRunner::printVersionString();

print "Usage: php <package> [switches] [UnitTest]\n\n";

if (class_exists('Image_GraphViz', FALSE)) {
    print "  --log-graphviz <file>  Log test execution in GraphViz markup.\n";
}

print "  --log-json <file>      Log test execution in JSON format.\n" .
      "  --log-tap <file>       Log test execution in TAP format to file.\n" .
      "  --log-xml <file>       Log test execution in XML format to file.\n";

if (extension_loaded('xdebug')) {
    print "  --log-metrics <file>   Write metrics report in XML format.\n" .
          "  --log-pmd <file>       Write violations report in PMD XML format.\n\n" .
          "  --coverage-html <dir>  Generate code coverage report in HTML format.\n" .
          "  --coverage-xml <file>  Write code coverage information in XML format.\n\n";
}

if (extension_loaded('pdo')) {
    print "  --test-db-dsn <dsn>    DSN for the test database.\n" .
          "  --test-db-log-rev <r>  Revision information for database logging.\n" .
          "  --test-db-prefix ...   Prefix that should be stripped from filenames.\n" .
          "  --test-db-log-info ... Additional information for database logging.\n\n";
}

print "  --testdox-html <file>  Write agile documentation in HTML format to file.\n" .
      "  --testdox-text <file>  Write agile documentation in Text format to file.\n\n" .
      "  --filter <pattern>     Filter which tests to run.\n" .
      "  --group ...            Only runs tests from the specified group(s).\n" .
      "  --exclude-group ...    Exclude tests from the specified group(s).\n\n" .
      "  --loader <loader>      TestSuiteLoader implementation to use.\n" .
      "  --repeat <times>       Runs the test(s) repeatedly.\n\n" .
      "  --tap                  Report test execution progress in TAP format.\n" .
      "  --testdox              Report test execution progress in TestDox format.\n\n" .
      "  --no-syntax-check      Disable syntax check of test source files.\n" .
      "  --stop-on-failure      Stop execution upon first error or failure.\n" .
      "  --verbose              Output more verbose information.\n" .
      "  --wait                 Waits for a keystroke after each test.\n\n" .
      "  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.\n\n" .
      "  --help                 Prints this usage information.\n" .
      "  --version              Prints the version and exits.\n\n" .
      "  --configuration <file> Read configuration from XML file.\n" .
      "  -d key[=value]         Sets a php.ini value.\n";
}

//---------------------------------
} // End of class PHPUnit_TextUI_PHK
//-------------------------
} // End of class_exists('PHPUnit_TextUI_PHK')
//=============================================================================
} // End of function _phk_load_phpunit_interface
//=============================================================================
} // End of function_exists(_phk_load_phpunit_interface)

a:12:{s:0:"";s:42:"D  FTREE;AUTOMAP;STATIC;OPTIONS;BUILD_INFO";s:8:"/AUTOMAP";s:17:"F    ä  ä  C
  ";s:11:"/BUILD_INFO";s:17:"F          Õg  ";s:6:"/FTREE";s:17:"F    C
  C
      ";s:8:"/OPTIONS";s:17:"F        Fe  ";s:7:"/STATIC";s:20:"D  tabs;phk_logo.png";s:20:"/STATIC/phk_logo.png";s:17:"F    i<  i<  Ý(  ";s:12:"/STATIC/tabs";s:45:"D  left.gif;right.gif;bottom.gif;tabs.css.php";s:23:"/STATIC/tabs/bottom.gif";s:17:"F    #   #     ";s:21:"/STATIC/tabs/left.gif";s:17:"F    Â  Â  '  ";s:22:"/STATIC/tabs/right.gif";s:17:"F    
  
  é  ";s:25:"/STATIC/tabs/tabs.css.php";s:17:"F    ¸  ¸  %  ";}a:42:{s:0:"";s:39:"D  Changelog;README;classes;etc;scripts";s:10:"/Changelog";s:17:"F   2  2      ";s:7:"/README";s:17:"F       2  ";s:8:"/classes";s:339:"D  Automap.php;Automap_Creator.php;PHK.php;PHK_Backend.php;PHK_Base.php;PHK_Cache.php;PHK_Creator.php;PHK_DC.php;PHK_DataStacker.php;PHK_File.php;PHK_ItemLister.php;PHK_Mgr.php;PHK_PHPUnit.php;PHK_PSF.php;PHK_Proxy.php;PHK_Stream.php;PHK_Stream_Backend.php;PHK_TDir.php;PHK_TFile.php;PHK_TNode.php;PHK_Tree.php;PHK_Util.php;PHK_Webinfo.php";s:20:"/classes/Automap.php";s:17:"F    =P  =P  F  ";s:28:"/classes/Automap_Creator.php";s:17:"F    º.  º.  ]  ";s:16:"/classes/PHK.php";s:17:"F    F  F  =  ";s:24:"/classes/PHK_Backend.php";s:17:"F    M  M    ";s:21:"/classes/PHK_Base.php";s:17:"F    ¼F  ¼F  à  ";s:22:"/classes/PHK_Cache.php";s:17:"F    ¢  ¢  Q' ";s:24:"/classes/PHK_Creator.php";s:17:"F    W*  W*  ó> ";s:19:"/classes/PHK_DC.php";s:17:"F    o  o  Ji ";s:28:"/classes/PHK_DataStacker.php";s:17:"F    X  X  ¹ ";s:21:"/classes/PHK_File.php";s:17:"F    U  U   ";s:27:"/classes/PHK_ItemLister.php";s:17:"F        f¡ ";s:20:"/classes/PHK_Mgr.php";s:17:"F    #6  #6  ¨ ";s:24:"/classes/PHK_PHPUnit.php";s:17:"F    6  6  §Þ ";s:20:"/classes/PHK_PSF.php";s:17:"F    §  §  8 ";s:22:"/classes/PHK_Proxy.php";s:17:"F    3  3  ß2 ";s:23:"/classes/PHK_Stream.php";s:17:"F    [,  [,  îe ";s:31:"/classes/PHK_Stream_Backend.php";s:17:"F    ³  ³  I ";s:21:"/classes/PHK_TDir.php";s:17:"F    Û
  Û
  ü¦ ";s:22:"/classes/PHK_TFile.php";s:17:"F    Í  Í  ×± ";s:22:"/classes/PHK_TNode.php";s:17:"F    '  '  ¤Ê ";s:21:"/classes/PHK_Tree.php";s:17:"F    6'  6'  ËÚ ";s:21:"/classes/PHK_Util.php";s:17:"F    q*  q*   ";s:24:"/classes/PHK_Webinfo.php";s:17:"F    ç  ç  r, ";s:4:"/etc";s:79:"D  help.htm;help.txt;license.htm;license.txt;phk_logo.png;phk_logo_old.png;tabs";s:13:"/etc/help.htm";s:17:"F   Z   Z   YL ";s:13:"/etc/help.txt";s:17:"F   L   L   ³L ";s:16:"/etc/license.htm";s:17:"F   )  )  ÿL ";s:16:"/etc/license.txt";s:17:"F   ^,  ^,  v ";s:17:"/etc/phk_logo.png";s:17:"F   i<  i<  ú¢ ";s:21:"/etc/phk_logo_old.png";s:17:"F   <*  <*  cß ";s:9:"/etc/tabs";s:45:"D  bottom.gif;left.gif;right.gif;tabs.css.php";s:20:"/etc/tabs/bottom.gif";s:17:"F   #   #   	 ";s:18:"/etc/tabs/left.gif";s:17:"F   Â  Â  Â	 ";s:19:"/etc/tabs/right.gif";s:17:"F   
  
   ";s:22:"/etc/tabs/tabs.css.php";s:17:"F    ¸  ¸   ";s:8:"/scripts";s:33:"D  PHK_Builder.php;PHK_Prolog.php";s:24:"/scripts/PHK_Builder.php";s:17:"F    ¿  ¿  U" ";s:23:"/scripts/PHK_Prolog.php";s:17:"F    å  å  . ";}AUTOMAP  M M1.1.0        V1.1.0        FS1508    a:2:{s:3:"map";a:28:{s:8:"Lautomap";s:20:"Sclasses/Automap.php";s:16:"Lautomap_creator";s:28:"Sclasses/Automap_Creator.php";s:4:"Lphk";s:16:"Sclasses/PHK.php";s:12:"Lphk_backend";s:24:"Sclasses/PHK_Backend.php";s:9:"Lphk_base";s:21:"Sclasses/PHK_Base.php";s:10:"Lphk_cache";s:22:"Sclasses/PHK_Cache.php";s:15:"Lphk_cache_base";s:22:"Sclasses/PHK_Cache.php";s:14:"Lphk_cache_apc";s:22:"Sclasses/PHK_Cache.php";s:17:"Lphk_cache_xcache";s:22:"Sclasses/PHK_Cache.php";s:23:"Lphk_cache_eaccelerator";s:22:"Sclasses/PHK_Cache.php";s:12:"Lphk_creator";s:24:"Sclasses/PHK_Creator.php";s:7:"Lphk_dc";s:19:"Sclasses/PHK_DC.php";s:16:"Lphk_datastacker";s:28:"Sclasses/PHK_DataStacker.php";s:9:"Lphk_file";s:21:"Sclasses/PHK_File.php";s:14:"Lphk_filespace";s:21:"Sclasses/PHK_File.php";s:15:"Lphk_itemlister";s:27:"Sclasses/PHK_ItemLister.php";s:8:"Lphk_mgr";s:20:"Sclasses/PHK_Mgr.php";s:28:"F_phk_load_phpunit_interface";s:24:"Sclasses/PHK_PHPUnit.php";s:8:"Lphk_psf";s:20:"Sclasses/PHK_PSF.php";s:10:"Lphk_proxy";s:22:"Sclasses/PHK_Proxy.php";s:11:"Lphk_stream";s:23:"Sclasses/PHK_Stream.php";s:19:"Lphk_stream_backend";s:31:"Sclasses/PHK_Stream_Backend.php";s:9:"Lphk_tdir";s:21:"Sclasses/PHK_TDir.php";s:10:"Lphk_tfile";s:22:"Sclasses/PHK_TFile.php";s:10:"Lphk_tnode";s:22:"Sclasses/PHK_TNode.php";s:9:"Lphk_tree";s:21:"Sclasses/PHK_Tree.php";s:9:"Lphk_util";s:21:"Sclasses/PHK_Util.php";s:12:"Lphk_webinfo";s:24:"Sclasses/PHK_Webinfo.php";}s:7:"options";a:0:{}}GIF89a	 ,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    	 , ÿ@P±É`H$!%Cq Ve2X­ÌJ(Ä +32$ÀÆ ¼kvä-Ëçõu*"}ã|}|~q("$f'l(&&$r&! )¢¤{¨£¥r­ª°©¯±¯¬´¦·»º³®«§¾¶ÃÂÀ¿²¹ÇÄËÆ²ÌÉÎµÒ½Í¼ÔÈÓ×Ð¸ÙÝÕÏÙÊâÜßãçæê¾äÛÅëÇíáîÖìéïøñ÷õüÑðåùü¤Pß?ÇÛBmåAÎáÀ%VÜî!Çk÷Ø/áÄ;^¤¨²$Æ#Mf)fÍ(WÎLæKçÒ° I)L:eD¡Cµ´x*4U¨h 
%A«£^ÁNKb¬Ùe§X± ´k»x!ÁÖí2tÝÖ	 !¯5tÛæéÀ]$¬´%Xíâ.i[¬]Y­ÊfEëõkg`µ:zëçÒ;£}ºµj×aaM¶é×¸cç½»vïÛºóî8ðáÈ'?®¼9óç©G_>Ýyuè¬_ß]zwêß­Ç¾º¼mîæµG~½ûôÞá/>ùööÙ«Ïÿ¿ÿýÿÅà|ÖWà} v ;GIF89a,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    , ÿ@pH,È¤rÉl:Ð¨tJ­Z¯Ø¬vh<¬pkL.Ïè´zÍn»ßð¸|N¯Ûïø¼~ÏwVa+ *)^,*ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃ¶)'ÆÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæÚ¥("ðñòóôõö÷øùúûüýþÿ 
H° ÁòK"RHH±¢Å3jÜÈ±£Ç CI²¤É(Sª\éÅu&@ Á²¦Í8sêÜÉ³§Oÿ(Â±DÐ£H*]Ê´©Ó§P£JJµªÕ«X³jÝÊµ«×¯S84± hÓª]Ë¶­Û·pãÊK·®Ý»xóêÝË·¯ß¿Ó} âDÌf(^Ì¸±ãÇ#KL¹²åË3kÞÌ¹³çÏ Cm¹ðCÄHXÍºµë×°cËM»¶íÛ¸sëÞÍ»·ïßÀN÷ÃJ Á®¹óçÐ£KN½ºõëØ³kßÎ½»÷ïàÃO¾<v1+_.³½û÷ðãËO¿¾ýûøóëßÏ¿¿ÿÿ (à_YÉ@Ár5èàF(áVháf¨ávèÿá (â$¨a¤H,¶èâ0Æ(ã4Öhâ	*¨"<öèã@)äDiäH&©äL6éäPF)åT&©\;V©å\véå`)æZ^%	d¦©æl¶éæpþhfqÖiçxæ©çsRæ*è ÂÙç&ªè¢6:ä¡F*é¤Æ	i¥fªé¦O^Êé§ Ê©§¢jê©êª¬¶Ê¦ª®Æ*ë¬SÂJë­¸æ*¤­ºöêë¬¼þ*ì°¥Kì±ÈVjl²Ì6è²ÎF+-ÐNkíµkVí¶Üv©m·àÛ©tkî¹Q~ÿîºìò¨n»ðûn¼ôr;o½øN{o¾ü2»o¿ ûoÀë:pÁK®	7íÁGl*ÄWü)Åg)Æw)Ç¬(È",(É&§'Ê*·léÂº,3¥,Ïl35ß¬30ïìó³=ÿ,t 9m´E­´A/ítI?-5QOm5U_=uÖZ?Íu×KöÑb=tÙfÿvÚ;¯ÍöÍn¿=sÜr»LwÝ*ß·Ézï-rß~{xàN¸Å.qâ;Ìxã	?yÁOpå÷yæùnÎy½oè¢·Kzéëú¹ª¯.në®{ìö6Mÿ»Ö³ß~mîºëk{ïRó¼³ÂïïïÆ+]|òÇ.Ï¼ÀÈ?/´óÒûJ}õG½Î×ok÷Þ+%Ãá«­}ùv~Þê¯ÏwûîÿüÏOáößxþú/Îÿû #'ÀR®¼¨¹2°s| è"(ÁÑQ°¦» S§Á²®|C(»°vãÙ		ÂF|.dc82ÒPZ3¼aªl¨Ãfå°Dã!õÃ!ê©F¤(,$2±NN|¢¡(Åìµ°L!¶ÈÅ.zñ`£ÇHÆ.zaH£×ÈÆ6ºñp£çHÇ:ÚÿñxÌ£÷ÈÇ>úñdÇ@ L¤"ÉÈF:ò¤$9  (8&ÉÉNzò ¥(G©FB^²!Ë¨ )WÉÊVºò°l¤)1wÄò¸Ì¥.wÊYºäà¥0IÌbó¾|ÉHpÌf:óÐìepJ±}È¦6·ÉÍnzóà§8û0 Â%"¸æ8×ÉÎvºóð§<ÉPÎQ`ò%×$>÷ÉÏ~úó ¨@JÐô M¨BÊÐ:ô¡¨D'ZPKF Ö¼&16ÊÑzô£ ©HGJRb ÷Lç5ÏÁÒºô¥ÿ0©LgJÓ#(e>¯Óúô§@ªPJÔ¢õ¨HMªRÊÔ¦:õ©PªT§JÕª&5;%U·ÊÕ®zõ«`«XÇJV«ÂC§ÑjY×ÊÖ¶ºõ­p«\U´À¦xÍ«^÷Ê×¾úõ¯ÐÀi)$ô°M¬bËØÆ:v,à²Í¬f7ËÙÎzö³ ­hGKÚÒö´¨M­jWËÚÖºöµ°­*$ÛSPô¶¸Í­nwËÛÞúö·ÀÅm + â¸ÈM®rËÜæ:÷¹ÐE®?±9ÏêZ÷ºØÍ®v¿9î"ºÛ¯xÇKÞòbÑLÿ¯z×Ë^A¢·½ð¯|ç÷Ò÷¾øÍ¯0í«ßþú÷¿¡ä/Là»×ÀN°ï(à;øÁ	n0'LaýJ¸ÂÎ0{/¬á{Øþ°G|ËøÄ(¥SÌâCrÅ.±	ãÛøÆv¬1wÌc6ê¸Ç@ÞñLd¹ÈHNñÌd/¹ÉPÎð£LeO¹ÊXp·|â+sùËýõ2ÇL_1ùÌí53×M5³ùÍÇt3ç¼_:ÛÙÂwÎsõÌgøÊ¹Ïp ýÌ?úÐ/F´¢ë¼èFãÒÐt!-éJãÒÎô1­éN»ÓuÿA-êPºÔ>5ª3­êUWºÕ®4¬cÝèYÓZÑ¶¾õ¡s­ëAóº×þ5°ù,ìaç¹ØÆ¶3²=çe3ûÍÎ~ö£-í3S»Úc¾6¶¿¬ímo¹ÛÞÆ2¸ÃMåqÊæ>7Ó­n$³»ÝD~7¼,ïyó¸ÞöÆ1¾ómã}óÛÈÿvµ¿Þâ\É/µÁNâ3ÜÉ÷´Ã#ÞáS\ÊguÆ-mñO¸ã0ÈC¾à\Ë'_´ÉS^à³|À.ùc.ó0×Ð4¿9~s®ó=÷¼Ï<ÿy|.ô4]ÏD?ºz®ô67]ÙO§3Ó£ÞÌ©SÄWvÖÙl>õ­3Úëdî:Øu)ö±?ÚìÙF;Ë®öW²½í­|;ÜW)÷¹²îvtÞË½w¾÷Ý|à×=xÂÞÝA  ;GIF89a    °Ç   ,       D ;<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

//-- We must change the returned mime type (default is text/html)
//-- And we must do it before any output

header('Content-type: text/css');

//=============================================================================
?>

/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */

DIV.tabs
{
   float            : left;
   width            : 100%;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/bottom.gif'); ?>') repeat-x bottom;
   margin-bottom    : 0px
}

DIV.tabs UL
{
   margin           : 0px;
   padding-left     : 10px;
   list-style       : none;
}

DIV.tabs LI, DIV.tabs FORM
{
   display          : inline;
   margin           : 0px;
   padding          : 0px;
}

DIV.tabs FORM
{
   float            : right;
}

DIV.tabs A
{
   float            : left;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/right.gif'); ?>') no-repeat right top;
   border-bottom    : 1px solid #84B0C7;
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none
}

DIV.tabs A:hover
{
   background-position: 100% -150px;
}

DIV.tabs A:link, DIV.tabs A:visited,
DIV.tabs A:active, DIV.tabs A:hover
{
       color: #1A419D;
}

DIV.tabs SPAN
{
   float            : left;
   display          : block;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/left.gif'); ?>') no-repeat left top;
   white-space      : nowrap; padding-left:9px; padding-right:9px; padding-top:5px; padding-bottom:5px
}

DIV.tabs INPUT
{
   float            : right;
   display          : inline;
   font-size        : 1em;
}

DIV.tabs TD
{
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none;
}



/* Commented Backslash Hack hides rule from IE5-Mac \*/
DIV.tabs SPAN {float : none;}
/* End IE5-Mac hack */

DIV.tabs A:hover SPAN
{
   background-position: 0% -150px;
}

DIV.tabs LI#current A
{
   background-position: 100% -150px;
   border-width     : 0px;
}

DIV.tabs LI#current SPAN
{
   background-position: 0% -150px;
   padding-bottom   : 6px;
}

DIV.nav
{
   background       : none;
   border           : none;
   border-bottom    : 1px solid #84B0C7;
}
PNG

   IHDR      X   ø!e   bKGD ÿ ÿ ÿ ½§   	pHYs        tIME×00Eÿ?    IDATxÚí½i¬$Ùu&ö{o,¹¿ýÕÚUÕÕì}å*îwÔÆI3Ð,6 Àðÿ¶X2,Ã²Ûð Éc${ÆÚ(5)J×^ØÝd5»ØK-¯¶·çÛ½÷øÇÌÈå½Wìn5î,^FfDd,_{Îw¾s.áu¾F³ØºÉÞk/jP¥JµF­ZÎz> Âqò3ñ¯zØÜÍ2$iÌYkìê1Á+Ä*Y!aX <üODxëõ·ëõºîÖ,·oØÖËôDôwo\µhïñ==ö.Óþ# / -Ââ
ayM ¹HªºÙ\¤íFºÂnàRãz<à­hnq\©RºzôñÓd×ñ|02  óÿ3SgÏ.óËÙFã=û5ý3OýnílYÙü&ÆïË/ åAH¨T	µ&ñÒ*aqEp£(E=?Äz6-lVkÔz:Ã$æ«ñ ÛYÂ©¶)^?IÉÚI¡d=,"b ú-kø#.fö/¾ xéyý/|Kÿ'_}2[èí3ña@óÝÔAÌ %åH$ÂèVÖ×°BìTª´QmàZ¥F{¾(¬Õ¯Æ¾¤3Úq²°DÙÒÅÕ:ö)«7`Ã
Yé!&B@[CûHàbæð{Ïeïú+úW?óûñ;¯]²y>¨ælúýËDÎ@­AXX!n-­ÖA´a+uÚ²/y>úA¸Ö$-$6=¼jÚaÑÂ2e*öÃzÍe$+UëÐJ¡ äÃ²%"~N? ¸9üîÓÙÇþúÏÒ_ùÜÄìm³ipøxäu_È³ãÿnH®7	õqµVZ¸± á:[Üò|t+uTkd	_µ»~@ZQXÅ@*t-ê¯GiÒj± èè­áÿ¬ X×^N>þ¹ßOÿÏÿ?É£{Û¬õ«^ÈÂÃÛÉuæ®?sxDî½n(+@P!àzÃÐX])±ïhÐ¡íûØ	ªØH¸ZGoõ8v×O¡»´FI"%BÀ~ÿAÇt`}çöO]xÚüøÛæ±WØc;ÿÑë¸Ù·³|ØºG>x¤eÒ
ÀHI

ðp­A¶Ú !A
dB¢ëyØÚR"?Ä~µJ?@V`[Ë´·¼k'Ði."Q>p9¡þQé0`=ûìþO=õÔî/_øïíßýªïõ»ãÍ@µÁh.[! 3,ÈR@g££	:ÙïíZ³Ûgìµs:¶4#ÖkØ°VØó åQWl	²°»°HJºÖ0èæ"Ìò::\n.`¯Ö@T m!pÀ ·Ù¿!ÖOÞüå×¾?¶ùâ¢¿ùZ,s¡ïýÀ¢²²ÔoBSÂ³ð$y¤àIJäØXVÉL"¥² SBL0nc¸}~Þmìß¾uÇÉ®Q¡R!¬ ðDli¾ò`-Zm?Äï#©Ô­GZoa#¬âF­¨µA½Dy¸E× ´HÿPÀÅÌásÏµ?ñä7ÿ«¿þ«ÍÇªåí½²rÃªg@Í°i~×Â I¡2@jÐÊBJ$CÎýá@P
_yð½ ¾ Á
d=°ñÁÚÉ$²T KiB¹u$Xíh·×3ü¾jÍ°Þû ò°,Aù@+% <pX¡g-zB@Uèæ"t¥Îâ
¶NÇKçïÇ×Æ3Já*ì°r4XÁºýâoþÊ¾pãkW7'°ùý&Ãi ì"m¾S'[íó¸yY9ÿ,,KÃÏ42XÊ ÊÀ"DÈ,R@dÒ¤	·	@I)$P¤à{BßGàð½ ô bdñÀh4&¤±¢ÓX KØÐ¡nîgX§d·;ìÎ'ÿ
:(öCØ0Ä ±í3wáÖ}áÅÞ³´' ä3Ë»ïýÊ_oÿÆüÉÆÛ··êÜ¹
Ò'píÅ´>ÄÉºr¼t÷;ìæI\}YÌ¹<zë(Xó÷ 0ãð=È8 "#)°L`E#z iABB@B
"/aø ¡À÷<H@Ø Â Öw1È"4vï&°%0S~Ír÷CàQë7dsA@. 	BØJÉwáÖÇ~ùÀ;ð«õ]þAÁ¥·nÆ§¾ýìÞ/}þó×ß±½=ZgP*DÊ10ÀÃâ®jiÙB(ÒË`víáçünàoKãÍcK0Âå1Ñð-¹­aò0zG*ö±'¾®æ/;jA¡¨È^
ç)T0@¥å@XU<QDÁ­Ö
:ñ c,QÐ5kr0ZfBñ0ã¢x­G>ã»Ñ6ùös·9hÌÎ Az¨ìïàÌåøûü4µ]ú×.k­úÌ¿»þà÷¾×þÙë×{RëÆ¤°ÖäÁ.;0äà2¶F'0¬ÝQYÕ¬m ø² <Z.r|BUûÝñåCùz;ÐÕ*!Î¯>sënd	ÁR	J0@>bhJò.bÜ	 " ¾ï9 O91PøTä
È +°ñaÒ &ñaR£Ø
X-a áx¤ÂyS"£3+r&È&Ày0C è´³à~ÜÜÀ?oïrXoâÿêö²*±¿®üóßúÖvEëZ§06óÐM<iS `[¬ã,Oþ «7s¿ó¬ÞÄ2Àâ Ëà© «§plmÛ»UØDBñÄpÅ2#Æ.®Ø?Ff9ÅTxõ£Ñ]B "!¹FÎ¯d´|À÷à/áU	ò¨*|Qd}­³Vû°Z5*¯ÀV(rf}Èü®?Ý6È  KA_kA_ûÿmkùO s»¾óÂþÒÆÆà}ÛÛXl­;X\ÆfXÜXÈü*3>b ÅýÎJ óÅç~ÏS'zMÈg6ØA7³ 8Ó|v÷NèTÉYÃ Ñ)¬N`	4b¸®½¯ÓQRÁ£:¤PÁSR
HEð=¿âÃWÆ x!ldB°ñÀVº¿Æk·£s! 0)é}'WñÏ>ò3¸ÁÌß8j$©  M­×d]¸°{Në$ÉáÿxÁ[2ÛÃmÆ¾ÒÁ KÁ´:¶ð¸ +`dyPÀ`hDPÊÃbãUGôéHðHgúD¤ ¬ß@«qÍV½¶eoDß¨¢ÁÈÿjîÃ²Alw`ÙBÀÊò*Zñ{`LÂ"F}ÑAÄ¼.¤$(%¡J)g½A5¢D¾ómÓ©Y6©I¿ñåÏà®Õuügøi|7Ï\×¯êYf>ùÂw¶H1°ò+Øiÿiêùv¹µ³9<VaÎvea(hÚûQÇÛÀ0ê@M=tüPkÔ¨:¤¥Õ ÁSC~yx.IË5ZU¢â7Ð¨­ Á:ª¥èx1 çÃUÃ[=±^ ,ÀÈ#9EÆlê§°¥C¦5d3EBÅ¯¢Nw­SÐ(^¤Z!Ï ë,ÃdÞÖÞAø/áÇú1<ÎÌ;õR ðüóÛáÆFïvT»b«iÿißUÂÀ_gÜÀ¹ ;êP
@°AAÁo"LáÕ»`#IúH³B
X6ÇVrò8HR¹5ç2°ÕHR£L+È}È A
	
êÕeÃÊ×`R÷\¤K`Î¹'}_9Uó^¤&g°Á$)l¢ÛZËø- Ù[5%"iº±SÆÇÂs¹ÑÁàbfüöo¿èu:ÉYc&5¶^#ÿi%Åýq¾¦,Ýhf·ß!Ä³ûã$áÝdiÙ\rÂç*¬04¡ÀCwÅ;:3¾1¨õziu¨Eò¤(:A¹§Z&AFDP¢.#+`Ëèö:¨ùÉ(¢&J4 ËÙÔÍõdfuÕ°
ºëç¥2>©áõÔ@ûjÇ¯B!l¿ûdc v÷P{þxìÑÇ= ?j´(±Þ$° Ä(EneÈãgÍc|ÒÃRÍÕÕBÀº\£Õ
lÌ'²:Ï3¦ñ ÈR	d:cD)Å°aöès|®«kýÔÏÝÿY¯qâ/úý´föÎë×âüÆ×;ç¯_K$hCåDvØÎ¹ÄU1!PMØ`ûH¾KUåâø/b ª£JP2@£ºÐo"bf4Ô)nMØnï`¥ºêSYAtýîúþwðAf~á0¤¸×%`1ça,/ri8+ú&<¦£<Jòèûû¸ã}Öèñ5ÌkPB@)¯ +ÁLRB	|4Tvÿ®~ß+È£ã1`iGA3Ã²-û\sXnbF½%Ì»ÞµöwÜuüáÊE½[1º4uÀ²Öíßpf¼Ï©k5~($`$YZ§È2	i>¬Òõp¹¨q<DÁ2òBÕÉR03tU:rDAàf;÷e5èwiùÒEÜÿ" 
.¥°§5¼]ybf>­0sáÂQîÐ@A£Ú;=ìíßÈ@9Rý@
Ïð=ãk«8·²zÙeãñuçÈ°Ö@H;óiôMÆ`çÜd[[ÉúõëýO>õÔ­»66veC`YGD¾tNó0Q0ûØ ÖmShÙÂùÁÐ\lÕ±~ò2`sknpjé,äÞÃ°©f²@´L¬$HW`)ÊÓnå Ä}V{[8ÆLÇ \:\äyBãLTXî	'ÁtDîcäÆÎú9ÛòTJÁa0ÛâRDÂC-ÌÀu;Ö³ÅÒZ.kÖZHòÁ´G2iS Ðí¦rs³W¿reG¤iX CP¸Î}âþÆÃó/]"$·zÆÂÈ1³Ì¡ÕÀ=÷,î?øÄýZí½NÛü/iï´M*Û!´©¸u £BÂm®G¨AÛ¤Ð`ø4ºmú=Ðî6V­ÁéÃÀ% À÷¥§µ»q4r®CÇÐJqas²u8þz×Øv<¤ÎPò%)(¢hi>>0çù½å²ÈE[ RP>ÖÂr² 1&âëÌº¬áuÐÆÅYûãáÅ ±XæÇÆÐÚºD<ñìcÊßV×BýwþÖã?þ¶7u¯k§}Ìwk}Î9gò%jH³ä¥åÛo&À úÞ6äÐÒÔLÅ$3ÒÜòÇçÜ2,×ATUðô:â*¡:W@¸¿$ )<@QµKäÒf²yZhhí,3µ eKÔÂ<²7MI& ªVº¾O%`¯Ö¤L1ÒÜDµ³b
Dªä§ÖÂYÃ£6½mnnß´ÿäÙowåþlïäKKêJ»ßfº­D¹â*$CÃK`Ø:*ªèÏ2ÃZZÞxÕYðCÅ $1SÀrï©W<(ÏçþÛ)3IEL
xz-'rÑ'hø íä^æ¦Äå¶WRkÄÑ¥â,µ$í81&Aß Q«)ãy3eD G&|&Í1âÒ»î|H³§ç*"Ö _°þÞ6î¢ímÝ)ZúÄÙØâ`*CÊÓ`ØL­¢*º±\gÿ¶tÆ+7®â3Äø\8ÖSÀÂ]kxêÉ}yä"wè#ÇÎ=å¹/1JQYæß|;ûÝò~æàòvXÌcpÛÓTIÂ´}×ÁT)!)§`Ê£C¡ôNGs½³Ì3Ì?ÁÂNølÅ` ê1®¾BP +x¨"@M7.©EApT¿@ä!ÛO0è·Á^ßiëJ c"DÈÝMÔ %dÖ°èy¢>d!¥µ13ò3@ç¼ZæQ´x¨å,æT	¾JÇF)K0Í§° Îz;Úv®â@4 }æ_'ï_©5dºwim¥wÅ eáÔ´SXÒye_pÖ¾s_ÇeÅèÚGqv÷ÖeË±"ÍçÆ&>³°¹µ[×¿&OÜ}ÝQ²	V¯ßíïb	 e Z.¥Dc0È&cW&K0ºìN_	G:?{d÷AËGæLg[ ç4 cí(Ï6Ò«ÍúÙ0ÿF¦.>¯Ï+%
ir
õRÔûªûÀNGÀ18í[8§c+Å)DCO¤wMè@²¨ä>8§u`qD\P·ïîzû¸#ËpæPp	A#Ë5òI¡¤SQÍû\CU¬;ÜrÍå9Â¢~DýWY½À("mhñPpèÇtÄPJÍ#AG±ïÅ¤åµ0èsi.I¸9Î`ìøx
j	ìaºÙÂËf§
²)
!¼TÁÌðl@5`ç×Ç]8 ô2°ö¦×,¢jÛ×Ñ8Ô¡^/£"°rru®C}®¿1ÌÆÛdÎs#Y	î 8}¿bQmh(È S[Ö0Äì>J¡úíªg'"Óy¾ß¼hMÀwjaºJ[@FÃlíÑ¬Òë0H%WXèt µ±bdý8B=H¡£êÁÌÐ+¾Ïk[úC-WXTùMÑGð¹Fªq8D$¢çzæP
@ÖöQ¹ã:üÎk$L¡ýÊ¸gÖ`¶°ÈE9õíçsnêÑ]HåCãØr±s"Umè"hËë$YËÏ#hÔC(
ÐOÍº ,w'ýj!J£	a}ó:Î%v.¸PF#0 ¥ [Å~PIAÀcUE(FrG.ÏÒtæwgk§ïw¿#;8¶^Ç}÷Ã1ÚqVJo¹Ü"ÙäjÔùRk¾É¸íxy=¦YÖ,³°®è¬0SQ;¦$C¬«éw>vZ_ßÃgÙåIÁ03`0· dÐÚßA@®½À4C¯/­-¡ó1´á)fy¡/0íy&hL¢À2O2ê}Ð¾¸@·Y,.VÌãï;÷ê?þï|õôÉ¥lxãÆ¼ç¨íw:#qÔãÃAÇ>Ú³\Ãã²ÖÂØÔ3¶ºNîß-{ÊÃÝçN>ýwøÊ/ý§ïùw¼ãäv%TSÀiªÁª;É3ºûLqO0cu®Ïeµ,ÜÁ/¼Î¶º¬?$¸5â¹R 1ø)B£4Z4ÒsYXèü¯Ñ.;ÏLãÀa¢þX`}­©ßñcõ§?úá»÷ÇÞ}záOþèµ_&¢¥2°ÜM´lreÄmAÏ9V{ÖoH«o¤)¼À xLÁÐáû¼åVÓ³O¼ÿÎù4ÿ«+õNà«Fk!üx¯å*4õrmÞ´¢³Ï4Ð$Æê¼£Ê2­YpQ"!Ïå*µáZøÉ^.ãÀ!èL^lÀ)!û õm\éR(ÿ»²1kóúC®,Ë°Ð)A«@~àÌSïy|á·Îß¹üÙzÝ¿WJú%Ç	ú¡Û°	ÈÐÇxïæK~¦%7¥ýÐðÜhtýqf8féçÉ¦½s@Ø³g[WßvúJ§T´±ßk6ü_ a,#ÉzNÕÝ¥¨æÍ®Ïµ\I¢IkëUã¡CIg«'ÒóV:ô\ÐÐãð¨Nkukï.%ßÎë%¤PRBI	)Ü2å¡ Êõâúé¾ïÞµ§îyàßzàáæçî½gµ ­õÆéqTlØ¤Ît¨OGUÀ4Æh÷¿,Ki&7MYúáðÝÄXuþÐ9ÀzitÛÌD°A £J·µNkxÿ{qA,Sþµkøôµ×øÄ¼Qij¼I`Bº¡Íg89Î·§<a'Ùé¨Ë$ÑèèGk¸2lÖ+¡z8çrvê®æS¼=ø­ZøüùsËm"bfÃP%ÿLC`qÎs9M×E²ÍmëÛPÒck:®t*Zbýönz°<1LN.=Ì23QÕç|çÒG,ÛËRÐÞ6B ÏíÕêÍ » /­Ûëc5LµË@4Àòæ5^vYÊi¿ê÷3J]KóÉmÅÜâ¬/3
¥®Òl^Nqfúèö^C/´ªæñÿèÜÆ»Þ~ês'N´þÍù;¿uþÜr· ÃMj5/¡¡æ±à[kAÎ°\3@ÆÖbko¯ô	äU×ã<"WÌ*,´ê8½þ´·WaSÌTDPÊ¥7cp¥©ô'*×oæà"ù)öwìZã? ¯¯¬Ôº¾/{ÌX*Ëá ßá-E`4G:²¢Ýk³ì¶© 1ª~?CJX¹ÊsUg;u ËmËý`¹fêÔyX1|4pËUóáÞõÝ}äß8{féÏÏ]Üm5+éNjU/ñ[#ËæQ(Ò8¨|.MûÑ`¦¸@F8½$Ã
¢@¤<ÙÃìÃ@DLèÎ¯ýþ§ç_ç¤ùxkÈ½¦/3ÀÌÍ²ìï01óÝÌ8à)põºÅ®Bi.D|Ã=#R	²!ûM<Ö©$ÓE¹nÓxµ¡ýØGï¹øÓ|ð¿¿ëüò¿;sfi0-N+UÊÀ*ªQ±¶`@°yO í&#©mFÌðKDj:HÌo§ÝhàòEÛøßL?Þ\¤&±6oÜå¯Ëã¸e¿¶y­¤éË2#»%Azdû» ^+IN½êRc]SÚéëp¶rMö6òb(W"öjÔ}þä'îõïÿÂc¿ræôâ?ÞL(ÔÔPéÜÿc!ýã¤Î"?Õü. ìÊ®¦Õ²®¸ ¦s¬³öë¢á±2Â±ôÑ8ÿhI2:I@×¯ppó*wkjP¨æ~£8Z¤¦!-¥VOWTÅ·®]¶µÙàêeÇºÎ¹?Q&mæuRú<NyìsEþQ«	<úñÉÍ~eý~Z1Æ
$AE)Àû¿óµþôCÿõý÷­èÐæ&¬(ãîO¡Ükd¹rMÍï"+Gë<`	R° e aÁ,ÉSÂ\Î/8NóÁùÙÃr·EßCåøU"átLÀZF?êÁ2Ì>n&Ä1Î\ºÈ«³"F52Ý,Z,.£RÅ¥I4JÛý2çæÉæSgBûóÿàØ?ô©G¥R{ | Jk[ãÌïtãj§7ÒÔgÏ,=Õj8¹ià°ÖÕ°ÍzÌoHRXB!ôhÊ`©aÇÀ &dÚµìÊi¿Å¨sx¢4RqhþUxÒ3.NÕ ¨ËÉ0êqò~Ç+IÏòaQ×·oòÊ¬QÅq45QÉ~A®[.ÎÀÁ£a±P¥=ÏrÍ jM>òy"ñÆ¾l*+5­yvÌ'ÀúzÍ>øÐùvn{{«_»|y¡ÓÎ<K¸Ë¤:ôxJÍ9;¸ñÜÇé~°j0h«³ llÂ[¹
ée vÛ{  êIDAT (´Âã¸úíS(:³ûÐgR§èõ#xk1ÕQ~g)M°çKJTZÊ2SãÒ=ªÛ«7±ZEv,Á)$¼áÉtÆ:K¹O7á%¥ØÒé½÷a´X´jóZ¾"¼÷î?ù§þÒ7_øÆ7®¼ûþäÅ_ú«/_=Äv,çÏ9-¼ôl¢çt;`zyQuûZU{xêÍÍ6®]{)öFn>øcïT' ³å±æ-IfX¤ÜÃnòE æÅ"ÑMKlÅÖ`a\BZs0	,fÎå·Tªú,5*dÙBn±Ðæ¥[ÅuxoÿF½rG~CJ2E`9*Âéè]yO¸<,&4Z²südíOl=ùÀýÇ?w÷]ë/·°gfgËÛ$´«!P(fKzýAÅÎï@tç¤]X§×_ÑGHlÄ
=×f*D6S`ÙM	ûöSðé^Sªßd­V±£àh!/É',(r&ý TÄí¼@ö<Ö-Ùq¿k]Ø0GíP| ¬eúØR=ñFxÀr»qàS·9U»9&Ré(Ê =EÀ:§Ü	
º½AÍQ1ù@	ÀH¹ç¾*­¨«¯pu*Z¬V´v°f<OgTçN\èëU %Ms$}
rsü¦MñP©x=ß\ÖH,h5Ì¨t^ÖaÖ¡×f$±0Ôk¾{ ªbf¡SÃ\1¿¼DÍ@ø1+%ùPæIH;Ýî<#êaýÃt&a´`)Å5DIÊ7H#1}ZF4à;¯½f&#FU«ùÊ;Xy)O·ù×Ì¶$,w³ø­2½ñ¦ ¬ZU}Ï<©éÏ3,`Ç¹ °èuúì»ýz&Ub
XÌ8N¡LAÒ2_¹à(?»"Y¦A*REÌRcò!ázªº{ ±½¿íõÔ}	G:øÉ	´o4szZ Ð@°P#¨)5 ô»¼ÜÞãÅÉQÕëef
X<êjCÖ43¸®È¥2FÃpåc÷¿¥Tòr]½u¥MV»ß¸ãNeWT2O2ûúÁåE7$QËÅ¿®ßôa)M¨ÏbÐ³Ugm4S©xSÀrõ¤§gZÅi+ä×ÄÈ±NSVñT¦Ùl½Bîû!á~g/>ã
o@$°¶´3­ B6`ôÁz+XkdÀN03ZÝÝ²`Ç&#F*H3]¸0â&î^Ly0hãêBZ(/¼q¾ÐÍ²áÇ*á»J*<±hxâì;îTÏÌÊ®¿A+ñ`ðtU¹±.A\o9ÛiztT¤,?'p52õ<±ëû"bæJX+= ³¼OÐÁÂC©EÞ©B2]Û1'eHî!çlíÎ p&<¬WúÊBg4¿TÕÑRÈÕúÌhuóºBâ>cÐ KúùX4ä¹ì
óï[hh°µc¯Ý½Ñ!Ïl! ¤ÀéSö|ûK¾ÓÿÍµãêoÖ«ÐË<Oò°ÌXºqØÀüI#òùáâfZ5ä'>Të4èåüÔc7¥] "°iÂ¯%X=­a2rí¬ëj3Á' QÚGFk¨?"&f¶æAR·¦4+7¡I |$£)T¥ÈÁ\"¸³ÇH"^ïìqXrè}_Ö¢(°X¡sëØçCèç,»;)×õÅ$öPEÃúz?ò¡·½òè£'~uy%ü¬ÈþåÐûÔ~0öe[,Û»1¾úÌóð=5TM(û0±Ñ¨àïýÇî>öã§þzS|}Z
Uß÷EJ<Wó\¬ÑR¼ðê·VPR9k-¼\ä¨ IèàÊÆ6øF6<êB½¹·;ºx ÁVVÀ	6NkóI´ftw3°6SªZ,Ä:3È8B½¦÷eO*8½ãÜdØx0ÔÄìZý¸ò)EÊóD­?p5EqÓÏ»Lú¬Hq
d=Ï1e÷³V$>ýG_üïþÆw,|×ó9@aÊÃÈÛ±rR
ö}9¶k:«-öÛÙÛ¡ýäùîû?pÇ¯-­Êé4|lµê§¾/u±Ûæ}çu¦ñâÅËÒuk&P>=f¤$|T Ít¡½yç.¼«· É)qeA+!ÀØÅ.4Gsâ4Æ^¼¥!CGÞb<Ñ8SJè´3¤WuÊ³Èb1£é÷ñàÍ+åQI)ý^:ÁïäÅ èÉâ@XA8wæ$ñ®^¨Ã§!½ÌaçÂbð7åyéX÷½iÌßñx>iÏF)2R÷Á$xÁó	~@ö¥âMñËRÑÀóiày½ßçö<ÒÊ:ûÙ§²AH[B`$Í.0>ã*l0Gø©ßüïþÍ3w,þkkõ¢´<OH¥6%ËÂiflF·e¸:å¥=´w3WÀ[ A 1ÒR 6ì¶HBx ÂBjhm§e é/_¾K×6FzV.ä 6O`¡FûSbEf`gËí=ª#F%%5zýt¢fÑ´³\<­þ2!ô8sâN4Í:n\00C¾Ê¶Èöo~QÓS_¾U#Â9f¥b!ÏÔl\ïÂP ¬û!qöÁ~@ð°ç	( ±¹& ³g¼_»S-Îä´
»É¤F3¢1x¸·4`BàlýLwåñ«/µ«/EøÆyê+1ío,<Ú¾|r­¡%4§ù¼A\ËîïØ2y	áôÉ~ê÷ag+ÅþìUô{	ònÐ á¬mCïîÉÛ	[oà~î1|à'îq¢1d¸ðâüÎï=ÍÈeÁR
6®AÝ¼`8R½¨fÅ ¿?¯Û¹e©RSgªT%5»¤¬|ØM<Wb\1<Â«,ÃÚõÅgïqý³¬sZmî¼Z¶ÈÛu»Úa{¯±"6ïfS¨"ÒÑíZt;Å¦ll/)[H¡
yeÿçÌÅ= >ó{Àþ`óBàÃo¥ ¤ç\8ZAÓ®L¨KiÖ°pWàÅ?÷4£óXÃ©ÿÌÜEPZ¸©^,»ÉPß¶ÒÂ}ÇÏáX«éj/stKÃÓÇë¸°»cu>ãF»èàS`#dÜõ²wÀòGòczQµ³¤±Ht"ÆjÔýÚ%KaÞm4þß¸¨Ñïg%`+b4,¨c/\Çþ v îocñ!7á|óîIæÆxè\n2|O¹xÏ1Êl	Öº÷Cº¨køFßèÑ÷zXIù:ÃâÝ³cNnä0
ÓÓPé;×Ò= ~
j2}á&
ø£Î¤ÀÍ«'RúîLÉÛw^%üîÿ¬ñûáp³Åp5û;ç±&Ï»ÔVð¾¹kâKX]mà¸÷.¶°§/â¦þ»ï¦ ) kÈîwÚØ6ÀÂG¥ PØ»²ä®!:û=[ßÙ´£ù]j(-yã7!Î3i¡í }=Âë£§ÓMK£D9GîxÝ¡+rÎ]0÷W
Ç	) û+NäßÖRõ!H@H§oW$Ü>IHæ£ÌÇ=ÃÿýOÈÄC½Tþ©Ëp|®ÅhÃ9-MüÅHÞd-) !SÏäªJ9Û¡bÅýM4
Ëî½_¥By{o¦YÃêR+ Û8©¢5!2£¹#eXHR¡Dý^VøÕBY#ÝuÐïðÛ®¼l«C§^ð³Ìe­EÔjuÂsFO¶(R\nAþ£úxñ¡pg.sFÛ¿wß1zàä÷Þ}FBÖ³è÷¹ewpÄð	ý 0å}äÝþ(bàc{ÿêUÚéh`Qí=^Çb»w	]s=÷-?Àjã{i?D°´fÍj4óÈ0ÿÚíðÛ·lkHÀ)c¬(VþXk¡Mý¶}´VrÖÚÅ5(Û)ãGXÁ´Ã7å(ZþñßÂ{ÁïNDÐlVÐ¨- ßUØì@éË)õ,4×QÙxÄ^ôi5¤ô°º|{7¾sýÍ¼Ë Ý ilÊ)À[×N¡ÚAim%&eL~ß¢3hc¥"¢ÁáKBsZìç ûÛ¬7©oÚ0Þ=ËK5__EÜ÷°³{RðÈÃ'ð¾w=½-\¿èDå
|	 x "Ö!¼Â'DZ#1"Uo]3ÔZôïbÆ× $®ÚÚòX]ê`g¯åõÕzÑàð|²`av
1"ï´èÄoë=ÔKUÜw÷di«× 1À#Àû >ï]që5	¶@U¬!ðjN6-=È®ÄÖ%À¤;Mxµa0h{£éõ+¤Ò ±cí[¶psZ [Û]Ü{*Bs±Í£²uÔ²·Aq±¼	#»yÃýbEöXS,à)MXA¸3.,­;?~=J{µùo)°UÜ÷¶óÙ®¿¶Ð¬ã¾{Oá½ï:Á^×/ÅèµCd±ç3¼ÐRJÐåAÉFäµ¨DÐq¤ÐE}9Æò)4ò0h{èî½6ß¼î"F²ÐÌ 3cow öúh.2Äm?ä´ mì|½ÄPRÑr!E2ê¬ë¿JÕÐ(ÎèaÇ\±kÔFÀxêPíß{\Ò?ùì¸zSø;^ÓbZð=½néÍµÉïË¶gÏö("¡×BU.ãäÒÞ)ìÜ$Ô¢¨]l_à¹¿èw	8yUö±r±w£`q°u¥R­37î­Â>*U+-D]/¯lê£º %MÄ=í]{ÿÆ+&`f¨8É<=X c¥ØnoãôSXxEawëèjbÅM¤	¡g<axÎdæ*M8êþ]Þó:Ëâq^)Ë7¦×uÑ?,Cñ·ÆMïF ¡qJ¬0³{ÉfO§7µ>÷ïùg«øX²Èv{[ÈVÂºE¿áúeFw«$u¼C	Äq`ùDN£½®F£µ½Î>D²#|¤± Ap¶¿-¡³oîjïSu¨ÈÂ@ KÀZ.\Á=<{9g¾bÄ·gú#?mÝZ¦YQÏy^i\oDÇÜ_Õù(ëôCDÍÛ_qtË@sÎ³ìo8ü H­&Ì^CÁÄHObw½}ÏÊf,A÷¢ßëÁÈ.+È-¨ëØJ7±´XéUA-@ìì¡Ûî!hÞDmÀÞ`åxs	Àkby¹òôù»§TÃ©Qnmuð_{w¾½ó÷{ÞtaJÁ<£¤¸Àó+fm7¯eæaë~ó)í(e ÃzÍÂgCruD¬r°"ÏûIWghóî¬\oxv@!xÿâ Ä>£ÿÒ\Ï
Gé³\Je$[h_¯c÷j44+K¡j](³ýÝã»yb;hµªèmWAõkh,e¥ëì·Ð»~ýkhï2­¬Ëw2CªLÛ¿~äáãüüs×ó4¡Ï¹Wzuá¥ëXY~ïýàû°¿#qãþ¡ù®GQcuetôí&ÄÖeÎCç ÎóöõLúPDÓÜ6ì³*²=j¡Z0pt)7å³Í¬Cô®ØµûÃSf÷4º=,%¤ý*$«Q$×ËYÁ$
©6.G0ïÎRboopé±Ç¿:ê£P ÖP¢µÁß|ýûxuë|èï*¬S ÂõutKvHÜêÐÚÊYÍm Ã!%tGh{Øòäï©Y±E^¨0ÅÒù+8ûÞpö±Ô®	I}Ø £÷\¯fu4òÀFÁDÕ«,ôqìMydõ¥F=M»zsÃZ\¨$ëkg=OOR3¬á%LRûGOãÓÔøÿâ=øË?Txñ¹YjßÔzÃ×mÉ°8Y²ÉÏf­{Ød¥u&­¦{èµnÉbÎ³Â24òÑ E´1ÀÎ~¥Z½¶Åc)Ë©k'eÏc1aO;Ú>zqý+ë/²	A×>±·ùêî»WM÷Ý·gÛ	¬ÑÆÿýoÁw.\Ç?úùÇqîÞ5|ýÉ»[:ã*ÍózAvà¼! Ãº*b¢[àïõlªÏ*¦;èC#jí+¬­® ¨'HS¡4 k»Ñë=#¢rª© -/¶pÇ·cÐ9ÔQmÔ @z;7-ºýìÔÊqÈ_ûµf~fc7Òøì·¯zÙÀ*¾¶¶zøê7/âÜýïûÀ*`ö\)*Gv?D°ÑIÊ¼ ì(ÑááQãÁëeÛYÇL|?+"¥#3	¯±F­4Õê	°ÐÆ ð%t&0ÈÚØno¢ßË0èQôA1è2ú]N´ mU$±¨6`$â4ÁÝyxðÑÚ¿V øÑGO\øÏüÒK~åµ-¬!fúÿê÷¿ów¾<qÎ<º¨bçÄÞ-d IdÏ¢²nä7K1Okóæ[ªÉÍfçQ#Bk©wv4¯pñÆpbÞÝ¸tÅDõÄ\±:¢| åÉ®Ê¿a¡½,Þµ©¡3F5ÑTNîaõ®>jBðÚûFjâJù6¥%LWbáØ6Ä 6dý*L³ÖÉ=	6^«RX?A²Þw/Üü?þÓ~ãÿ_yøÆ¬É[,!NoáÜU[]D=XMªº
qÆ5wù­a.ªT¼á<lLí0®«äï0¯´NÉ²RÖð&>ãmJ`¥Ù­ÂGú*.§ÈºÀ×éNÏ'9>iËpB!{Ø'Ïa#¡sÉ¸÷=ö¯×ÐÝõ&|	+vot¬]¥±Ê#,/øßþxõ+eùÊµkûÿÝG?|ï¯ýég¾sÿînÿHÀràdDQW^ÝÆ+¯nCæ`«×,¶ª|T±BÊÇL<M4oX¡â\f'IÏ©ácúÇg34(Uzv ý9ÃQ¹ÛÑÍ²æåRW	Ñà%,âEU¤}:UH²èì Û¨Å)¤Ë­$¤®¢×÷%"o%KÆ5°»ÜºfVÔð <OÆÛÛ½'Ûødÿöþ½Õí>ñDRù(É[cAÁ Åæfo½þý¿<O¢Ù¨`uy`¡± Táêh:Ò¦1zÔókj"i+6@µ!¨M?õºÀ¤./×:O<~þ=OÔ@ýìÓÏ\}ô{/Ýq¢¬·^?¯,3ØÙíag·"@
åI4U,/5ÐÐ¨¯IàfL)ùQ
	â¬ÃW\S;U¶õF'>þÀÍõSôÇj2ÇÌW?ò¡{ÿ×Åê·ï8½ø÷¾úõ×>öíç6Nlm÷h8³Ù[ÀúÛýr%¶¢66·:â:ÊSÞK`´EêÑLÀÃW£àÓ?þðÞmÃ«&U$:ÌüçË+õï>½ø­<ñóß½pãÏ¿p­¾»;@jö°þV¬ ÃØÛüÀûk4B|ì£÷]ÿèïùÎYúãÇ½C8ZÆ×¿yé®W^Ý~ßÞÞà±4Õ_¿Ñy`ãÚ¾wáÅrãêEq­ÚÀÎ\]©¼>!èÜ?ÕsZÇõ'¼czCò6Vç`½¯F#ÄÏ|úáøÉ~ýáNü«ûî=¶GDGëäûêÆØËWö~æêÒ­­nãäñÖ§vw£:IðÝlsuÑDÚ8ò÷7lð[Jû¹e.¶PMÒÉ)eæûÕ*%"+¥)ÄRúÂimcÎ2¦q$qÅX-Ñ*I¢j&c¬-,ÇmÀác­-ÑC½X©å
¢fm+õ³zµÑ|D)r>39by²RærGfÆµëmºtivv®¡Ý½)ÀúÔÃ7>ññ~ý¡Oü_÷ßwlwØÃnõ£íµXéõ2¹µÝm¢¸j]ôK¥;.èÁ:¼v.3¡)Ïãz­i|?°DÊóY
ÅÕ¨ò½p1­µEÊtFYR¿ßA$ÑyDÌd-bÝ9ø¾äìÕÏ¥°=ïÂE<ÁÆÚáÔîÐÜ£a·Lã{#GyþÐqãÍF¤3Ê__o¾;MõÇ®\Ý}dk«Wù/¾$:.í"N+#¥«ÿ¾W½à§?õÈÍOòÁ_àþã¿7´XoØ°ð#VÙCøÑ~ÑµfPðÆÍvýû/oVÁh®­5~ÎZn\¼xë'¯ßìÿìç¿.nÒövq¬â¨×9òÕ:>þ±ûo}è÷ü÷Ý»þ/ßv×j{²ëÐúÍxëõ>ìÌLÌð±ôÌ³WÕ@¾owgðÓívTç±U¤I½>hÔþ;n¸bàiü)OÏÙï§~ÿ}ÇâYó.ýØìdSì    IEND®B`a:16:{s:4:"name";s:11:"PHK Creator";s:7:"summary";s:16:"PHK Creator tool";s:7:"version";s:3:"1.5";s:7:"release";s:1:"0";s:4:"icon";s:17:"/etc/phk_logo.png";s:9:"crc_check";b:1;s:7:"license";s:72:"Apache License, Version 2.0 <http://www.apache.org/licenses/LICENSE-2.0>";s:9:"copyright";s:16:"(c) F. Laupretre";s:6:"author";s:37:"F. Laupretre <mailto:phk@tekwire.net>";s:3:"url";s:22:"http://phk.tekwire.net";s:8:"packager";s:37:"F. Laupretre <mailto:phk@tekwire.net>";s:14:"cli_run_script";s:24:"/scripts/PHK_Builder.php";s:12:"plain_prolog";b:1;s:19:"prolog_code_creator";b:1;s:11:"help_prefix";s:9:"/etc/help";s:14:"license_prefix";s:12:"/etc/license";}a:7:{s:15:"build_timestamp";i:1303816696;s:11:"map_defined";b:1;s:19:"PHK_Creator_version";s:5:"1.4.0";s:15:"PHK_min_version";s:5:"1.4.0";s:23:"Automap_creator_version";s:5:"1.1.0";s:19:"Automap_min_version";s:5:"1.1.0";s:15:"PHK_PSF_version";s:5:"0.1.3";}==============================================================================
= V 0.4.6 - Released 21-DEC-2006

* An embedded package is now autoloaded when one of its symbols is referenced.
  This feature is recursive, exporting package symbols to the upper layers. It
  brings an alternative to the 'automount' option which had to be used in
  previous versions. It also makes PHK closer to a 'PHP runtime linker'.

==============================================================================
= V 1.0.1 - Released 09-MAY-2007

* Initial stable version

==============================================================================
= V 1.1.0 - Released 21-MAY-2007

* Minor modifications to create accelerator hooks

==============================================================================
= V 1.2.0 - 20-JUN-2007

* Introduces the PHK_Cache class, used by PHK_Mgr. Now, when a cache
  system is present, the runtime code will use it to store a serialized
  version of the PHK instance, speeding up subsequent mounts.
  The mount point unicity is obtained by using a combination of dev/inode
  and modification time (same method as APC). So, if we replace an archive
  file with a new version, the mount point changes and the previous
  cached data is ignored. Cache supported: APC

==============================================================================
= V 1.3.0 - 20-AUG-2007

--* BC break: Due to the change in the way trees are serialized, packages
  generated with PHK_Creator version 1.3.0 and up need at least
  version 1.3.0 of the runtime *--

* PHKW renamed to PHK_Webinfo
* Complete redesign of the PHK_Tree and associated classes (PHK_TNode, PHK_TDir,
  PHK_TFile). Faster at runtime, as we don't serialize an object tree anymore.
  Now, we unserialize an array of serialized node objects, and a node object
  is created only when the path is accessed (lookup).
* Complet redesign of the PHK instance. Everything splitted in a fast object
  (PHK) and a 'slow' object (PHK_Proxy) which physically accesses the archive.
  PHK calls PHK_Proxy through the stream wrapper, and the stream wrapper
  controls the cache.
* The caching mechanism supports apc, xcache, memcache, and eaccelerator.
* Cache IDs are different wether the PHK accelerator is used or not, because
  the serialized data can become different in the future.
* Remove explicit CRC check. Now a CRC check is automatically performed
  before every built-in CLI command, and before accessing Webinfo mode.
* Suppressed the PHK::F_USE_INCLUDE_PATH mount flag. Include path search is done
  by PHP before including the archive. As include becomes the usual way of
  mounting a PHK archive, we don't have to search again.
* Suppressed the PHK::F_PRELOAD_CACHE mount flag. Useless with the new caching
  mechanisms.
* Removed the 'interface' type from the autoloader. It was nonsense as classes
  and interfaces share the same name space. So, Autoload_Creator now registers
  interfaces as classes.


option disable_cache renamed to no_cache (TODO doc)
option disable_opcode_cache renamed to no_opcode_cache (TODO doc)
















Thanks for your interest in PHK

This documentation is not complete, but I am working on it everyday...

Please remember that calling the PHK API is reserved for advanced uses. In most
cases, you shouldn't have to deal with this information.

Francois <francois@tekwire.net>

<?php
//=============================================================================
//
// Copyright Francois Laupretre <automap@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The Automap runtime code
*
* @copyright Francois Laupretre <automap@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category Automap
* @package Automap
*/
//===========================================================================

if (!class_exists('Automap',false)) 
{
//------------------------------------------
/**
* Automap runtime class
*
* This class allows to autoload PHP scripts and extensions by extension,
* constant, class, or function name.
*
* @package Automap
*/

class Automap
{
const VERSION='1.1.0';

const MAGIC="AUTOMAP  M\024\x8\6\3";// Magic value for map files (offset 0)

//---------

const T_FUNCTION='F';
const T_CONSTANT='C';
const T_CLASS='L';
const T_EXTENSION='E';

const F_SCRIPT='S';
const F_EXTENSION='X';
const F_PACKAGE='P';

private static $type_strings=array(
	self::T_FUNCTION	=> 'function',
	self::T_CONSTANT	=> 'constant',
	self::T_CLASS		=> 'class',
	self::T_EXTENSION	=> 'extension',
	self::F_SCRIPT		=> 'script',
	self::F_EXTENSION	=> 'extension file',
	self::F_PACKAGE		=> 'package'
	);

private static $failure_handlers=array();

private static $success_handlers=array();

private static $support_constant_autoload; // whether the engine is able to
private static $support_function_autoload; // autoload functions/constants

//-- Load flags

// Reserved for future use

//---------

private static $automaps;	// Key=mnt ; Value=Automap instance

private static $mount_order; // Key=numeric(load order) ; Value=instance

//============ Utilities (please keep in sync with PHK_Util) ============

private static function is_web()
{
return (php_sapi_name()!='cli');
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

private static function path_unique_id($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//================== Map manager (static methods) =======================

public static function init()	// Unpublished - Internal use only
{
self::$automaps=array();
self::$mount_order=array();

// Determines if function/constant autoloading is supported

$f=new ReflectionFunction('function_exists');
self::$support_function_autoload=($f->getNumberOfParameters()==2);

$f=new ReflectionFunction('defined');
self::$support_constant_autoload=($f->getNumberOfParameters()==2);
}

//-------- User handlers -----------

public static function register_failure_handler($callable)
{
self::$failure_handlers[]=$callable;
}

//--------

public static function register_success_handler($callable)
{
self::$success_handlers[]=$callable;
}

//-------- Key management -----------

// Combines a type and a symbol in a 'key'. The resulting string can be used
// as a key or a value with the appropriate prefix in an automap.

public static function key($type,$symbol)
{
// Extension names are case insensitive

if (($type==self::T_EXTENSION)
	||($type==self::T_FUNCTION)
	||($type==self::T_CLASS)) $symbol=strtolower($symbol);

return $type.$symbol;
}

//---------

public static function get_type_from_key($key)
{
if (strlen($key) <= 1) throw new Exception('Invalid key');

return $key{0};
}

//---------
// Extracts the symbol from a key. If the key contains
// a '|' character, ignores everything from this char.

public static function get_symbol_from_key($key)
{
if (strlen($key) <= 1) throw new Exception('Invalid key');

return substr($key,1,strcspn($key,'|',1));
}

//---------

public static function get_type_string($type)
{
if (!isset(self::$type_strings[$type]))
	throw new Exception("$type: Invalid type");

return self::$type_strings[$type];
}

//---------

public static function string_to_type($string)
{
$type=array_search($string,self::$type_strings,true);

if ($type===false) throw new Exception("$type: Invalid type");

return $type;
}

//-------- Map mounting/unmounting -----------

/**
* Checks if a mount point is valid (if it corresponds to a currently mounted
* package)
*
* @param string $mnt Mount point to check
* @return boolean
*/

public static function is_mounted($mnt)
{
return isset(self::$automaps[$mnt]);
}

//-----
/**
* Same as is_mounted but throws an exception is the mount point is invalid.
*
* Returns the mount point so that it can be embedded in a call string.
*
* @param string $mnt Mount point to check
* @return string mount point (not modified)
* @throws Exception if mount point is invalid
*/

public static function validate($mnt)
{
if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point');

return $mnt;
}

//-----
/**
* Returns the Automap object corresponding to a given mount point
*
* @param string $mnt Mount point
* @return Automap instance
* @throws Exception if mount point is invalid
*/

public static function instance($mnt)
{
self::validate($mnt);

return self::$automaps[$mnt];
}

//-----
/**
* Returns the list of the defined mount points.
*
* @return array
*/

public static function mnt_list()
{
return array_keys(self::$automaps);
}

//---------
/**
* Given a file path, tries to determine if it is currently mounted. If it is
* the case, the corresponding mount point is returned. If not, an exception is
* thrown.
*
* @param string $path Path of an automap file
* @return the corresponding mount point
* @throws Exception if the file is not currently mounted
*/

public static function path_to_mnt($path)
{
$dummy=null;

$mnt=self::path_unique_id('m',$path,$dummy);

if (self::is_mounted($mnt)) return $mnt;

throw new Exception($path.': path is not mounted');
}

//---------
/**
* Mount an automap and returns the new (or previous, if already loaded)
* mount point.
*
* @param string $path The path of an existing automap file
* @param string $base_dir The base directory to use as a prefix (with trailing
*				separator).
* @param int $flags Or-ed combination of mount flags.
* @param string $mnt The mount point to use. Reserved for stream wrappers.
*					 Should be null for plain files.
* @return string the mount point
*/

public static function mount($path,$base_dir=null,$mnt=null,$flags=0)
{
try
{
if (is_null($mnt))
	{
	$dummy=null;
	$mnt=self::path_unique_id('m',$path,$dummy);
	}

if (self::is_mounted($mnt))
	{
	self::instance($mnt)->mnt_count++;
	return $mnt;
	}

if (is_null($base_dir))
	{
	$base_dir=dirname($path);
	if (($base_dir!=='/') && ($base_dir!=='\\'))
		$base_dir .= DIRECTORY_SEPARATOR;
	}

self::$mount_order[]
	=self::$automaps[$mnt]=new self($path,$base_dir,$mnt,$flags);
}
catch (Exception $e)
	{
	if (isset($mnt) && self::is_mounted($mnt)) unset(self::$automaps[$mnt]);
	throw new Exception($path.': Cannot mount - '.$e->getMessage());
	}

return $mnt;
}

//---------------------------------
/**
* Umounts a mounted map.
*
* We dont use __destruct because :
*	1. We don't want this to be called on script shutdown
*	2. Exceptions cannot be caught when sent from a destructor.
*
* Accepts to remove a non registered mount point without error
*
* @param string $mnt The mount point to umount
*/

public static function umount($mnt)
{
if (self::is_mounted($mnt))
	{
	$map=self::instance($mnt);
	if ((--$map->mnt_count) > 0) return;
	
	foreach (self::$mount_order as $order => $obj)
		{
		if ($obj===$map) self::$mount_order[$order]=null;
		}
	unset(self::$automaps[$mnt]);
	}
}

//-------- Symbol resolution -----------

private static function symbol_is_defined($type,$symbol)
{
switch($type)
	{
	case self::T_CONSTANT:	return (self::$support_constant_autoload ?
		defined($symbol,false) : defined($symbol));

	case self::T_FUNCTION:	return (self::$support_function_autoload ?
		function_exists($symbol,false) : function_exists($symbol));

	case self::T_CLASS:		return class_exists($symbol,false)
								|| interface_exists($symbol,false);

	case self::T_EXTENSION:	return extension_loaded($symbol);
	}
}

//---------
// The autoload handler, the default type is 'class', hoping that future
// versions of PHP support function and constant autoloading.

public static function autoload_hook($symbol,$type=self::T_CLASS)
{
self::get_symbol($type,$symbol,true,false);
}

//---------
// resolve a symbol, i.e. load what needs to be loaded for the symbol to be
// defined. Returns true on success / false if unable to resolve symbol.

private static function get_symbol($type,$symbol,$autoload=false
	,$exception=false)
{
//echo "get_symbol(".self::get_type_string($type).",$symbol)\n";//TRACE

if (!$autoload)
	{
	if (self::symbol_is_defined($type,$symbol)) return true;
	}

$key=self::key($type,$symbol);
foreach(array_reverse(self::$mount_order) as $map)
	{
	if ((!is_null($map)) && $map->resolve_key($key)) return true;
	}

foreach (self::$failure_handlers as $callable) $callable($key);

if ($exception) throw new Exception('Automap: Unknown '
	.self::get_type_string($type).': '.$symbol);

return false;
}

//---------

public static function get_function($symbol)
	{ return self::get_symbol(self::T_FUNCTION,$symbol,false,false); }

public static function get_constant($symbol)
	{ return self::get_symbol(self::T_CONSTANT,$symbol,false,false); }

public static function get_class($symbol)
	{ return self::get_symbol(self::T_CLASS,$symbol,false,false); }

public static function get_extension($symbol)
	{ return self::get_symbol(self::T_EXTENSION,$symbol,false,false); }

//---------

public static function require_function($symbol)
	{ return self::get_symbol(self::T_FUNCTION,$symbol,false,true); }

public static function require_constant($symbol)
	{ return self::get_symbol(self::T_CONSTANT,$symbol,false,true); }

public static function require_class($symbol)
	{ return self::get_symbol(self::T_CLASS,$symbol,false,true); }

public static function require_extension($symbol)
	{ return self::get_symbol(self::T_EXTENSION,$symbol,false,true); }

//=============== Instance (one per map) =================================
// Automap instance
// Used for plain maps and package-wrapped maps. So, this class must support
// plain script files and packages.
// Using a 2-stage creation. __construct creates a simple instance, and
// realize() really reads the map file.

private $path;
private $base_dir; // Prefix to combine with table entries (with trailing separator)
private $mnt;
private $flags;	 // Load flags;
private $mnt_count;

private $symbols=null;	// Null until realize()d
private $options=null;
private $version;
private $min_version;

//-----
// This object must be created from load() or from Automap_Creator.
// Making __construct() private avoids direct creation from elsewhere.
// base_dir is used only when resolving symbols.
// If base_dir is not set, it is taken as the directory where the map file lies

private function __construct($path,$base_dir,$mnt,$flags=0)
{
$this->path=$path;
$this->mnt=$mnt;
$this->base_dir=$base_dir;
$this->flags=$flags;

$this->mnt_count=1;
}

//-----

private function realize()
{
if (!is_null($this->symbols)) return;

try
{
if (($buf=@file_get_contents($this->path))===false)
	throw new Exception($this->path.': Cannot read map file');

if (substr($buf,0,14)!=self::MAGIC) throw new Exception('Bad Magic');

$this->min_version=trim(substr($buf,16,12));	// Check min version
if (version_compare($this->min_version,self::VERSION) > 0)
	throw new Exception('Cannot understand this automap.'.
		' Requires at least Automap version '.$this->min_version);

$this->version=trim(substr($buf,30,12));

if (strlen($buf)!=($sz=(int)substr($buf,45,8)))		// Check file size
	throw new Exception('Invalid file size. Should be '.$sz);

if (($buf=unserialize(substr($buf,53)))===false)
	throw new Exception('Cannot unserialize data from map file');

if (!is_array($buf))
	throw new Exception('Map file should contain an array');

if (!array_key_exists('map',$buf))
	throw new Exception('No symbol table');

if (!array_key_exists('options',$buf))
	throw new Exception('No options array');

if (!is_array($this->symbols=$buf['map']))
	throw new Exception('Symbol table should contain an array');

if (!is_array($this->options=$buf['options']))
	throw new Exception('Options should be an array');
}
catch (Exception $e)
	{
	$this->symbols=array(); // No retry later
	throw new Exception($this->path.': Cannot load map - '.$e->getMessage());
	}
}

//---

public function path()
{
self::validate($this->mnt);

return $this->path;
}

//---

public function base_dir()
{
self::validate($this->mnt);

return $this->base_dir;
}

//---

public function mnt()
{
self::validate($this->mnt);

return $this->mnt;
}

//---

public function flags()
{
self::validate($this->mnt);

return $this->flags;
}

//---

public function symbols()
{
self::validate($this->mnt);

$this->realize();
return $this->symbols;
}

//---

public function options()
{
self::validate($this->mnt);

$this->realize();
return $this->options;
}

//---

public function version()
{
self::validate($this->mnt);

$this->realize();
return $this->version;
}

//---

public function min_version()
{
self::validate($this->mnt);

$this->realize();
return $this->min_version;
}

//---

public function option($opt)
{
self::validate($this->mnt);

$this->realize();

return (isset($this->options[$opt]) ? $options[$opt] : null);
}

//---

public function symbol_count()
{
self::validate($this->mnt);

return count($this->symbols());
}

//---

private function call_success_handlers($key,$value)
{
foreach (self::$success_handlers as $callable)
	$callable($key,$this->mnt,$value);
}

//---
/**
* Resolves an Automap symbol.
*
* When the symbol is in a package, the search is recursive and the
* concerned (sub)package(s) are automatically mounted.
*
* @param string $key The key we are resolving
* @return boolean symbol could be resolved (true/false)
*/

private function resolve_key($key)
{
$this->realize();
if (!isset($this->symbols[$key])) return false;

$value=$this->symbols[$key];
$fname=self::get_symbol_from_key($value);

switch($ftype=self::get_type_from_key($value))
	{
	case self::F_EXTENSION:
		if (!dl($fname)) return false;
		$this->call_success_handlers($key,$value);
		break;

	case self::F_SCRIPT:
		$file=$this->base_dir.$fname;
		//echo "Loading script file : $file\n";//TRACE
		{ require($file); }
		$this->call_success_handlers($key,$value);
		break;

	case self::F_PACKAGE:
		// Remove E_NOTICE messages if the test script is a package - workaround
		// to PHP bug #39903 ('__COMPILER_HALT_OFFSET__ already defined')

		$file=$this->base_dir.$fname;
		error_reporting(($errlevel=error_reporting()) & ~E_NOTICE);
		$mnt=require($file);
		error_reporting($errlevel);
		self::instance($mnt)->resolve_key($key);
		break;

	default:
		throw new Exception('<'.$ftype.'>: Unknown file type in map');
	}

return true;
}

//---------
// Display the content of a map

public function show($subfile_to_url_function=null)
{
self::validate($this->mnt);

$this->realize();

if ($html=self::is_web())
	{
	$this->html_show($subfile_to_url_function);
	return;
	}

echo "\n* Global information :\n\n";
echo '	Map version : '.$this->version."\n";
echo '	Min reader version : '.$this->min_version."\n";
echo '	Symbol count : '.$this->symbol_count()."\n";

echo "\n* Options :\n\n";
print_r($this->options);

echo "\n* Symbols :\n\n";

$ktype_len=$kname_len=4;
$fname_len=10;

foreach($this->symbols as $key => $value)
	{
	$ktype=self::get_type_string(self::get_type_from_key($key));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	$ktype_len=max($ktype_len,strlen($ktype)+2);
	$kname_len=max($kname_len,strlen($kname)+2);
	$fname_len=max($fname_len,strlen($fname)+2);
	}

echo str_repeat('-',$ktype_len+$kname_len+$fname_len+8)."\n";
echo '|'.str_pad('Type',$ktype_len,' ',STR_PAD_BOTH);
echo '|'.str_pad('Name',$kname_len,' ',STR_PAD_BOTH);
echo '| T ';
echo '|'.str_pad('Defined in',$fname_len,' ',STR_PAD_BOTH);
echo "|\n";
echo '|'.str_repeat('-',$ktype_len);
echo '|'.str_repeat('-',$kname_len);
echo '|---';
echo '|'.str_repeat('-',$fname_len);
echo "|\n";

foreach($this->symbols as $key => $value)
	{
	$ktype=ucfirst(self::get_type_string(self::get_type_from_key($key)));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	echo '| '.str_pad(ucfirst($ktype),$ktype_len-1,' ',STR_PAD_RIGHT);
	echo '| '.str_pad($kname,$kname_len-1,' ',STR_PAD_RIGHT);
	echo '| '.$ftype.' ';
	echo '| '.str_pad($fname,$fname_len-1,' ',STR_PAD_RIGHT);
	echo "|\n";
	}
}
//---
// The same in HTML

private function html_show($subfile_to_url_function=null)
{
echo "<h2>Global information</h2>";

echo '<table border=0>';
echo '<tr><td>Map version:&nbsp;</td><td>'
	.htmlspecialchars($this->version).'</td></tr>';
echo '<tr><td>Min reader version:&nbsp;</td><td>'
	.htmlspecialchars($this->min_version).'</td></tr>';
echo '<tr><td>Symbol count:&nbsp;</td><td>'
	.$this->symbol_count().'</td></tr>';
echo '</table>';

echo "<h2>Options</h2>";
echo '<pre>'.htmlspecialchars(print_r($this->options,true)).'</pre>';

echo "<h2>Symbols</h2>";

echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 '
	.'cellspacing=0 style="border-collapse: collapse"><tr><th>Type</th>'
	.'<th>Name</th><th>FT</th><th>Defined in</th></tr>';
foreach($this->symbols as $key => $value)
	{
	$ktype=ucfirst(self::get_type_string(self::get_type_from_key($key)));
	$kname=self::get_symbol_from_key($key);

	$ftype=self::get_type_from_key($value);
	$fname=self::get_symbol_from_key($value);

	echo '<tr><td>'.$ktype.'</td><td>'.htmlspecialchars($kname)
		.'</td><td align=center>'.$ftype.'</td><td>';
	if (!is_null($subfile_to_url_function)) 
		echo '<a href="'.call_user_func($subfile_to_url_function,$fname).'">';
	echo htmlspecialchars($fname);
	if (!is_null($subfile_to_url_function)) echo '</a>';
	echo '</td></tr>';
	}
echo '</table>';
}

//---

public function export($path=null)
{
self::validate($this->mnt);

$this->realize();

$file=(is_null($path) ? "STDOUT" : $path);
$fp=fopen($file,'w');
if (!$fp) throw new Exception("$file: Cannot open for writing");

foreach($this->symbols as $key => $value) fwrite($fp,"$key $value\n");

fclose($fp);
}

//---
} // End of class Automap
//===========================================================================

// Registers the automap callback (needs SPL). We support only the SPL
// registration process because defining an _autoload() function is too
// intrusive.

if (!defined('_AUTOMAP_DISABLE_REGISTER'))
	{
	if (!extension_loaded('spl'))
		throw new Exception("Automap requires the SPL extension");

	spl_autoload_register('Automap::autoload_hook');
	}

Automap::init();

} // End of class_exists('Automap')
//===========================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <automap@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The Automap_Creator class
*
* This class creates map files
*
* @copyright Francois Laupretre <automap@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category Automap
* @package Automap
*/
//============================================================================

// <PLAIN_FILE> //---------------
require_once(dirname(__FILE__).'/Automap.php');
// </PLAIN_FILE> //---------------

if (!class_exists('Automap_Creator',false)) 
{
//------------------------------------------

class Automap_Creator
{
const VERSION='1.1.0';
const MIN_VERSION='1.1.0'; // Minimum version of reader to understand the map

//---------

private $symbols=array();
private $options=array();
private $flags;

//---------
// Utilities (taken from PHK_Util)

private static function atomic_write($path,$data)
{
$tmpf=tempnam(dirname($path),'tmp_');

if (file_put_contents($tmpf,$data)!=strlen($data))
	throw new Exception($tmpf.": Cannot write");

// Windows does not support renaming to an existing file (looses atomicity)

if (PHK_Util::is_windows()) @unlink($path);

if (!rename($tmpf,$path))
	{
	unlink($tmpf);
	throw new Exception($path.': Cannot replace file');
	}
}

//---------
// Creates an empty object

public function __construct($flags=0)
{
$this->flags=$flags;
}

//---------

public function add_option($key,$value)
{
$this->options[$key]=$value;
}

//---------

public function set_options($options)
{
if (!is_array($options))
	throw new Exception("set_options: arg should be an array");

$this->options=$options;
}

//---------
// Can be called with type/symbol or with type=null/symbol=key
// Replace symbol even if previously defined

public function add_entry($type,$symbol,$value,$exclude_list=null)
{
$key=is_null($type) ? $symbol : Automap::key($type,$symbol);

if ((!is_null($exclude_list)) && (array_search($key,$exclude_list)!==false))
	return;

$this->symbols[$key]=$value;
}

//---------

public function symbol_count()
{
return count($this->symbols);
}

//---------
// Remove the entries contaning $value

private function cleanup($value)
{
foreach(array_keys($this->symbols,$value) as $key) unset($this->symbols[$key]);
}

//---------

public function get_mapfile($path,$flags=0)
{
$source_mnt=Automap::mount($path,null,null,$flags);
$source_map=Automap::instance($source_mnt);
$this->symbols=$source_map->symbols();
$this->options=$source_map->options();

Automap::umount($source_mnt);
}

//---------

public function serialize()
{
$data=serialize(array('map' => $this->symbols
	, 'options' => $this->options));

return Automap::MAGIC.' M'.str_pad(self::MIN_VERSION,12).' V'
	.str_pad(self::VERSION,12).' FS'.str_pad(strlen($data)+53,8).$data;
}

//---------

public function dump($path)
{
$data=$this->serialize();

self::atomic_write($path,$data);
}

//---------
// Register an extension in current map.
// $file=extension file (basename)

public function register_extension_file($file)
{
echo "INFO: Registering extension file: $file\n";

$value=Automap::key(Automap::F_EXTENSION,$file); // Key & value = same format
$this->cleanup($value);

$extension_list=get_loaded_extensions();

@dl($file);
$a=array_diff(get_loaded_extensions(),$extension_list);
if (($ext_name=array_pop($a))===NULL)
	throw new Exception($file.': Cannot load extension');

$ext=new ReflectionExtension($ext_name);

self::add_entry(Automap::T_EXTENSION,$ext_name,$value);

foreach($ext->getFunctions() as $func)
	self::add_entry(Automap::T_FUNCTION,$func->getName(),$value);

foreach(array_keys($ext->getConstants()) as $constant)
	self::add_entry(Automap::T_CONSTANT,$constant,$value);

foreach($ext->getClasses() as $class)
	{
	self::add_entry(Automap::T_CLASS,$class->getName(),$value);
	}
}

//---------
// Register every extension files in the extension directory
// We do several passes, as there are dependencies between extensions which
// must be loaded in a given order. We stop when a pass cannot load any file.

public function register_extension_dir()
{
$ext_dir=ini_get('extension_dir');
echo "INFO: Scanning directory : $ext_dir\n";

//-- Multiple passes because of possible dependencies
//-- Loop until everything is loaded or we cannot load anything more

$f_to_load=array();
$pattern='\.'.PHP_SHLIB_SUFFIX.'$';
foreach(scandir($ext_dir) as $ext_file)
	{
	if (is_dir($ext_dir.DIRECTORY_SEPARATOR.$ext_file)) continue;
	if (ereg($pattern,$ext_file)!==false) $f_to_load[]=$ext_file;
	}

while(true)
	{
	$f_failed=array();
	foreach($f_to_load as $key => $ext_file)
		{
		try { $this->register_extension_file($ext_file); }
		catch (Exception $e) { $f_failed[]=$ext_file; }
		}
	//-- If we could load everything or if we didn't load anything, break
	if ((count($f_failed)==0)||(count($f_failed)==count($f_to_load))) break;
	$f_to_load=$f_failed;
	}

if (count($f_failed))
	{
	$msg="These extensions were not registered because they could"
		." not be loaded :";
	foreach($f_failed as $file)	$msg.=" $file";
	trigger_error($msg,E_USER_WARNING);
	}
}

//---------
//-- This function extracts the function, class, and constant names out of a
//-- PHP script.

//-- States :

const ST_OUT=1;						// Upper level
const ST_FUNCTION_FOUND=Automap::T_FUNCTION; // Found 'function'. Looking for name
const ST_SKIPPING_BLOCK_NOSTRING=3; // In block, outside of string
const ST_SKIPPING_BLOCK_STRING=4;	// In block, in string
const ST_CLASS_FOUND=Automap::T_CLASS;	// Found 'class'. Looking for name
const ST_DEFINE_FOUND=6;			// Found 'define'. Looking for '('
const ST_DEFINE_2=7;				// Found '('. Looking for constant name
const ST_SKIPPING_TO_EOL=8;			// Got constant. Looking for EOL (';')

const AUTOMAP_COMMENT='// *<Automap>:([^ ]+)(.*)$';

//--

public function register_script($file,$automap_path)
{
//echo "INFO: Registering script $file as $automap_path\n";//TRACE

if (($buf=php_strip_whitespace($file))==='') return;

// Force relative path

$value=Automap::key(Automap::F_SCRIPT
	,trim(str_replace('\\','/',$automap_path),'/\\'));

$this->cleanup($value);

// Register explicit declarations
//Format:
//	<double-slash> <Automap>:declare <type> <value>
//	<double-slash> <Automap>:ignore <type> <value>
//	<double-slash> <Automap>:no-auto-index
//	<double-slash> <Automap>:skip-blocks

$skip_blocks=false;
$exclude_list=array();
$regs=false;
$line_nb=0;

try {
foreach(file($file) as $line)
	{
	$line_nb++;
	$line=trim($line);
	$lin=str_replace('	',' ',$line);	// Replace tabs with spaces
	if (ereg(self::AUTOMAP_COMMENT,$line,$regs)===false) continue;

	if ($regs[1]=='no-auto-index') return;

	if ($regs[1]=='skip-blocks')
		{
		$skip_blocks=true;
		continue;
		}
	$type=strtolower(strtok($regs[2],' '));
	$name=strtok(' ');
	if ($type===false || $name===false) throw new Exception('Needs 2 args');
	$type_letter=Automap::string_to_type($type);
	$key=Automap::key($type_letter,$name);
	switch($regs[1])
		{
		case 'declare': // Add entry, even if set to be 'ignored'.
			$this->add_entry(null,$key,$value);
			break;

		case 'ignore': // Ignore this symbol in autoindex stage.
			$exclude_list[]=$key;
			break;

		default:
			throw new Exception($regs[1].': Invalid Automap command');
		}
	}
} catch (Exception $e)
	{ throw new Exception("$file (line $line_nb): ".$e->getMessage()); }

//-- Auto index

$block_level=0;
$state=self::ST_OUT;

foreach(token_get_all($buf) as $token)
	{
	if (is_string($token))
		{
		$tvalue=$token;
		$tnum=-1;
		$tname='String';
		}
	else
		{
		list($tnum,$tvalue)=$token;
		$tname=token_name($tnum);
		}

	if ($tnum==T_WHITESPACE || $tnum==T_COMMENT) continue;

	//echo "$tname <$tvalue>\n";//TRACE
	switch($state)
		{
		case self::ST_OUT:
			switch($tnum)
				{
				case T_FUNCTION:
					$state=self::ST_FUNCTION_FOUND; break;
				case T_CLASS:
				case T_INTERFACE:
					$state=self::ST_CLASS_FOUND; break;
				case T_STRING:
					if ($tvalue=='define') $state=self::ST_DEFINE_FOUND;
					break;
				// If this flag is set, we skip anything enclosed
				// between {} chars, ignoring any conditional block.
				case -1:
					if ($tvalue=='{' && $skip_blocks)
						{
						$state=self::ST_SKIPPING_BLOCK_NOSTRING;
						$block_level=1;
						}
					break;
				}
			break;

		case self::ST_FUNCTION_FOUND:
		case self::ST_CLASS_FOUND:
			if ($tnum==-1 && $tvalue=='&') break; //-- Function returning ref
			if ($tnum==T_STRING)
				$this->add_entry($state,$tvalue,$value,$exclude_list);
			else trigger_error($file.": Cannot get name (type=$tname;value=$tvalue)"					,E_USER_WARNING);
			$state=self::ST_SKIPPING_BLOCK_NOSTRING;
			$block_level=0;
			break;

		case self::ST_SKIPPING_BLOCK_STRING:
			if ($tnum==-1 && $tvalue=='"')
				$state=self::ST_SKIPPING_BLOCK_NOSTRING;
			break;

		case self::ST_SKIPPING_BLOCK_NOSTRING:
			if ($tnum==-1 || $tnum==T_CURLY_OPEN)
				{
				switch($tvalue)
					{
					case '"':
						$state=self::ST_SKIPPING_BLOCK_STRING;
						break;
					case '{':
						$block_level++;
						//TRACE echo "block_level=$block_level\n";
						break;
					case '}':
						$block_level--;
						if ($block_level==0) $state=self::ST_OUT;
						//TRACE echo "block_level=$block_level\n";
						break;
					}
				}
			break;

		case self::ST_DEFINE_FOUND:
			if ($tnum==-1 && $tvalue=='(') $state=self::ST_DEFINE_2;
			else
				{
				trigger_error("Unrecognized token for constant definition (type=$tnum;value=$tvalue). Waited for '(' string"
					,E_USER_WARNING);
				$state=self::ST_SKIPPING_TO_EOL;
				}
			break;

		case self::ST_DEFINE_2:
			// Accept T_STRING, even if it is incorrect
			if ($tnum==T_CONSTANT_ENCAPSED_STRING || $tnum==T_STRING)
				{
				$schar=$tvalue{0};
				if ($schar=="'" || $schar=='"') $tvalue=trim($tvalue,$schar);
				$this->add_entry(Automap::T_CONSTANT,$tvalue,$value,$exclude_list);
				}
			else trigger_error('Unrecognized token for constant definition '
				."(type=$tname;value=$tvalue). Waited for string constant"
				,E_USER_WARNING);
			$state=self::ST_SKIPPING_TO_EOL;
			break;

		case self::ST_SKIPPING_TO_EOL:
			if ($tnum==-1 && $tvalue==';') $state=self::ST_OUT;
			break;
		}
	}
}

//---------
// Here, we must use 'Automap' and not 'parent' because the package always
// registers its map via Automap::mount()

public function register_package($file,$automap_path)
{
$value=Automap::key(Automap::F_PACKAGE,trim($automap_path,'/\\'));

// We use the same mount point for packages and automaps

$mnt=require($file);
if (Automap::is_mounted($mnt)) // If package has an automap
	{
	foreach(array_keys(Automap::instance($mnt)->symbols()) as $key)
		{
		//var_dump($key);//TRACE
		$this->add_entry(null,$key,$value);
		}
	}
else echo "No automap found in package\n";
}

//---------

public function import($path)
{
$fp=is_null($path) ? STDIN : fopen($path,'r');

while(($line=fgets($fp))!==false)
	{
	if (($line=trim($line))==='') continue;
	list($key,$value)=explode(' ',$line,2);
	$this->add_entry(null,$key,$value);
	}
if (!is_null($path)) fclose($fp);
}

//---------
} // End of class Automap_Creator
//===========================================================================
} // End of class_exists('Automap_Creator')
//===========================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK',false))
{
// <PLAIN_FILE> //---------------
/** Get base class */
require(dirname(__FILE__).'/PHK_Base.php');
// </PLAIN_FILE> //---------------

//=============================================================================
/**
* This class is just an empty extension of the PHK_Base class. This is done
* this way so that PHK_Creator uses the PHP code even if the extension
* is present.
*
* @see PHK_Base
*/

class PHK extends PHK_Base
{

//---------------
// If we get here, the PHP runtime is already loaded.
// But the method has to exist.

public static function need_php_runtime()
{
}

//---------------------------------
} // End of class PHK
//-------------------------
} // End of class_exists('PHK')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Backend',false))
{
//=============================================================================
/**
* This class contains the non-accelerated runtime code. This code must
* never be called by the 'fast path' scenarios.
*
* Each PHK_Backend instance is associated with a 'front-end' PHK instance
* (accelerated or not).
*/

class PHK_Backend
{

private $front; // PHK front-end

//--------------

public function __construct($front)
{
$this->front=$front;
}

//---------------------------------

public function __get($name)
{
return $this->front->$name();
}

//---------------------------------

public function __call($method,$args)
{
return call_user_func_array(array($this->front,$method),$args);
}

//---------------------------------

public function test()
{
// Remove E_NOTICE messages if the test script is a package - workaround
// to PHP bug #39903 ('__COMPILER_HALT_OFFSET__ already defined')

error_reporting(($errlevel=error_reporting()) & ~E_NOTICE);

if (!is_null($test_script=$this->option('test_script')))
	{
	$test_uri=$this->uri($test_script);
	require($test_uri);
	}
elseif (!is_null($phpunit_test_package=$this->option('phpunit_test_package')))
	{
	if (!is_null($phpunit_package=$this->option('phpunit_package')))
		{ $phpunit_package_mnt=require $this->uri($phpunit_package); }
	else $phpunit_package_mnt=null;

	$phpunit_test_package_mnt=require $this->uri($phpunit_test_package);

	_phk_load_phpunit_interface();
	define('PHPUnit_MAIN_METHOD', 'PHPUnit_TextUI_PHK::main');
	PHPUnit_TextUI_PHK::main();

	if (!is_null($phpunit_package_mnt)) PHK_Mgr::umount($phpunit_package_mnt);

	if (!is_null($phpunit_test_package_mnt))
		PHK_Mgr::umount($phpunit_test_package_mnt);
	}
else echo "No unit tests\n";

error_reporting($errlevel);
}

//---------------------------------
// Display the environment
// This function cannot be cached

public function envinfo()
{
$html=PHK_Util::is_web();

//-- Accelerator

self::info_section($html,'PHK Accelerator');

self::start_info_table($html);
if (PHK::accelerator_is_present()) PHK::accel_techinfo();
else self::show_info_line($html,'PHK Accelerator','No');

self::info_section($html,'Automap Accelerator');

self::start_info_table($html);
if (Automap::accelerator_is_present()) Automap::accel_techinfo();
else self::show_info_line($html,'Automap Accelerator','No');

self::info_section($html,'Cache');

self::show_info_line($html,'Cache system used',PHK_Cache::cache_name());
self::end_info_table($html);

//-- Environment

self::info_section($html,'Environment');

self::start_info_table($html);
self::show_info_line($html,'PHP SAPI',php_sapi_name());
self::show_info_line($html,'Mount point',$this->mnt);

//-- Mount options

$string='';
$class=new ReflectionClass('PHK');
foreach($class->getConstants() as $name => $value)
	{
	if ((strlen($name)>1) && (substr($name,0,2)=='F_')
		&& ($this->flags & $value)) $string .= ','.strtolower(substr($name,2));
	}
unset($class);
$string=trim($string,',');
self::show_info_line($html,'Current mount options'
	,$string=='' ? '<none>' : $string);
self::end_info_table($html);
}

//---------------------------------
// Display the file tree

public function showfiles()
{
$this->proxy()->showfiles();
}

//---------------------------------
// Display Automap map content or <empty> message

public function showmap($subfile_to_url_function=null)
{
if ($this->map_defined())
	Automap::instance($this->mnt)->show($subfile_to_url_function);
else echo "Automap not defined\n";
}

//-----
/**
* <Info> Displays information about the plugin
*
* If the plugin object defines a method name '_webinfo', this method is called
* with the $html parameter.
*
* If the plugin is not defined, just displays a small informative message
*
* @param boolean $html Whether to display in html or raw text
* @return void
*/

private function plugin_info($html)
{
self::info_section($html,'Plugin');

if (is_null($class=$this->option('plugin_class')))
	{
	echo ($html ? '<p>' : '')."Not defined\n";
	return;
	}

if ($this->is_callable_plugin_method('_webinfo'))
	{
	$this->call_plugin_method('_webinfo',$html);
	echo $html ? '<p>' : "\n";
	}

self::start_info_table($html);

self::show_info_line($html,'Class',$class);

$rc=new ReflectionClass($class);

foreach ($rc->getMethods() as $method)
	{
	if ((!$method->isPublic())||($method->isStatic())
		||($method->isConstructor())||($method->isDestructor())
		||($method->getName()==='_webinfo')) continue;
	$name=$method->getName();
	$a=array();
	foreach($method->getParameters() as $param)
		{
		$s='$'.$param->getName();
		if ($param->isPassedByReference()) $s='&'.$s;
		if ($param->isArray()) $s = 'Array '.$s;
		if ($param->isOptional())
			{
			if ($param->isDefaultValueAvailable())
				$s .= ' = '.var_export($param->getDefaultValue(),true);
			$s = '['.$s.']';
			}
		$a[]=$s;
		}
	self::show_info_line($html,'Method',$name.' ( '.implode(', ',$a).' )');
	}
		
self::end_info_table($html);
}

//-----
/**
* <Info> Displays an option and its value
*
* An URL can be set in an option. Syntax: 'text to display <url>'
* In HTML mode, only the text is displayed and an hyperlink is generated
* In text mode, it is displayed as-is.
* URLs starting with 'http://' are automatically recognized

* @param boolean $html Whether to display in html or raw text
* @param string $opt Option name
* @return void
*/

private function show_option($html,$opt,$default=null)
{
$str1=ucfirst(str_replace('_',' ',$opt));

$url=null;
$newwin=true;
if (is_null($val=$this->option($opt))) $val=$default;

if ($html && ereg('^(.*)[ 	]<([^ 	]+)>.*$',$val,$regs))
	{	// If the value contains an URL
	$str2=trim($regs[1]);
	$url=$regs[2];
	if ($str2=='') $str2=$url;
	}
else
	{
	$str2=$val;
	$vlen=strlen($val);
	if (($vlen>=7)&&(substr($val,0,7)=='http://')) $url=$val;
	elseif (($vlen>=1) && ($val{0}=='/') && file_exists($this->uri($val)))
		{
		// Warning: We build an HTTP URL going to PHK_Webinfo, not a
		// stream wrapper URI.
		$url=PHK::subpath_url('/view/'.trim($val,'/'));
		$newwin=false;
		}
	}

self::show_info_line($html,$str1,$str2,$url,$newwin);
}

//-----
/**
* <Info> Start a new information section
*
* @param boolean $html Whether to display in html or raw text
* @param string $title The title to display
* @return void
*/

public static function info_section($html,$title)
{
echo $html ? '<h2>'.htmlspecialchars($title).'</h2>'
	: "\n==== ".str_pad($title.' ',70,'='). "\n\n";
}

//-----
/**
* <Info> Displays an information line
*
* In html mode, the information is displayed in a table. This table must
* have been opened by a previous call to PHK::start_info_table().
*
* Note: The URLs starting with a '/' char are internal (generated by PHK_Webinfo
* ) and, so, are displayed in html mode only.
*
* @param boolean $html Whether to display in html or raw text
* @param string $string The left side (without ':')
* @param string|boolean $value The value to display. If boolean, displays 'Yes'
*    or 'No'.
* @param string|null $url An URL to associate with this value. Null if no URL.
* @param boolean $newwin Used in html mode only. Whether the URL link opens
*    a new window when clicked.
* @return void
*
* @see start_info_table()
* @see end_info_table()
*/

public static function show_info_line($html,$string,$value,$url=null
	,$newwin=true)
{
if (is_null($value)) $value='<>';
if (is_bool($value)) $value=PHK_Util::bool2str($value);

if ($html)
	{
	echo '<tr><td>'.htmlspecialchars($string).':&nbsp;</td><td>';
	if ($url)
		{
		echo '<a href="'.$url.'"';
		if ($newwin) echo ' target="_blank"';
		echo '>';
		}
	echo htmlspecialchars($value);
	if ($url) echo '</a>';
	echo '</td></tr>';
	}
else
	{
	echo "$string: $value";
	if ((!is_null($url)) && ($url{0}!='/')) echo " <$url>";
	echo "\n";
	}
}

//-----
/**
* <Info> Starts an HTML table
*
* In text mode, does nothing.
*
* This function is public because it can be called from the plugin's _webinfo
* method.
*
* @param boolean $html Whether to display in html or raw text
* @return void
*/

public static function start_info_table($html)
{
echo $html ? '<table border=0>' : '';
}

//-----

public static function end_info_table($html)
{
echo $html ? '</table>' : '';
}

//-----
// Display non technical information
// Webinfo default welcome page

public function info()
{
$html=PHK_Util::is_web();

if ($html && (!is_null($info_script=$this->option('info_script'))))
	{ require($this->uri($info_script)); }
else
	{
	self::start_info_table($html);
	$this->show_option($html,'name');
	$this->show_option($html,'summary');
	$this->show_option($html,'version');
	$this->show_option($html,'release');
	$this->show_option($html,'distribution');
	$this->show_option($html,'license');
	$this->show_option($html,'copyright');
	$this->show_option($html,'url');
	$this->show_option($html,'author');
	$this->show_option($html,'packager');
	$this->show_option($html,'requires');

	$req=implode(' ',PHK_Util::mk_array($this->option('required_extensions')));
	if ($req=='') $req='<none>';
	self::show_info_line($html,'Required extensions',$req);

	self::end_info_table($html);
	}
}

//-----

public function techinfo()
{
$html=PHK_Util::is_web();

self::info_section($html,'Package');

self::start_info_table($html);
$this->show_option($html,'name');
$this->show_option($html,'summary');
$this->show_option($html,'version');
$this->show_option($html,'release');
$this->show_option($html,'distribution');
$this->show_option($html,'license');
$this->show_option($html,'copyright');
$this->show_option($html,'url');
$this->show_option($html,'author');
$this->show_option($html,'packager');
$this->show_option($html,'requires');
self::show_info_line($html,'Signed',$this->proxy()->signed());
self::show_info_line($html,'Automap defined',$this->map_defined());
self::show_info_line($html,'File path',$this->path);
self::show_info_line($html,'File size',filesize($this->path));

$req=implode(', ',PHK_Util::mk_array($this->option('required_extensions')));
if ($req=='') $req='<none>';
self::show_info_line($html,'Required extensions',$req);

self::show_info_line($html,'Build date'
	,PHK_Util::timestring($this->build_info('build_timestamp')));
$this->show_option($html,'icon');
$this->show_option($html,'crc_check',false);
$this->show_option($html,'help_prefix');
$this->show_option($html,'license_prefix');
$this->show_option($html,'auto_umount',false);
$this->show_option($html,'no_cache',false);
$this->show_option($html,'no_opcode_cache',false);
$this->show_option($html,'prolog_code_creator',false);
$this->show_option($html,'plain_prolog',false);
self::show_info_line($html,'File count',count($this->path_list()));
self::end_info_table($html);

$this->plugin_info($html);

self::info_section($html,'Package scripts');

self::start_info_table($html);
$this->show_option($html,'cli_run_script');
$this->show_option($html,'web_run_script');
$this->show_option($html,'lib_run_script');
$this->show_option($html,'info_script');
$this->show_option($html,'mount_script');
$this->show_option($html,'umount_script');
$this->show_option($html,'test_script');
$this->show_option($html,'phpunit_package');
$this->show_option($html,'phpunit_test_package');

self::end_info_table($html);

self::info_section($html,'Module versions');

self::start_info_table($html);
self::show_info_line($html,'PHK_Creator',$this->build_info('PHK_Creator_version'));
self::show_info_line($html,'PHK min version',$this->build_info('PHK_min_version'));
self::show_info_line($html,'Automap_Creator class',$this->build_info('Automap_creator_version'));
self::show_info_line($html,'Automap min version',$this->build_info('Automap_min_version'));
self::show_info_line($html,'PHK_PSF class',$this->build_info('PHK_PSF_version'));
self::end_info_table($html);

self::info_section($html,'Sub-packages');

ob_start();
$this->proxy()->display_packages();
$data=ob_get_clean();
if ($data==='')	echo ($html ? '<p>' : '')."None\n";
else echo $data;

self::info_section($html,'Web direct access');

self::start_info_table($html);
$list=PHK_Util::mk_array($this->option('web_access'));
self::show_info_line($html,'State',count($list) ? 'Enabled' : 'Disabled');
$this->show_option($html,'web_main_redirect',false);
foreach($list as $path) self::show_info_line($html,'Path',$path);
self::end_info_table($html);

//-- Options

self::info_section($html,'Package options');

$a=$this->options();
$data=(is_null($a) ? '<>' : print_r($a,true));
echo ($html ? ('<pre>'.htmlspecialchars($data).'</pre>') : $data);

//-- Sections

self::info_section($html,'Sections');
$this->proxy()->stree()->display(false);
}

//-----
/**
* Returns a subfile content for a multi-type metafile
*
* File name : <prefix>.<type> - Type is 'txt' or 'htm'.
*
* A text file can be transformed to html, but the opposite is not possible.
*
* Type is determined by the SAPI type (CLI => txt, else => htm).
*
* @param string $prefix Prefix to search for
* @return string|null The requested content or null if not found
*/

public function auto_file($prefix)
{
$html=PHK_Util::is_web();
$txt_suffixes=array('.txt','');
$suffixes=($html ? array('.htm','.html') : $txt_suffixes);

$base_path=$this->uri($prefix);
foreach($suffixes as $suffix)
	{
	if (is_readable($base_path.$suffix))
		{
		return PHK_Util::readfile($base_path.$suffix);
		break;
		}
	}

// If html requested and we only have a txt file, tranform it to html

if ($html)
	{
	foreach ($txt_suffixes as $suffix)
		if (is_readable($base_path.$suffix))	
			return '<pre>'.htmlspecialchars(PHK_Util::readfile($base_path.$suffix))
				.'</pre>';
	}

return null;
}

//-----
/**
* Returns a multi-type content from an option name
*
* Option ($name.'_prefix') gives the prefix to send to auto_file()
*
* @param string $name Option prefix
* @return string Requested content or an informative error string.
*/

public function auto_option($name)
{
$data=null;

$prefix=$this->option($name.'_prefix');

if (!is_null($prefix)) $data=$this->auto_file($prefix);

if (is_null($data))
	{
	$data='<No '.$name.' file>'."\n";
	if (PHK_Util::is_web()) $data=htmlspecialchars($data);
	}

return $data;
}

//-----
/**
* Checks if the plugin class is defined and contains a given method
*
* @param string $method
* @return boolean
*/

public function is_callable_plugin_method($method)
{
return (is_null($this->plugin)) ? false
	: is_callable(array($this->plugin,$method));
}

//-----
/**
* Calls a given method in the plugin object
*
* @param string method
* @return * the method's return value
* @throws Exception if the plugin or the method does not exist
*/

public function call_plugin_method($method)
{
if (!$this->is_callable_plugin_method($method))
	throw new Exception($method.': Undefined plugin method');

$args=func_get_args();
array_shift($args);

return call_user_func_array(array($this->plugin,$method),$args);
}

//-----

public function path_list()
{
return unserialize(file_get_contents($this->command_uri(__FUNCTION__)));
}

//-----

public function section_list()
{
return unserialize(file_get_contents($this->command_uri(__FUNCTION)));
}

//---------------------------------
// Workaround for PHP bug/issue when trying to use PATH_INFO when PHP is
// run as an Apache CGI executable. In this mode, an url in the form of
// 'http://.../.../file.php/args' does not go to file.php but returns
// 'No input file specified'. There, we have to pass args the 'usual'
// way (via $_REQUEST).
// Drawback: as the URL now contains a '?' char, most browsers refuse to cache
// it, even with the appropriate header fields, causing some useless traffic
// when navigating in the tabs and flicking on the screen. So, the preferred
// method is via PATH_INFO.
// Allows a PHK package to become fully compatible with CGI mode by computing
// every relative URLs through this method.

public static function subpath_url($path)
{
if ($path{0}!='/') $path=PHK::get_subpath().'/'.$path; //-- Make path absolute
$path=ereg_replace('//+','/',$path);

return PHK_Util::http_base_url().((php_sapi_name()=='cgi')
	? ('?_PHK_path='.urlencode($path)) : $path);
}

//-----

private static function cmd_usage($msg=null)
{
if (!is_null($msg)) echo "** ERROR: $msg\n";

echo "\nAvailable commands:\n\n";
echo "	- @help             Display package help\n";
echo "	- @license          Display license\n";
echo "	- @get <path>       Display a subfile content\n";
echo "	- @showmap          Display automap, if present\n";
echo "	- @showfiles        List subfiles\n";
echo "	- @option <name>    Display a package option\n";
echo "	- @set_interp <string>  Set the first line of the PHK to '#!<string>'\n";
echo "	- @info             Display information about the PHK file\n";
echo "	- @techinfo         Display technical information\n";
echo "	- @dump <directory> Extracts the files\n";
echo "	- @test [switches] [UnitTest]  Run the package's unit tests\n";

if (!is_null($msg)) exit(1);
}

//-----

public function builtin_prolog($file)
{
$retcode=0;

try
{
$this->proxy()->crc_check();

$command=PHK_Util::substr($_SERVER['argv'][1],1);
array_shift($_SERVER['argv']);
$param=isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : null;

switch($command)
	{
	case 'get':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");
		$uri=$this->uri($param);
		if (is_file($uri)) readfile($uri);
		else throw new Exception("$param: file not found");
		break;

	case 'test':
		$this->test();
		break;

	case 'showmap':
	case 'info':
	case 'techinfo':
	case 'showfiles':
		$this->$command();
		break;

	case 'option':
		$res=$this->$command($param);
		if (is_null($res)) throw new Exception('Option not set');
		echo "$res\n";
		break;

	case 'set_interp':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");

		//-- This is the only place in the runtime code where we write something
		//-- into an existing PHK archive.

		if (file_put_contents($file
			,PHK_Proxy::set_buffer_interp($file,$param))===false)
			throw new Exception('Cannot write file');
		break;

	case 'license':
	case 'help':
		echo $this->auto_option($command);
		break;

	case 'dump':
		if (is_null($param))
			self::cmd_usage($command.": needs argument");
		$this->proxy()->ftree()->dump($param);
		break;

	case '':
		self::cmd_usage();
		break;

	default:
		self::cmd_usage($command.': Unknown command');
	}

PHK_Util::display_slow_path();
}
catch (Exception $e)
	{
	if (getenv('PHK_DEBUG')!==false) throw $e;
	echo "** ERROR: Command failed ($command) - ".$e->getMessage()."\n";
	$retcode=1;
	}

return $retcode;
}

//---------------------------------
} // End of class PHK_Backend
//-------------------------
} // End of class_exists('PHK_Backend')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Base',false))
{
//=============================================================================
/**
* A mounted PHK archive file
*
* This file contains the front-end class for PHK object. This class gets its
* data from the stream wrapper, which retrieves them from the cache or from
* PHK_Proxy. This class is also used as base class for PHK_Creator instances.
*
* This class does never access the package file directly.
*
* Note: When dealing with a sub-package, the mounted archive file is a 'phk://'
* virtual file contained in a higher-level PHK archive (which, itself, can be
* virtual). There is no limit to the recursion level of sub-packages.
*
* Runtime code -> 100% read-only
*
* PHK objects are created and destructed from the PHK manager (PHK_Mgr class).
*
* You get the PHK object instance by calling PHK_Mgr::instance with a mount
* point. This mount point is generally returned either by an include,
* when including a package, or by PHK_Mgr::uri_to_mnt().
*
* @see PHK_Mgr
* @see PHK_Proxy
* @package PHK
*/

abstract class PHK_Base
{
//========== Class constants ===============

/** Class version */

const VERSION='1.4.0';

//-----
// Mount flags
/* The values defined here must be the same as in the accelerator extension */

/** Mount flag - If set, force a CRC check when creating the PHK instance */

const F_CRC_CHECK=4;

/** Mount flag - If set, don't call mount/umount scripts */

const F_NO_MOUNT_SCRIPT=8;

/** Mount flag - If set, create a PHK_Creator object, instead of a PHK object */

const F_CREATOR=16;

//========== Class properties ===============

/** @var string		Current mount point */

protected $mnt;

/** @var string		Parent mount point (for a subpackage) or null */

protected $parent_mnt;

/** @var array		Package options */

protected $options=null;	// Array

/** @var array		Build-time information */

protected $build_info=null;

/** @var integer	Mount flags */

protected $flags;

/** @var integer	Package path (URI when subpackage) */

protected $path;

/** @var Object|null	Plugin object, if defined */

protected $plugin=null;

/** @var boolean|null Allows to temporarily enable/disable caching */

protected $caching=null;

/** @var int The modification time for every subfiles */

protected $mtime;

/** @var PHK_Backend The slow backend object (created only when needed) */

protected $backend=null;

/** @var array	File extension to mime type (constant)
*
* Would be cleaner if PHP class constants could contain arrays */

protected static $mime_table=array(
	''     => 'text/plain',
	'gif'  => 'image/gif',
	'jpeg' => 'image/jpeg',
	'jpg'  => 'image/jpeg',
	'png'  => 'image/png',
	'psd'  => 'image/psd',
	'bmp'  => 'image/bmp',
	'tif'  => 'image/tiff',
	'tiff' => 'image/tiff',
	'iff'  => 'image/iff',
	'wbmp' => 'image/vnd.wap.wbmp',
	'ico'  => 'image/x-icon',
	'xbm'  => 'image/xbm',
	'txt'  => 'text/plain',
	'htm'  => 'text/html',
	'html' => 'text/html',
	'css'  => 'text/css',
	'php'  => 'application/x-httpd-php',
	'phk'  => 'application/x-httpd-php',
	'pdf'  => 'application/pdf',
	'js'   => 'application/x-javascript',
	'swf'  => 'application/x-shockwave-flash',
	'xml'  => 'application/xml',
	'xsl'  => 'application/xml',
	'xslt' => 'application/xslt+xml',
	'mp3'  => 'audio/mpeg',
	'ram'  => 'audio/x-pn-realaudio',
	'svg'  => 'image/svg+xml'
	);

//========== Class methods ===============

//-----

public function __construct($parent_mnt,$mnt,$path,$flags,$mtime)
{
$this->parent_mnt=$parent_mnt;
$this->mnt=$mnt;
$this->path=$path;
$this->flags=$flags;
$this->mtime=$mtime;
}

//-----

public function init($options,$build_info)
{
try
{
$this->options=$options;
$this->build_info=$build_info;

$this->supports_php_version();

if ($this->option('crc_check') || ($this->flags & self::F_CRC_CHECK))
	$this->crc_check();

// As required extensions are added to the enclosing package when a subpackage
// is inserted, we don't have to check subpackages for required extensions.

if (is_null($this->parent_mnt))
	{
	if (!is_null($extensions=$this->option('required_extensions')))
		PHK_Util::load_extensions($extensions);
	}

if ($this->map_defined())
	{
	Automap::mount($this->automap_uri(),$this->base_uri(),$this->mnt);
	}

//-- Call the mount script - if the mount script wants to refuse the mount,
//-- it throws an exception.

if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT)
	&& (!is_null($mpath=$this->option('mount_script'))))
		{ require $this->uri($mpath); }

//-- Create the plugin_object

if (!is_null($c=$this->option('plugin_class')))
	$this->plugin=new $c($this->mnt);
}
catch (Exception $e)
	{
	throw new Exception('While initializing PHK instance - '.$e->getMessage());
	}
}

//---------

public function map_defined()
{
if ($this->flags & PHK::F_CREATOR) return false;

return $this->build_info('map_defined');
}

//---------

public function mtime()
{
return $this->mtime;
}

//---------

public function set_cache($toggle)
{
$this->caching=$toggle;
}

//---------
/**
* Check if a given path contains a PHK package
*
* @param string $path	path to check (can be virtual)
* @return boolean
*/

public static function file_is_package($path)
{
return PHK_Proxy::file_is_package($path);
}

//---------
/**
* Check if a data buffer contains a PHK package
*
* @param string $data	data buffer to check
* @return boolean
*/

public static function data_is_package($data)
{
return PHK_Proxy::data_is_package($data);
}

//-----

public function cache_enabled($command,$params,$path)
{
if ($this->flags & PHK::F_CREATOR) return false;

if ($this->option('no_cache')===true) return false;

if (!PHK_Cache::cache_present()) return false;

if (!is_null($this->caching)) return $this->caching;

return true;
}

//-----
// Umount this entry.
// We dont use __destruct because :
//	1. We don't want this to be called on script shutdown
//	2. Exceptions cannot be caught when sent from a destructor.

public function umount()
{
//-- Destroy the plugin

if (!is_null($this->plugin)) unset($this->plugin);

//-- Call the umount script

if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT))	// Call the umount script
	{
	if (!is_null($upath=$this->option('umount_script')))
		{ require($this->uri($upath)); }
	}

//-- Unload the automap

if ($this->map_defined()) Automap::umount($this->mnt);
}

//-----

public function mnt()
{
return $this->mnt;
}

//-----

public function flags()
{
return $this->flags;
}

//-----

public function path()
{
return $this->path;
}

//-----

public function uri($path)
{
return PHK_Mgr::uri($this->mnt,$path);
}

//-----

public function section_uri($section)
{
return PHK_Mgr::section_uri($this->mnt,$section);
}

//-----

public function command_uri($command)
{
return PHK_Mgr::command_uri($this->mnt,$command);
}

//-----

public function base_uri()
{
return PHK_Mgr::base_uri($this->mnt);
}

//-----
/**
* Returns the URI of the Automap
*
* @return string
*/

public function automap_uri()
{
return PHK_Mgr::automap_uri($this->mnt);
}

//-----
/**
* Returns an option
*
* If the option is not set, returns null.
*
* The 'OPTIONS' section is mandatory in a package.
*
* @param string $key The option name
* @return any|null Option value or null if the requested option is not set
*/


public function option($key)
{
return (isset($this->options[$key]) ? $this->options[$key] : null);
}

//-----
/**
* Returns the whole options array
*
* The 'OPTIONS' section is mandatory in a package.
*
* @return array
*/


public function options()
{
return $this->options;
}

//-----

public function parent_mnt()
{
return $this->parent_mnt;
}

//---------------------------------

public function web_access_allowed($path)
{
$plen=strlen($path);

foreach(PHK_Util::mk_array($this->option('web_access')) as $apath)
	{
	if ($apath=='/') return true;
	$alen=strlen($apath);
	if (($plen >= $alen) && (substr($path,0,$alen)==$apath)
		&& (($alen==$plen)||($path{$alen}=='/')))
		return true;
	}

return false;
}

//---------------------------------
// Transfer control to main script (web mode)
// Two methods: redirect or transparently execute main script.

private function goto_main($web_run_script)
{
if ($this->option('web_main_redirect'))
	{
	PHK_Util::http_301_redirect($web_run_script);
	}
else return 'require(\''.$this->uri($web_run_script).'\');';
}

//---------------------------------
// Returns the code to display or execute a subfile from the calling code. We
// cannot directly include the subfile from this function because the variable
// scope must be the calling one.
// Use as : eval($phk->web_tunnel([$path [,webinfo mode]]));
// This function is supposed to transfer control in as transparent a manner as
// possible.
// If the given path is a directory, tries to find an index.[htm|html|php] file.
// This function does not support subpaths in PHK subfiles.

public function web_tunnel($path=null,$webinfo=false)
{
if (is_null($path)) $path=PHK::get_subpath();
$last_slash=(substr($path,-1)=='/');
if ($path!='/') $path=rtrim($path,'/');
$web_run_script=$this->option('web_run_script');
$mnt=$this->mnt();

if ($path=='')
	{
	if (!is_null($web_run_script)) return $this->goto_main($web_run_script); 
	else PHK_Util::http_301_redirect('/'); // Redirect to the virtual root dir
	}

// If a package use a path as both file and http paths, we can receive
// a PHK URI. Handle this. Ugly: to be suppressed when PHP makes
// current directory compatible with stream wrappers.
// We check for one or two '/' between 'phk:' and $mnt because Apache removes
// the 2nd '/'.
// Suppressed in v 1.4.0: don't know if still useful ?

//$path=str_replace('phk:/'.$mnt.'/','',$path);
//$path=str_replace('phk://'.$mnt.'/','',$path);

// Access enabled ? If not in the enabled paths, go to the main script
// Allows to support a mod_rewrite-like feature where a single entry point
// gets every request.

if ((!$webinfo) && (!$this->web_access_allowed($path))
	&& ($path!==$web_run_script))
	{
	if (!is_null($web_run_script)) return $this->goto_main($web_run_script); 
	else PHK_Util::http_403_fail();	// Returns 'Forbidden'
	}

// File exists ?

$uri=$this->uri($path);

if (($a=@stat($uri))===false) PHK_Util::http_404_fail();

if (($a['mode'] & 0170000) == 040000)	// Special case for directory
	{
	$file_path=null;
	if ($last_slash)	// Search a DirectoryIndex
		{
		foreach(array('index.htm', 'index.html', 'index.php') as $fname)
			{
			if (is_file($this->uri($path.'/'.$fname)))
				{
				$file_path=$path.'/'.$fname;
				break;
				}
			}
		if (is_null($file_path)) PHK_Util::http_404_fail(); // No Directory Index
		}
	else PHK_Util::http_301_redirect($path.'/');
	}
else $file_path=$path;

// Now, we return the string which will be used by the calling environment
// to execute the file if it is a PHP source, or to output its content
// with the correct mime type. Execution is disabled in webinfo mode

if ((!$webinfo) && ($this->is_php_source_path($file_path)))
	{
	return "require('".$this->uri($file_path)."');";
	}
else
	{
	return "PHK_Mgr::instance('".$this->mnt."')->mime_header('$file_path');\n"
		."readfile('".$this->uri($file_path)."');";
	}
}

//---------------------------------
/**
* Sends a mime header corresponding to a path
*
* Actually, we use only the file suffix (the path can correspond to an existing
*	node or not).
*
* If the suffix does not correspond to anything we know, nothing is sent
*	(defaults to text/html on Apache, don't know if it can change on another
*	SAPI).
*
* @param string $path
* @return void
*/

public function mime_header($path)
{
if (!is_null($type=$this->mime_type($path))) header('Content-type: '.$type);
}

//---------
/**
* Returns the mime-type corresponding to a given path, or null if the
* suffix does not correspond to anything we know
*
* Searches :
*
* 1. The 'mime-types' option
* 2. The built-in mime table
* 3. If the suffix contains 'php', sets the type to 'application/x-httpd-php'
*
* @param string $path
* @return string|null The mime type or null if file suffix is unknown
*/

public function mime_type($path)
{
$ext=PHK_Util::file_suffix($path);

if ((!is_null($mtab=$this->option('mime_types'))) && isset($mtab[$ext]))
	return $mtab[$ext];

if (isset(self::$mime_table[$ext])) return self::$mime_table[$ext];

if (strpos($ext,'php')!==false)	return 'application/x-httpd-php';

return null;
}

//---------
/**
* Should we consider this path as a PHP source file ?
*
* In order to be identified as PHP source, a path must be associated with Mime
* type 'application/x-httpd-php'.
*
* @param string $path
* @return boolean
*/

public function is_php_source_path($path)
{
return ($this->mime_type($path)==='application/x-httpd-php');
}

//---------

public function proxy()
{
return PHK_Mgr::proxy($this->mnt);
}

//---------
/**
* Checks the CRC of the PHK archive file
*
* Generates an exception if the check fails
*
* @return void
* @throws Exception
*/

public function crc_check()
{
$this->proxy()->crc_check();
}

//---------

public function supports_php_version()
{
if ((!is_null($minv=$this->option('min_php_version')))
	&& (version_compare(PHP_VERSION,$minv) < 0))
		throw new Exception("PHP minimum supported version: $minv (current is ".PHP_VERSION.")");

if ((!is_null($maxv=$this->option('max_php_version')))
	&& (version_compare(PHP_VERSION,$maxv) > 0))
		throw new Exception("PHP maximum supported version: $maxv (current is ".PHP_VERSION.")");
}

//---------------------------------
/**
* Returns the associated plugin object if defined, or null if not
*
* @return plugin_object|null
*/

public function plugin()
{
return $this->plugin;
}

//-----
/**
* Is the PHK accelerator in use or not ?
*
* @return boolean
*/

public static function accelerator_is_present()
{
return false;
}

//-----
/**
* Returns a build-time information field or the whole array
*
* Unlike options, an unknown key throws an error
*
* @param string|null $name Field name
* @return array|string|null The field's content or null if it does not exist
*/

public function build_info($name=null)
{
if (is_null($name)) return $this->build_info;

if (!isset($this->build_info[$name]))
	throw new Exception($name.': unknown build info');

return $this->build_info[$name];
}

//---------------------------------

public static function subpath_url($path)
{
return PHK_Backend::subpath_url($path);
}

//---------------------------------
// Get the sub-path from an URL. Because of the problems with CGI mode, we
// have to support 2 syntaxes :
// http://<site>/.../<phk_file><path>
// http://<site>/.../<phk_file>?_PHK_path=<path>

public static function get_subpath()
{
$path='';

if (isset($_REQUEST['_PHK_path'])) $path=urldecode($_REQUEST['_PHK_path']);
else
	{
	$path=isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : '';
	if ($path=='' && isset($_SERVER['ORIG_PATH_INFO']))
		$path=$_SERVER['ORIG_PATH_INFO'];
	}

if (($path!='') && ($path{0}!='/')) $path='/'.$path;

return $path;
}

//----
// Undocumented

private function backend()
{
if (is_null($this->backend)) $this->backend=new PHK_Backend($this);

return $this->backend;
}

//--------------
// Forward unknown method calls to the slow backend

public function __call($method,$args)
{
return PHK_Util::call_method($this->backend($this),$method,$args);
}

//---------

public static function prolog($file,&$cmd,&$ret)
{
# Do we run in CLI mode ?

if ($cli=(!PHK_Util::is_web()))
	{
	ini_set('display_errors',true);
	ini_set('memory_limit','1024M'); // Only in CLI mode
	}

PHK_Mgr::php_version_check();	//-- Check PHP version - if unsupported, no return

//-----
// Mount the PHK file (or get the mount point if previously mounted)

try {
	$mnt=PHK_Mgr::mount($file);
	$phk=PHK_Mgr::instance($mnt);
	}
catch (Exception $e)
	{		
	if (getenv('PHK_DEBUG')!==false) throw $e;
	echo '** Fatal error: Cannot mount PHK file - '.$e->getMessage()."\n";
	exit(1);
	}
//PHK_Util::trace("Prolog mounted $file on $mnt");//TRACE

//-----
// Am I a main script ?
// When there are symbolic links in the path, get_included_files() returns
// 2 paths, the logical one first, and then the real one.

$tmp=get_included_files();
$main=(($tmp[0]===$file) || (realpath($tmp[0]) === $file));

if (!$main)	// Not main script
	{
	if (!is_null($script=$phk->option('lib_run_script')))
		{ require($phk->uri($script)); }

	if ($phk->option('auto_umount'))
		{
		PHK_Mgr::umount($mnt);
		$ret='';
		}
	else $ret=$mnt;
	return;
	}

//-----------------
// Main script - Dispatch

if ($cli)
	{
	if (($_SERVER['argc']>1) && ($_SERVER['argv'][1]!='')
		&& ($_SERVER['argv'][1]{0}=='@'))
		{
		$ret=$phk->builtin_prolog($file);
		return;
		}

	// Not a command: call cli_run

	if (!is_null($run_path=$phk->option('cli_run_script')))
		{
		$cmd="require('".$phk->uri($run_path)."');";
		}
	return;
	}
else	// HTTP mode
	{
	if (file_exists($file.'.webinfo'))	// Slow path
		{
		PHK_Util::run_webinfo($phk);
		}
	else
		{
		$cmd=$phk->web_tunnel();
		}
	}
}

//---------------------------------
} // End of class PHK_Base
//-------------------------
} // End of class_exists('PHK_Base')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK cache gateway
*
* The cache key is based on the mount point because it uniquely defines the
* PHK file on the current host.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Cache',false))
{
// <PLAIN_FILE> //---------------
require(dirname(__FILE__).'/PHK.php');
// </PLAIN_FILE> //---------------

//=============================================================================

class PHK_Cache	// Static only
{
/** Class version */

const VERSION='1.1.0';

const TTL=3600;	// Arbitrary TTL of one hour

//-- Global static properties

private static $caches=array("apc","xcache","eaccelerator");

private static $cache_name;	// Info

/** @var Object|false|null	The cache system we are using for PHK instances
*
* False means 'no cache'.
* null until set by set_cache_object().
*/

private static $cache=null;

private static $cache_maxsize=524288;	// 512 Kb

//-----

public static function cache_id($prefix,$key)
{
return 'phk.'.$prefix.'.'.$key;
}

//---------------------------------
// If the cache's init() method returns an exception, don't use it.

private static function set_cache_object()
{
if (is_null(self::$cache))
	{
	self::$cache=false;
	self::$cache_name='none';
	foreach(self::$caches as $c)
		{
		if (!extension_loaded($c)) continue;
		
		$class='PHK_Cache_'.$c;
		$obj=new $class;
		try { $status=$obj->init(); }
		catch (Exception $e) { $status=false; }
		if ($status)
			{
			self::$cache=$obj;
			self::$cache_name=$c;
			break;
			}
		unset($obj);
		}
	// echo "Cache system used : ".self::$cache_name."\n";//TRACE
	}
}

//---------------------------------

public static function set_cache_maxsize($size)
{
$this->cache_maxsize=$size;
}

//---------------------------------

public static function cache_name()
{
if (is_null(self::$cache)) self::set_cache_object();

return self::$cache_name;
}

//---------------------------------

public static function cache_present()
{
if (is_null(self::$cache)) self::set_cache_object();

return (self::$cache!==false);
}
//---------------------------------
/**
* Gets an element from cache
*
* Fast path
*
* @param string $id		Cache key
*
* @return string|null The data. Null if not found
*/

public static function get($id)
{
if (is_null(self::$cache)) self::set_cache_object();

if (self::$cache===false) return null;

$result=self::$cache->get($id);
if ($result===false) $result=null;

return $result;
}

//---------------------------------
/**
* Writes an element to cache
*
* @param string $id		Cache key
* @param string $data	Data to cache
*
* @return void
*/

public static function set($id,$data)
{
if (is_null(self::$cache)) self::set_cache_object();

if (is_object(self::$cache))
	{
	if (is_string($data) && (strlen($data) > self::$cache_maxsize)) return;

	PHK_Util::trace("Writing cache: id=$id");//TRACE
	self::$cache->set($id,$data);
	}
}

//---------------------------------
} // End of class PHK_Cache
//=============================================================================

abstract class PHK_Cache_Base
{
// Returns true if this system can be used. Exception if unavailable

abstract public function init();

// Return data or null

abstract public function get($id);

// Return void

abstract public function set($id,$data);
}

//=============================================================================

class PHK_Cache_apc extends PHK_Cache_Base
{

public function init()
{
// Valid only in a web environment or if CLI is explicitely enabled

return PHK_Util::is_web() || ini_get('apc.enable_cli');
}

//------

public function get($id)
{
return apc_fetch($id);
}

//------

public function set($id,$data)
{
apc_store($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_apc
//=============================================================================

class PHK_Cache_xcache extends PHK_Cache_Base
{

public function init()
{
return PHK_Util::is_web(); // Valid only in a web environment
}

//------

public function get($id)
{
return xcache_get($id);
}

//------

public function set($id,$data)
{
xcache_set($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_xcache
//=============================================================================

class PHK_Cache_eaccelerator extends PHK_Cache_Base
{

public function init()
{
// eaccelerator must be compiled with shared memory functions 
// (configured with --with-eaccelerator-shared-memory)

if (!function_exists('eaccelerator_get')) return false;

return PHK_Util::is_web(); // Valid only in a web environment
}

//------

public function get($id)
{
return eaccelerator_get($id);
}

//------

public function set($id,$data)
{
eaccelerator_put($id,$data,PHK_Cache::TTL);
}

//---------------------------------
} // End of class PHK_Cache_eaccelerator
//=============================================================================

//-------------------------
} // End of class_exists('PHK_Cache')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Creator',false))
{
// <PLAIN_FILE> //---------------
require(dirname(__FILE__).'/Automap_Creator.php');
require(dirname(__FILE__).'/PHK_Proxy.php');
require(dirname(__FILE__).'/PHK_Base.php');
require(dirname(__FILE__).'/PHK_Mgr.php');
require(dirname(__FILE__).'/PHK_Tree.php');
// </PLAIN_FILE> //---------------

//============================================================================
/*
* The package creator class
*
* Note: If PHK_Creator is inside a PHK package (usual case), it is
* absolutely mandatory that Automap and PHK classes as package's files
* are the same as the Automap and PHK classes included in the prolog. Which
* means that the package must be generated from its files. If it is not the
* case, packages generated from this creator package will display wrong version
* information.
*/

class PHK_Creator extends PHK_Base
{
const VERSION='1.4.0';	// Must be the same as in PHK_Creator.psf
const MIN_VERSION='1.4.0';

//-----

public $prolog=null;
public $code=null;
private $interp='';

//-----
// init a new empty package.

public function __construct($mnt,$path,$flags)
{
parent::__construct(null,$mnt,$path,$flags,time());

$this->options=array();
$this->build_info=array('build_timestamp' => time());
}

//-----
// Read a PHK file and import everything
// We don't read the Automap map as it is rebuilt at finalize() time.

public function import_phk($source_path,$flags=0)
{
$flags |= self::F_NO_MOUNT_SCRIPT | self::F_PRELOAD_CACHE;

$source_phk=PHK_Mgr::instance($source_mnt=PHK_Mgr::mount($source_path,$flags));
$source_phk->proxy()->cache_data();

$this->proxy()->set_stree($source_phk->proxy()->stree);
$this->proxy()->set_ftree($source_phk->proxy()->ftree);
parent::set_options($source_phk->options,null);
$this->interp=$source_phk->proxy()->interp();

PHK_Mgr::umount($source_mnt);
}

//---------

public function ftree()
{
return $this->proxy()->ftree();
}

//---------

public function set_options($opt)
{
$this->options=$opt;
}

//---------

public function update_option($name,$a)
{
$this->options[$name]=$a;
}

//---------

public function update_build_info($name,$a)
{
$this->build_info[$name]=$a;
}

//---------

public function set_prolog($data)
{
$this->prolog=$data;
}

//---------

private function process_php_code(&$buffer)
{
$buffer=str_replace('?><?php','',$buffer);
$buffer=str_replace("?>\n<?php",'',$buffer);

foreach (array('creator','plain_file') as $pcode)
	{
	if (!$this->option("prolog_code_$pcode"))
		{
		$token=strtoupper($pcode);
		while (($pos=strpos($buffer,'<'.$token.'>'))!==false)
			{
			if (($pos2=strpos($buffer,'</'.$token.'>',$pos))===false)
				throw new Exception('Cannot find end of <'.$token.'> section');
			$buffer=substr_replace($buffer,'',$pos,$pos2-$pos+15);
			}
		}
	}

// php_strip_whitespace takes a file as arg. So, instead of creating a temp
// file, we use our stream wrapper to feed it with the current prolog data

if (!$this->option('plain_prolog'))
	{
	$buffer=PHK_Stream_Backend::_strip_string($buffer);
	}
}

//---------
// Build runtime PHP code
//-- $dir= base dir where files are stored

public function build_php_code($dir)
{
$this->code='';

$this->code .= PHK_Util::readfile($dir.'/classes/Automap.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Util.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_File.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Cache.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Proxy.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Mgr.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Base.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Backend.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Stream.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Stream_Backend.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_DC.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Tree.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_TNode.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_TDir.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_TFile.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_Webinfo.php');
$this->code .= PHK_Util::readfile($dir.'/classes/PHK_PHPUnit.php');

$this->process_php_code($this->code);

$this->code=str_replace('<?php','',$this->code);
$this->code=str_replace('?>','',$this->code);
}

//---------
//-- Build prolog code
//-- $dir= base dir where files are stored

public function build_prolog($dir)
{
$this->prolog = PHK_Util::readfile($dir.'/scripts/PHK_Prolog.php');

//-- The four FF chars turn unicode detection off (see PHP bug #42396)

$this->prolog .= '<?php __halt_compiler(); ?>'.str_repeat(chr(255),4);

$this->process_php_code($this->prolog);
}

//---------
// Create a new section and fill it with some data

public function add_section($name,$data,$modifiers=array())
{
$this->proxy()->stree()->mkfile($name,$data,$modifiers);
}

//---------

public function dump($path=null)
{
if (is_null($path)) $path=$this->path();

if (! PHK::file_is_package(__FILE__)) // If building PHK_Creator package
	{
	$base_dir=dirname(__FILE__).'/..';
	}
else
	{
	$mnt=PHK_Mgr::path_to_mnt(__FILE__);
	$base_dir=PHK_Mgr::base_uri($mnt);
	}

$this->build_php_code($base_dir);

//-- Build prolog if not already set

if (is_null($this->prolog)) $this->build_prolog($base_dir);

//-- Build FILES part and FTREE section
// Build Automap, strip sources, etc...

$needed_extensions=new PHK_ItemLister;

$this->proxy()->ftree()->walk('get_needed_extensions',$this,$needed_extensions);

$map=new Automap_Creator();
list($files_structure,$files_data)=$this->proxy()->ftree()->export($this,$map);

$this->add_section('FTREE',$files_structure);
unset($files_structure);

//-- Build Automap section

if ($map->symbol_count())
	$this->add_section(PHK_Proxy::AUTOMAP_SECTION,$map->serialize());

$this->update_build_info('map_defined',($map->symbol_count()!=0));

//-- Tabs sections / PHK icon

foreach(array('tabs/left.gif','tabs/right.gif','tabs/bottom.gif'
	,'tabs/tabs.css.php','phk_logo.png') as $f)
	{
	$source=$base_dir.'/etc/'.$f;
	$this->add_section('STATIC/'.$f,PHK_Util::readfile($source));
	}

//-- Build info

$this->update_build_info('PHK_Creator_version',self::VERSION);
$this->update_build_info('PHK_min_version',self::MIN_VERSION);
$this->update_build_info('Automap_creator_version',Automap_Creator::VERSION);
$this->update_build_info('Automap_min_version',Automap_Creator::MIN_VERSION);
$this->update_build_info('PHK_PSF_version',PHK_PSF::VERSION);

//-- Record the user-specified needed extensions

foreach(PHK_Util::mk_array($this->option('required_extensions')) as $ext)
	{
	if ($ext!=='') $needed_extensions->add($ext,true);
	}

//-- Flush sections
//-- Add the uncompress needed extensions to the user required extensions

$this->proxy()->stree()->walk('get_needed_extensions',$this,$needed_extensions);

$ext=array_keys($needed_extensions->get());
if (count($ext)) $this->update_option('required_extensions',$ext);

//-- Ensure mime_types, if present, is an array

if (!is_null($this->option('mime_types')))
	$this->update_option('mime_types'
		,PHK_Util::mk_array($this->option('mime_types')));

$this->add_section('OPTIONS',serialize($this->options()));

// Add build info section

$this->add_section('BUILD_INFO',serialize($this->build_info()));

// Now, dump the section tree

PHK_Util::msg('--- Sections');

list($sections_structure,$sections_data)=$this->proxy()->stree()->export($this);

//---

$prolog_offset=PHK_Proxy::INTERP_LEN+PHK_Proxy::MAGIC_LINE_LEN;
$code_offset=$prolog_offset+strlen($this->prolog);
$sections_structure_offset=$code_offset+strlen($this->code);
$sections_offset=$sections_structure_offset+strlen($sections_structure);
$files_offset=$sections_offset+strlen($sections_data);
$sig_offset=$files_offset+strlen($files_data);
$file_size=$sig_offset;

$buf=PHK_Proxy::fix_crc(PHK_Proxy::interp_block($this->interp)
	.'<?php '.PHK_Proxy::MAGIC_STRING
	.' M'  .str_pad(self::MIN_VERSION,PHK_Proxy::VERSION_SIZE)
	.' V'  .str_pad(self::VERSION,PHK_Proxy::VERSION_SIZE)
	.' FS' .str_pad($file_size,PHK_Proxy::OFFSET_SIZE)
	.' PO' .str_pad($prolog_offset,PHK_Proxy::OFFSET_SIZE)
	.' SSO'.str_pad($sections_structure_offset,PHK_Proxy::OFFSET_SIZE)
	.' STO'.str_pad($sections_offset,PHK_Proxy::OFFSET_SIZE)
	.' FTO'.str_pad($files_offset,PHK_Proxy::OFFSET_SIZE)
	.' SIO'.str_pad($sig_offset,PHK_Proxy::OFFSET_SIZE)
	.' CRC00000000'
	.' PCO'.str_pad($code_offset,PHK_Proxy::OFFSET_SIZE)
	.' PCS'.str_pad(strlen($this->code),PHK_Proxy::OFFSET_SIZE)
	.' ?>'
	.$this->prolog.$this->code.$sections_structure.$sections_data.$files_data);

PHK_Util::msg('Writing PHK file to '.$path);
PHK_Util::atomic_write($path,$buf);
}

//---------
// Upgrade a PHK package to the current PHK format
// Suppressed in v 1.3.0 - Undocumented - too dangerous

public function upgrade($phk_file_in,$phk_file_out)
{
//-- First, refuse upgrade if input file is signed

$phk=PHK_Mgr::instance
	($mnt_in=PHK_Mgr::mount($phk_file_in,self::F_NO_MOUNT_SCRIPT));

if ($phk->signed())
	throw new Exception('Cannot upgrade a signed file. Please unsign first.');

PHK_Mgr::umount($mnt_in);

//-- Create empty output object

$phk_out=PHK_Mgr::instance
	($mnt_out=PHK_Mgr::mount($phk_file_out,PHK::F_CREATOR));

//-- Get everything from the source

echo 'INFO: Upgrading from V '.$phk->version()
	.' to V '.PHK_Creator::VERSION."\n";

$phk_out->get_phk($phk_file_in);

//-- Dump to file

$phk_out->dump();
}

//---------
} //-- End of class PHK_Creator
//-------------------------
} // End of class_exists('PHK_Creator')
//============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* Data container
*
* Contains string data and supports compression.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_DC',false))
{
//============================================================================

class PHK_DC	// Data Container
{

private $csz;	// Compressed size
private $rsz;	// Real size
private $flags;	// Compression method
private $off;	// Offset
private $data=null;	// Data cache (null if unset)
private $fspace=null;

//---------

const COMPRESS_TYPE=7;	// Space reserved for 8 compression types

const COMPRESS_NONE=0;
const COMPRESS_GZIP=1;
const COMPRESS_BZIP2=2;

private static $compression_method_names=array('none','gzip','bzip2');

private static $compression_needed_extensions=array(null,'zlib','bz2');

//---------
// Clears the data cache

public function clear_cache()
{
$data=null;
}

//---------

public function set_fspace($fspace)
{
$this->fspace=$fspace;
}

//---------

private function compression_type()
{
return $this->flags & self::COMPRESS_TYPE;
}

//---------
// Uncompress a buffer, given the compression method

private function expand($buf)
{
$ctype=$this->compression_type();

if ($buf==='' || $ctype==self::COMPRESS_NONE) return $buf;

switch($ctype)
	{
	case self::COMPRESS_BZIP2:
		if(is_int($rbuf=bzdecompress($buf)))
			throw new Exception("Cannot bzdecompress data - Error code $buf");
		break;

	case self::COMPRESS_GZIP:
		if(($rbuf=gzuncompress($buf))===false)
			throw new Exception("Cannot gzuncompress data");
		break;

	default:
		throw new Exception("Unknown compression method : $ctype");
	}
return $rbuf;
}

//---
// Read/uncompress/verify and cache data

public function read()
{
if (is_null($this->data))
	{
	if ($this->rsz==0) $this->data='';	// Empty file
	else
		{
		$rbuf=$this->expand($this->fspace->read_block($this->off,$this->csz));
		if (strlen($rbuf)!=$this->rsz) throw new Exception('Wrong expanded size');
		$this->data=$rbuf;
		}
	}
return $this->data;
}

//---

private static function compression_ratio($rsz,$csz)
{
return ($rsz==0) ? '-' : (round(($csz/$rsz)*100));
}

//---

public function flag_string()
{
if ($ctype=$this->flags & self::COMPRESS_TYPE)
	return 'compress/'.self::$compression_method_names[$ctype]
		.' ('.self::compression_ratio($this->rsz,$this->csz).'%)';

return '';
}

//---

public function size() { return $this->rsz; }

//---

public function import($edata)
{
list($this->flags,$this->csz,$this->rsz,$this->off)
	=array_values(unpack('va/V3b',$edata));
	
$this->data=null; // Must be reset as the object is created as an empty file
}

//---

public function __construct()
{
$this->set_flags(0);
$this->set_data('');
$this->csz=$this->off=null;
}

//---
// Set only the DC flags

public function set_flags($flags)
{
$this->flags=($flags & PHK_TNode::TN_DC_FLAG_MASK);
}

//---

public function set_data($data)
{
$this->rsz=strlen($this->data=$data);
}

// <CREATOR> //---------------

public function get_needed_extensions(PHK_Creator $phk
	,PHK_ItemLister $item_lister)
{
if (!is_null($ext=self::$compression_needed_extensions
	[$this->flags & self::COMPRESS_TYPE]))
		$item_lister->add($ext,true);
}

//---

public function append_data($data)
{
$this->data.=$data;
$this->rsz+=strlen($data);
}

//---

public function export(PHK_Creator $phk,PHK_DataStacker $stacker)
{
$cbuf=$this->compress($this->data,$phk);
$this->csz=strlen($cbuf);
$this->off=$stacker->offset;
$stacker->push($cbuf);

return pack('vV3',$this->flags,$this->csz,$this->rsz,$this->off);
}

//------

private function deny_compress($msg,$buf)
{
PHK_Util::msg("	No compression: $msg");
$this->flags &= ~self::COMPRESS_TYPE; // Set to COMPRESS_NONE
return $buf;
}

//------

private function compress($buf,PHK_Creator $phk)
{
if (!($ctype=$this->compression_type())) return $buf;

$comp_min_size=$phk->option('compress_min_size');
$comp_max_size=$phk->option('compress_max_size');
$comp_ratio_limit=$phk->option('compress_ratio_limit');

if ($buf==='') return $this->deny_compress('Empty file',$buf);
if ((!is_null($comp_min_size)) && (strlen($buf) < $comp_min_size))
		return $this->deny_compress('File too small',$buf);
if ((!is_null($comp_max_size)) && (strlen($buf) > $comp_max_size))
		return $this->deny_compress('File too large',$buf);

switch($ctype)
	{
	case self::COMPRESS_BZIP2:
		PHK_Util::load_extension('bz2');
		PHK_Util::msg("	Compressing (bzip2)");
		if(is_int($cbuf=bzcompress($buf,9)))
			throw new Exception("Cannot bzcompress data - Error code $buf");
		break;

	case self::COMPRESS_GZIP:
		PHK_Util::load_extension('zlib');
		PHK_Util::msg("	Compressing (gzip)");
		if(($cbuf=gzcompress($buf))===false) 
			throw new Exception("Cannot gzcompress data");
		break;

	default:
		throw new Exception("Unknown compression method : $ctype");
	}

// Default: Deny if compressed buffer is larger than 90% of original

if (is_null($comp_ratio_limit)) $comp_ratio_limit=90;
if (($r=self::compression_ratio(strlen($buf),strlen($cbuf))) >$comp_ratio_limit)
	return $this->deny_compress("Compression ratio exceeded ($r%)",$buf);

return $cbuf;
}

// </CREATOR> //---------------

}	// End of class PHK_DC
//-------------------------
} // End of class_exists('PHK_DC')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* A utility class used only at package creation time.
*
* This class maintains a string buffer and appends strings to it, returning
* the current offset. When every strings have been appended, returns the
* resulting buffer.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_DataStacker',false))
{
//============================================================================

class PHK_DataStacker
{
public $offset;
public $data;

//---------

public function __construct()
{
$this->offset=0;
$this->data='';
}

//---------

public function push($data)
{
$this->data .= $data;
$ret_offset=$this->offset;
$this->offset += strlen($data);
return $ret_offset;
}

//---------
} // End of class PHK_DataStacker
//-------------------------
} // End of class_exists('PHK_DataStacker')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* Contains the code to physically access PHK package files.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_File',false))
{

//-------------------------
class PHK_File
{

private $fp=null;
private $path;
private $size;
private $open_count=0;
private $keep_open_flag;

//------
// Special case : keep sub-PHKs open (in stream wrapper memory)

public function __construct($path,$flags)
{
$this->set_params($path,$flags);

if (($this->size=filesize($path))===false)
	throw new Exception($path.': Cannot get file size');
}

//------

public function set_params($path,$flags)
{
$this->path=$path;

$this->keep_open_flag=PHK_Mgr::is_a_phk_uri($path);
}

//---

public function __sleep()
{
return array('size');
}

//------

public function __destruct()
{
$this->really_close();
}

//------

private function really_close()
{
if (!is_null($this->fp))
	{
	fclose($this->fp);
	$this->fp=null;
	$this->open_count=0;
	}
}

//------
// Open in read-only mode. Maintains a count for close(), throws exceptions,
// and force 'b' mode (for Windows).
// Called from self or PHK_FileSpace only

public function _open()
{
if (is_null($this->fp))
	{
	if (!($this->fp=fopen($this->path,'rb',false)))	//-- 'b' mode is for Windows
		throw new Exception($this->path.': Cannot open for reading');
	$this->open_count=1;
	}
else $this->open_count++;
}

//-----
// fclose() the file pointer. Maintains an open count.
// Called from self or PHK_FileSpace only

public function _close()
{
$this->open_count--;
if (($this->open_count <= 0) && (!$this->keep_open_flag)) $this->really_close();
}

//-----
// Same as PHP fread() but reads any size, throws exceptions, and checks size
// I don't use stream_get_contents() because, sometimes, it crashes
// on Windows (detected with PHP 5.1.4).

private function read($size)
{
$data='';
$nb_chunks=intval($size/8192);
$rest=$size % 8192;

PHK_Util::disable_mqr();
while ($nb_chunks > 0)
	{
	$data .= $this->read_chunk(8192);
	$nb_chunks--;
	}

if ($rest) $data .= $this->read_chunk($rest);
PHK_Util::restore_mqr();

return $data;
}

//-----
// Read up to 8192 bytes

private function read_chunk($size)
{
$buf=fread($this->fp,$size);
if ($buf===false) throw new Exception('Cannot read');
if (($bsize=strlen($buf))!=$size)
	throw new Exception("Short read ($bsize/$size)");
return $buf;
}

//-----
// Reads a block from file.
// Called only from PHK_FileSpace. So:
//		- we don't need to check bounds,
//		- we don't provide default args,
//		- we are sure that size is > 0

public function _read_block($offset,$size)
{
try
	{
	$this->_open();
	if (fseek($this->fp,$offset,SEEK_SET) == -1)
		throw new Exception('Cannot seek');
	$buf=$this->read($size);
	$this->_close();	// At the end. Everything before can raise an exception
	}				// and we don't want to close it twice
catch (Exception $e)
	{
	$this->_close();
	throw new Exception($e->getMessage());
	}
return $buf;
}

//------

public function size()
{
return $this->size;
}

//------

public function path()
{
return $this->path;
}

}	// End of class PHK_File
//-------------------------
} // End of class_exists('PHK_File')
//=============================================================================

if (!class_exists('PHK_FileSpace',false))
{
//-------------------------
class PHK_FileSpace
{

public $file;	// underlying  PHK_File object
private $offset;
private $size;

//------
// Two possibles syntaxes :
// new PHK_FileSpace(String $path,int $flags) : creates a first space for a file
// new PHK_FileSpace(PHK_FileSpace $parent, int $offset, int $size) :
//		creates a subspace inside an existing FileSpace.

public function __construct($arg1,$arg2,$size=null)
{
if (is_string($arg1))
	{
	$this->file=new PHK_File($arg1,$arg2);
	$this->offset=0;
	$this->size=$this->file->size();
	}
else
	{
	if ((!($arg1 instanceof self))
		|| (!is_numeric($arg2))
		|| (!is_numeric($size))
		|| ($arg2 < 0)
		|| (($arg2+$size) > $arg1->size))
		throw new Exception("PHK_FileSpace: cannot create - invalid arguments");

	$this->file=$arg1->file;
	$this->offset=$arg1->offset + $arg2;
	$this->size=$size;
	}
}

//------
// Default args so that read_block() without args returns the whole filespace

public function read_block($offset=0,$size=null)
{
//PHK_Util::trace("Starting PHK_FileSpace::read_block - offset=$offset - size=$size");//TRACE

if (is_null($size)) $size=$this->size-$offset; // Read up to the end

if (($offset<0)||($size<0)||($offset+$size>$this->size))
	throw new Exception('PHK_FileSpace: Read out of bound');

if ($size==0) return '';

$data=$this->file->_read_block($this->offset+$offset,$size);

//PHK_Util::trace("Ending PHK_FileSpace::read_block");//TRACE
return $data;
}

//------
// Used to force the file to remain open temporarily

public function open()
{
$this->file->_open();
}

//------

public function close()
{
$this->file->_close();
}

//------

public function size()
{
return $this->size;
}

//------
// Returns path of underlying file (can be a PHK URI)

public function path()
{
return $this->file->path();
}

//------
}	// End of class PHK_FileSpace
//-------------------------
} // End of class_exists('PHK_FileSpace')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* A utility class used only at package creation time.
*
* This class maintains an array and appends elements to it, eliminating
* duplicate keys. When every elements have been appended, returns the resulting
* array.
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_ItemLister',false))
{
//============================================================================

class PHK_ItemLister
{
private $a;

//---------

public function __construct()
{
$this->a=array();
}

//---------

public function add($item,$value)
{
$this->a[$item]=$value;
}

//---------

public function get()
{
return $this->a;
}

//---------
} //-- End of class PHK_ItemLister
//-------------------------
} // End of class_exists('PHK_ItemLister')
//============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

//=============================================================================

if (!class_exists('PHK_Mgr',false))
{
//=============================================================================
/**
* This is a static-only class. It has the responsability to manage the table
* of currently mounted packages. Each package is uniquely identified by a
* 'mount point', which is a string computed at mount time. The PHK_Mgr class
* contains the methods allowing to get information from its table, as well
* as methods to mount and umount a package.
*
* Runtime code -> 100% read-only.
*
* @package PHK
*/

//=============================================================================

class PHK_Mgr	// Static only
{
/** Class version */

const VERSION='1.4.0';

//-- Global static properties

/** @var array		Currently mounted PHK instances */

private static $phk_tab=array(); // Key=mount directory, value=PHK instance

/**
* @var array		Proxy objects for each currently mounted package. As
* long as the proxy object is not instantiated through the proxy() method,
* the corresponding value is null in this array. Contains exactly the same
* keys as $phk_tab.
*/

private static $proxy_tab=array(); // Key=mount directory, value=PHK_Proxy|null

/* @var int Running value for PHK_Creator mount points */

private static $tmp_mnt_num=0;

/* @var boolean|null Global cache toggle. If null, per-instance logic is used */

private static $caching=null;

//-----
/**
* Checks if a mount point is valid (if it corresponds to a currently mounted
* package)
*
* @param string $mnt Mount point to check
* @return boolean
*/

public static function is_mounted($mnt)
{
return isset(self::$phk_tab[$mnt]);
}

//-----
/**
* Same as is_mounted but throws an exception is the mount point is invalid.
*
* Returns the mount point so that it can be embedded in a call string.
*
* @param string $mnt Mount point to check
* @return string mount point (not modified)
* @throws Exception if mount point is invalid
*/

public static function validate($mnt)
{
if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point');

return $mnt;
}

//-----
/**
* Returns the PHK object corresponding to a given mount point
*
* @param string $mnt Mount point
* @return PHK instance
* @throws Exception if mount point is invalid
*/

public static function instance($mnt)
{
self::validate($mnt);

return self::$phk_tab[$mnt];
}

//-----
/**
* Returns the PHK_Proxy object corresponding to a given mount point
*
* If the corresponding PHK_Proxy object does not exist yet, it is created.
*
* @param string $mnt Mount point
* @return PHK_Proxy proxy object
* @throws Exception if mount point is invalid
*/

public static function proxy($mnt)
{
self::validate($mnt);

if (is_null(self::$proxy_tab[$mnt]))
	{
	$phk=self::instance($mnt);
	self::$proxy_tab[$mnt]=new PHK_Proxy($phk->path(),$phk->flags());
	}

return self::$proxy_tab[$mnt];
}

//-----
/**
* Returns the list of the defined mount points.
*
* @return array
*/

public static function mnt_list()
{
return array_keys(self::$phk_tab);
}

//---------
/**
* Sets the global caching toggle
*
* Normally, the global cache toggle is always null, except in 'webinfo'
* mode, where it is false to inhibit any caching of webinfo information
* (2 reasons: useless in terms of performance, and could use the same keys as
* the 'non-webinfo' mode, so we would have to use another key prefix).
*
* @param boolean|null $caching True: always cache, False: never cache,
* null: use per-instance logic.
* @return void
*/

public static function set_cache($caching)
{
self::$caching=$caching;
}

//---------
/**
* Determines if a an URI can be cached.
*
* For performance reasons, the input URI is splitted.
*
* Called by the wrapper to know if it should cache the data it got from its
* backend.
*
* The global cache toggle is checked first. If it is null, control is
* transferred to the instance logic.
*
* @param string|null $mnt Mount point or null if global command
* @param string|null $command command if defined
* @param array|null $params Command parameters if defined
* @param string $path Path
* @return boolean whether the data should be cached or not
* @throws Exception if mount point is invalid
*/


public static function cache_enabled($mnt,$command,$params,$path)
{
if (!is_null(self::$caching)) return self::$caching;

if (is_null($mnt)) return false;

return self::instance($mnt)->cache_enabled($command,$params,$path);
}

//---------
/**
* Given a file path, tries to determine if it is currently mounted. If it is
* the case, the corresponding mount point is returned. If not, an exception is
* thrown.
*
* Note: when dealing with sub-packages, the input path parameter can be a PHK
* URI.
*
* @param string $path Path of a PHK package
* @return the corresponding mount point
* @throws Exception if the file is not currently mounted
*/

public static function path_to_mnt($path)
{
$dummy1=$mnt=$dummy2=null;
self::compute_mnt($path,$dummy1,$mnt,$dummy2);

if (self::is_mounted($mnt)) return $mnt;

throw new Exception($path.': path is not mounted');
}

//---------
/**
* Mount a PHK package and returns the new (or previous, if already loaded)
* PHK mount point.
*
* Can also create empty PHK_Creator instances (when the 'CREATOR' flag is set).
*
* @param string $path The path of an existing PHK archive, or the path of the
*                     archive to create if ($flags & PHK::F_CREATOR)
* @param int $flags Or-ed combination of PHK mount flags.
* @return string the mount point
*/

public static function mount($path,$flags=0)
{
try
{
if ($flags & PHK::F_CREATOR)
	{
	$mnt='_tmp_mnt_'.(self::$tmp_mnt_num++);
	self::$proxy_tab[$mnt]=null;
	self::$phk_tab[$mnt]=new PHK_Creator($mnt,$path,$flags);
	}
else	// Mount an existing archive
	{
	$parent_mnt=$mnt=$mtime=$options=$build_info=null;
	self::compute_mnt($path,$parent_mnt,$mnt,$mtime);
	if (self::is_mounted($mnt)) return $mnt;

	self::$proxy_tab[$mnt]=null;
	self::$phk_tab[$mnt]=$phk=new PHK($parent_mnt,$mnt,$path,$flags,$mtime);

	self::get_store_data($mnt,$options,$build_info);
	$phk->init($options,$build_info);
	}
}
catch (Exception $e)
	{
	if (isset($mnt) && self::is_mounted($mnt)) unset(self::$phk_tab[$mnt]);
	throw new Exception($path.': Cannot mount - '.$e->getMessage());
	}

return $mnt;
}

//-----
/**
* Checks the PHK version this package requires against the current version.
* Then, retrieves the 'options' and 'build_info' arrays.
*
* This function is separated from mount() to mimic the behavior of the PHK
* extension, where this data is cached in persistent memory.
*
* @param string $mnt the mount point
* @param array $options on return, contains the options array
* @param array $build_info on return, contains the build_info array
* @return void
*/

private static function get_store_data($mnt,&$options,&$build_info)
{
$caching=(is_null(self::$caching) ? true : self::$caching);

// Must check this first

$mv=PHK_Util::get_min_version($mnt,$caching);

if (version_compare($mv,PHK::VERSION) > 0)
	{
	PHK_Util::format_error('Cannot understand this version. '
		.'Requires at least PHK version '.$mv);
	}

$options=PHK_Util::get_options($mnt,$caching);
$build_info=PHK_Util::get_build_info($mnt,$caching);
}

//---------------------------------
/**
* Computes the mount point corresponding to a given path.
*
* Also returns the parent mount point (for sub-packages), and the modification
* time (allows to call stat() only once).
*
* Mount point uniqueness is based on a combination of device+inode+mtime.
*
* When dealing with sub-packages, the input path is a PHK URI.
*
* Sub-packages inherit their parent's modification time.
*
* @param string $path The path to be mounted
* @param $parent_mnt string|null returns the parent mount point. Not
* null only for sub-packages.
* @param string $mnt returns the computed mount point
* @param int $mtime returns the modification time
* @return void
* @throws Exception with message 'File not found' if unable to stat($path).
*/

private static function compute_mnt($path,&$parent_mnt,&$mnt,&$mtime)
{
if (self::is_a_phk_uri($path)) // Sub-package
	{
	$dummy1=$dummy2=$subpath=$parent_mnt=null;
	PHK_Stream::parse_uri($path,$dummy1,$dummy2,$parent_mnt,$subpath);
	self::validate($parent_mnt);
	$mnt=$parent_mnt.'#'.str_replace('/','*',$subpath);
	$mtime=self::instance($parent_mnt)->mtime(); // Inherit mtime
	}
else
	{
	$mnt=PHK_Util::path_unique_id('p',$path,$mtime);
	$parent_mnt=null;
	}
}

//---------------------------------
/**
* Umounts a mounted package and any mounted descendant.
*
* We dont use __destruct because :
*	1. We don't want this to be called on script shutdown
*	2. Exceptions cannot be caught when sent from a destructor.
*
* Accepts to remove a non registered mount point without error
*
* @param string $mnt The mount point to umount
*/

public static function umount($mnt)
{
if (self::is_mounted($mnt))
	{
	// Umount children

	foreach (array_keys(self::$phk_tab) as $dmnt)
		{
		if (isset(self::$phk_tab[$dmnt])
			&& self::$phk_tab[$dmnt]->parent_mnt()===$mnt)
				self::umount($dmnt);
		}

	// Call instance's umount procedure

	self::$phk_tab[$mnt]->umount();

	// Remove from the list

	unset(self::$phk_tab[$mnt]);
	unset(self::$proxy_tab[$mnt]);
	}
}

//---------
/**
* Builds a 'phk://' uri, from a mount directory and a path
*
* @param string $mnt The mount point
* @param string $path The path
* @return string The computed URI
*/

public static function uri($mnt,$path)
{
return self::base_uri($mnt).ltrim($path,'/');
}

//-----
/** Checks if a string is a PHK URI
*
* @param string $uri
* @return boolean
*/

public static function is_a_phk_uri($uri)
{
$u=$uri.'      ';

// Much faster this way

return ($u{0}=='p' && $u{1}=='h' && $u{2}=='k' && $u{3}==':'
	&& $u{4}=='/' && $u{5}=='/'); 

//return (strlen($uri) >= 6) && (substr($uri,0,6)=='phk://');
}

//-----
/**
* Returns the base string used to build URIs for a given mount point.
*
* The base URI has the form : phk://<mount point>
*
* @param string $mnt A mount point
* @return string
*/

public static function base_uri($mnt)
{
return 'phk://'.$mnt.'/';
}

//---------
/**
* Returns a 'command' URI, given a mount point and a 'command' string
*
* Command URIs have the form : phk://<mount point>/?<command>
*
* @param string $mnt A mount point
* @param string $command Command string
* @return string
*/

public static function command_uri($mnt,$command)
{
return self::uri($mnt,'?'.$command);
}

//---------
/**
* Returns the URI allowing to retrieve a section.
*
* Section URIs have the form : phk://<mount point>/?section&name=<section>
*
* @param string $mnt A mount point
* @param string $section The section to retrieve
* @return string
*/

public static function section_uri($mnt,$section)
{
return self::command_uri($mnt,'section&name='.$section);
}

//-----
/**
* Returns the URI of the Automap map if it is defined
*
* @param string $mnt A mount point
* @return string|null returns null if the package does not define an automap.
*/

public static function automap_uri($mnt)
{
if ((!self::is_mounted($mnt))||(!self::instance($mnt)->map_defined()))
	return null;

return self::section_uri($mnt,'AUTOMAP');
}

//---------------------------------
/**
* Replaces '\' characters by '/' in a URI.
*
* @param string $uri
* @return string
*/

public static function normalize_uri($uri)
{
return str_replace('\\','/',$uri);
}

//-----
/**
* Returns the mount directory of a subfile's phk uri.
* Allows to reference other subfiles in the same package if you don't want
* or cannot use Automap (the preferred method) or a relative path.
* Example : include(PHK_Mgr::uri(PHK_Mgr::uri_to_mnt(__FILE__),<path>));
*
* @param string $uri
* @return string a mount point
* @throws Exception if the input URI is not a PHK URI
*/

public static function uri_to_mnt($uri)
{
if (! self::is_a_phk_uri($uri))
	throw new Exception($uri.': Not a PHK URI');

$buf=substr(self::normalize_uri($uri),6);
$buf=substr($buf,0,strcspn($buf,'/'));
return trim($buf);
}

//---------
/**
* Check if the current PHP version is supported.
*
* Note that, if PHP version < 5.1, parsing fails and we don't even start
* execution. So, this test is only executed when PHP version >= 5.1
*
* As a side effect, until we request a version > 5.1, this function
* will never fail.
*
* Calls exit(1) if PHP version is not supported by the PHK runtime
*
* @return void
*/

public static function php_version_check()
{
if (version_compare(PHP_VERSION,'5.1.0') < 0)
	{
	echo PHP_VERSION.': Unsupported PHP version '
		.'- PHK needs at least version 5.1.0';
	exit(1);
	}
}

//---------------------------------
} // End of class PHK_Mgr
//-------------------------
} // End of class_exists('PHK_Mgr')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
// Please note that most of this file is derived from the code published by
// the PHPUnit project (v 3.2.2).
// As such, please consider the following notice:
/*
 * PHPUnit
 *
 * Copyright (c) 2002-2007, Sebastian Bergmann <sb@sebastian-bergmann.de>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *
 *   * Neither the name of Sebastian Bergmann nor the names of his
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!function_exists('_phk_load_phpunit_interface'))
{
function _phk_load_phpunit_interface()
{
if (!class_exists('PHPUnit_Runner_PHKTestSuiteLoader',false))
{
//=============================================================================
/**
*/
class PHPUnit_Runner_PHKTestSuiteLoader implements PHPUnit_Runner_TestSuiteLoader
{

//-------------------

public function load($suiteClassName, $suiteClassFile = '')
{
if (class_exists($suiteClassName, true))
	{
	return new ReflectionClass($suiteClassName);
	}
else throw new RuntimeException("Class $suiteClassName could not be found");
}

//-------------------

public function reload(ReflectionClass $aClass)
{
return $aClass;
}

//---------------------------------
} // End of class PHPUnit_Runner_PHKTestSuiteLoader
//-------------------------
} // End of class_exists('PHPUnit_Runner_PHKTestSuiteLoader')
//=============================================================================

if (!class_exists('PHPUnit_TextUI_PHK',false))
{
//=============================================================================
/**
*/
class PHPUnit_TextUI_PHK
{
//-------------------

public static function main()
{
PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT');

self::handleLoader('PHPUnit_Runner_PHKTestSuiteLoader');

//----

$arguments=self::handleArguments();

$runner= new PHPUnit_TextUI_TestRunner;

$suite = $runner->getTest($arguments['test'],'',$arguments['syntaxCheck']);

try	{
	if (PHK_Util::is_web()) echo "<pre>\n";

	$result = $runner->doRun($suite,$arguments);

	if (PHK_Util::is_web()) echo "</pre>\n";
	}
catch (Exception $e)
	{
    throw new RuntimeException('Could not create and run test suite: '
		. $e->getMessage());
	}

if (!PHK_Util::is_web())
	{
	if ($result->wasSuccessful()) exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
	else if($result->errorCount() > 0)
		exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
	else exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT);
	}
}

//-------------------
/**
* @access protected
* @static
*/

protected static function handleArguments()
{
$arguments = array('syntaxCheck' => TRUE);

$longOptions = array(
	'configuration=',
	'exclude-group=',
	'filter=',
	'group=',
	'help',
	'loader=',
	'log-json=',
	'log-tap=',
	'log-xml=',
	'repeat=',
	'skeleton',
	'stop-on-failure',
	'tap',
	'testdox',
	'testdox-html=',
	'testdox-text=',
	'no-syntax-check',
	'verbose',
	'version',
	'wait');

if (class_exists('Image_GraphViz', FALSE)) $longOptions[] = 'log-graphviz=';

if (extension_loaded('pdo'))
	{
	$longOptions[] = 'test-db-dsn=';
	$longOptions[] = 'test-db-log-rev=';
	$longOptions[] = 'test-db-log-prefix=';
	$longOptions[] = 'test-db-log-info=';
	}

if (extension_loaded('xdebug'))
	{
	$longOptions[] = 'coverage-html=';
	$longOptions[] = 'coverage-xml=';
	$longOptions[] = 'log-metrics=';
	$longOptions[] = 'log-pmd=';
	$longOptions[] = 'report=';
	}

try
	{
	//-- Tests if argv exists - allows to run in web mode

	$options = PHPUnit_Util_Getopt::getopt(
		isset($_SERVER['argv']) ? $_SERVER['argv'] : array(),'d:',$longOptions);
	}
catch (RuntimeException $e)
	{
	PHPUnit_TextUI_TestRunner::showError($e->getMessage());
	}

$arguments['test']=(isset($options[1][0]) ? $options[1][0] : 'AllTests');

$arguments['testFile'] = '';

foreach ($options[0] as $option)
	{
	switch ($option[0])
		{
		case '--configuration':
			$arguments['configuration'] = $option[1];
			break;

		case '--coverage-xml':
			$arguments['coverageXML'] = $option[1];
			break;

		case 'd':
			$ini = explode('=', $option[1]);
			if (isset($ini[0]))
				{
				if (isset($ini[1]))
					{
					ini_set($ini[0], $ini[1]);
					}
				else ini_set($ini[0], TRUE);
				}
			break;

		case '--help':
			self::showHelp();
			exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
			break;

		case '--filter':
			if (preg_match('/^[a-zA-Z0-9_]/', $option[1]))
				$arguments['filter'] = '/^' . $option[1] . '$/';
			else
				$arguments['filter'] = $option[1];
			break;

		case '--group':
			$arguments['groups'] = explode(',', $option[1]);
			break;

		case '--exclude-group':
			$arguments['excludeGroups'] = explode(',', $option[1]);
			break;

		case '--loader':
			self::handleLoader($option[1]);
			break;

		case '--log-json':
			$arguments['jsonLogfile'] = $option[1];
			break;

		case '--log-graphviz':
			$arguments['graphvizLogfile'] = $option[1];
			break;

		case '--log-tap':
			$arguments['tapLogfile'] = $option[1];
			break;

		case '--log-xml':
			$arguments['xmlLogfile'] = $option[1];
			break;

		case '--log-pmd':
			$arguments['pmdXML'] = $option[1];
			break;

		case '--log-metrics':
			$arguments['metricsXML'] = $option[1];
			break;

		case '--repeat':
			$arguments['repeat'] = (int)$option[1];
			break;

		case '--stop-on-failure':
			$arguments['stopOnFailure'] = TRUE;
			break;

		case '--test-db-dsn':
			$arguments['testDatabaseDSN'] = $option[1];
			break;

		case '--test-db-log-rev':
			$arguments['testDatabaseLogRevision'] = $option[1];
			break;

		case '--test-db-prefix':
			$arguments['testDatabasePrefix'] = $option[1];
			break;

		case '--test-db-log-info':
			$arguments['testDatabaseLogInfo'] = $option[1];
			break;

		case '--coverage-html':
		case '--report':
			$arguments['reportDirectory'] = $option[1];
			break;

		case '--skeleton':
			if (isset($arguments['test']))
				self::doSkeleton($arguments['test'],'');
			else
				{
				self::showHelp();
				exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
				}
			break;

		case '--tap':
			$arguments['printer'] = new PHPUnit_Util_Log_TAP;
			break;

		case '--testdox':
			$arguments['printer'] = new PHPUnit_Util_TestDox_ResultPrinter_Text;
			break;

		case '--testdox-html':
			$arguments['testdoxHTMLFile'] = $option[1];
			break;

		case '--testdox-text':
			$arguments['testdoxTextFile'] = $option[1];
			break;

		case '--no-syntax-check':
			$arguments['syntaxCheck'] = FALSE;
			break;

		case '--verbose':
			$arguments['verbose'] = TRUE;
			break;

		case '--version':
			PHPUnit_TextUI_TestRunner::printVersionString();
			exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
			break;

		case '--wait':
			$arguments['wait'] = TRUE;
			break;
		}
	}

if (!isset($arguments['test']) && isset($arguments['configuration']))
	{
	$configuration= new PHPUnit_Util_Configuration($arguments['configuration']);

	$testSuite = $configuration->getTestSuiteConfiguration();

	if ($testSuite !== NULL) $arguments['test'] = $testSuite;
	}

if ((isset($arguments['testDatabaseLogRevision'])
	&& !isset($arguments['testDatabaseDSN'])))
	{
	self::showHelp();
	exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
	}

return $arguments;
}

/**
* @param  string  $test
* @param  string  $testFile
* @access protected
* @static
*/
protected static function doSkeleton($test, $testFile)
{
if ($test !== FALSE)
	{
	PHPUnit_TextUI_TestRunner::printVersionString();

	try
		{
		$skeleton = new PHPUnit_Util_Skeleton($test, $testFile);
		$skeleton->write();
		}
	catch (Exception $e)
		{
		print $e->getMessage() . "\n";

		printf('Could not write test class skeleton for "%s" to "%s".' . "\n",
			$test,$testFile);

		exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT);
		}

	printf('Wrote test class skeleton for "%s" to "%s".' . "\n",
		$test,$skeleton->getTestSourceFile());

	exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
	}
}

/**
* @param  string  $loaderName
* @access protected
* @static
*/
protected static function handleLoader($loaderName)
{
if (!class_exists($loaderName, FALSE))
	{
	PHPUnit_Util_Fileloader::checkAndLoad(str_replace('_', '/', $loaderName)
		. '.php');
	}

if (class_exists($loaderName, FALSE))
	{
	$class = new ReflectionClass($loaderName);

	if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') &&
		$class->isInstantiable())
		{
		$loader = $class->newInstance();
		}
	}

if (!isset($loader))
	{
	PHPUnit_TextUI_TestRunner::showError(
		sprintf('Could not use "%s" as loader.',$loaderName));
	}

PHPUnit_TextUI_TestRunner::setLoader($loader);
}

/**
* @access public
* @static
*/
public static function showHelp()
{
PHPUnit_TextUI_TestRunner::printVersionString();

print "Usage: php <package> [switches] [UnitTest]\n\n";

if (class_exists('Image_GraphViz', FALSE)) {
    print "  --log-graphviz <file>  Log test execution in GraphViz markup.\n";
}

print "  --log-json <file>      Log test execution in JSON format.\n" .
      "  --log-tap <file>       Log test execution in TAP format to file.\n" .
      "  --log-xml <file>       Log test execution in XML format to file.\n";

if (extension_loaded('xdebug')) {
    print "  --log-metrics <file>   Write metrics report in XML format.\n" .
          "  --log-pmd <file>       Write violations report in PMD XML format.\n\n" .
          "  --coverage-html <dir>  Generate code coverage report in HTML format.\n" .
          "  --coverage-xml <file>  Write code coverage information in XML format.\n\n";
}

if (extension_loaded('pdo')) {
    print "  --test-db-dsn <dsn>    DSN for the test database.\n" .
          "  --test-db-log-rev <r>  Revision information for database logging.\n" .
          "  --test-db-prefix ...   Prefix that should be stripped from filenames.\n" .
          "  --test-db-log-info ... Additional information for database logging.\n\n";
}

print "  --testdox-html <file>  Write agile documentation in HTML format to file.\n" .
      "  --testdox-text <file>  Write agile documentation in Text format to file.\n\n" .
      "  --filter <pattern>     Filter which tests to run.\n" .
      "  --group ...            Only runs tests from the specified group(s).\n" .
      "  --exclude-group ...    Exclude tests from the specified group(s).\n\n" .
      "  --loader <loader>      TestSuiteLoader implementation to use.\n" .
      "  --repeat <times>       Runs the test(s) repeatedly.\n\n" .
      "  --tap                  Report test execution progress in TAP format.\n" .
      "  --testdox              Report test execution progress in TestDox format.\n\n" .
      "  --no-syntax-check      Disable syntax check of test source files.\n" .
      "  --stop-on-failure      Stop execution upon first error or failure.\n" .
      "  --verbose              Output more verbose information.\n" .
      "  --wait                 Waits for a keystroke after each test.\n\n" .
      "  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.\n\n" .
      "  --help                 Prints this usage information.\n" .
      "  --version              Prints the version and exits.\n\n" .
      "  --configuration <file> Read configuration from XML file.\n" .
      "  -d key[=value]         Sets a php.ini value.\n";
}

//---------------------------------
} // End of class PHPUnit_TextUI_PHK
//-------------------------
} // End of class_exists('PHPUnit_TextUI_PHK')
//=============================================================================
} // End of function _phk_load_phpunit_interface
//=============================================================================
} // End of function_exists(_phk_load_phpunit_interface)
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_PSF class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

class PHK_PSF 
{
private $filename;
private $line_nb;
private $variables;

const VERSION='0.1.3';

//---------

public function __construct($psf,$args)
{
$this->filename=$psf;
$this->variables=array();

$this->set_variable('PSF_DIR',dirname($psf));

$n=1;
foreach($args as $arg) $this->set_variable($n++,$arg);
}

//---- Exception with file name and line number
// Can be called recursively. So, we decorate the message only once

private function send_error($msg)
{
if (($msg!='') && ($msg{0}=='>')) throw new Exception($msg);
else throw new Exception('> '.$this->filename.'(line '.$this->line_nb.') : '.$msg);
}

//---- Read a line with continuation '\' and strip comments (#) + trim()
//---- Returns false on EOF

private function get_line()
{
$line='';

while (true)
	{
	$this->line_nb++;
	if (($line1=fgets($this->fp))===false) // EOF
		{
		if ($line=='') return null;
		else $this->send_error('Unexpected EOF'); // If it was a continuation
		}
	if (($pos=strpos($line1,'#'))!==false)	// Remove comments
		$line1=substr($line1,0,$pos);
	$line1=trim($line1);
	if ($line1=='') continue;

	if ($line1[strlen($line1)-1]=='\\')	// Continued on next line
		{
		$cont=true;
		$line1=substr($line1,0,-1);	// Remove \ at EOL
		$line .=' '; // As we trim every line, add a space for continuation
		}
	else $cont=false;
	$line .= $line1;
	if ($cont) continue;
	//-- Variables substitution

	while (($pos=strpos($line,'$('))!==false) // always search the whole line
		{
		$pos2=strpos($line,')',$pos);
		if ($pos2==($pos+2)) $this->send_error('Empty variable');
		if ($pos2===false) $this->send_error('No variable end');
		$var=substr($line,$pos+2,$pos2-($pos+2));
		$val=$this->get_variable($var);
		$line=substr_replace($line,$val,$pos,$pos2+1-$pos);
		}

	//-- Remove leading/trailing blanks

	$line=str_replace('	',' ',trim($line));	// Replaces tabs with spaces

	if ($line!='') break;	// Skip empty lines
	}
return $line;
}

//---------

private function set_variable($name,$value)
{
$this->variables[$name]=$value;
}

//---------

private function get_variable($name)
{
if (isset($this->variables[$name])) return $this->variables[$name];
if (($val=getenv($name))!==false) return $val;
$this->send_error($name.': reference to undefined variable');
}

//---------

private function get_word(&$line,$error_flag=true)
{
if (($line=trim($line))=='')
	{
	if ($error_flag) send_error('Short line');
	else return null;
	}
$pos=strpos($line,' ');
if ($pos==false)
	{
	$word=$line;
	$line='';
	}
else
	{
	$word=substr($line,0,$pos);
	$line=ltrim(substr($line,$pos));
	}

//-- Globbing

if ((strpos($word,'*')!==false) || (strpos($word,'?')!==false))
	{
	$g=@glob($word);
	if ($g===false) return $word;
	if (count($g)) $line=implode(' ',$g).' '.$line;
	return $this->get_word($line,$error_flag);
	}

return $word;
}

//---------

public function get_modifiers(&$line)
{
$modifiers=array();

while (!is_null($word=$this->get_word($line,false)))
	{
	if (($word!='') && ($word{0}!='-')) break; // If it is not an option
	if ($word=='-') continue;
	if (count($a=explode('=',strtolower(substr($word,1)),2))!==2)
		throw new Exception($word.': Wrong modifier format');
	$modifiers[$a[0]]=$a[1];
	}

if ($word) $line=$word.' '.$line; // unget word
return $modifiers;
}

//---------
// Globbing will be implemented in a future version...
// On entry, $phk is a PHK_Creator object

public function apply_to($phk)
{
if (!($phk instanceof PHK_Creator))
	throw new Exception('Object must be PHK_Creator');

if (!($this->fp=fopen($this->filename,'rb',false)))
	throw new Exception($this->filename.': Cannot open');
	
$this->line_nb=0;

try {
while (!is_null($line=$this->get_line()))
	{
	$command=strtolower($this->get_word($line));
	if ($command{0}==='%') break;
	switch($command)
		{
		case 'add':	// add <target> <source> [<source>...]
			$modifiers=$this->get_modifiers($line);
			// Beware of trailing '/'
			if (($target_spec=rtrim($this->get_word($line),'/'))=='')
				throw new Exception('Cannot replace root dir');

			while (!is_null($source=$this->get_word($line,false)))
				{
				$target=str_replace('&',basename($source),$target_spec);
				$phk->ftree()->add_file_tree($target,$source,$modifiers);
				}
			break;

		case 'merge':	// merge <target (dir)> <source-dir> [<source_dir>...]
			$modifiers=$this->get_modifiers($line);
			$target_dir_spec=rtrim($this->get_word($line));

			while (!is_null($source_dir=$this->get_word($line,false)))
				{
				$target_dir=str_replace('&',basename($source_dir)
					,$target_dir_spec);
				$phk->ftree()->merge_file_tree($target_dir,$source_dir,$modifiers);
				}
			break;

		case 'modify':
			$modifiers=$this->get_modifiers($line);
			while (!is_null($path=$this->get_word($line,false)))
				$phk->ftree()->modify($path,$modifiers);
			break;

		case 'mount':
			$mnt_var=$this->get_word($line);
			$file=$this->get_word($line);
			$mnt=PHK_Mgr::mount($file,PHK::F_NO_MOUNT_SCRIPT | PHK::F_CHECK_CRC);
			$this->set_variable($mnt_var,$mnt);
			break;

		case 'remove':	// remove <path> [<path>...]
			while ($path=trim($this->get_word($line,false),'/'))
				{
				$phk->ftree()->remove($path);
				}
			break;

		case 'import':	// import <phk-path>
			$phk->import_phk($this->get_word($line));
			break;

		case 'set':
			$var=$this->get_word($line);
			$this->set_variable($var,$line);
			break;

		case 'section':		//-- Undocumented
			$name=$this->get_word($line);
			$file=$this->get_word($line);

			$phk->add_section($name,PHK_Util::readfile($file));
			break;
			
		case 'prolog':	//-- Undocumented - maybe useless
			$phk->set_prolog(PHK_Util::readfile($this->get_word($line)));
			break;

		default:
			$this->send_error($command.': Unknown command');
		}
	}
} catch (Exception $e) { $this->send_error($e->getMessage()); }

if (!is_null($line)) // If we met a '%'
	{
	$data='<?php ';
	while (($line=fgets($this->fp))!==false) $data .= $line;

	$a=PHK_Stream_Backend::_include_string($data);
	if (!(is_array($a)))
		throw new Exception('Options block should return an array');
	$phk->set_options($a);
	}

fclose($this->fp);
}

//---------
// Build a new PHK package from a PSF file

public static function build($phk_file,$psf_file,$args)
{
//-- Create empty output object

$mnt=PHK_Mgr::mount($phk_file,PHK::F_CREATOR);
$phk=PHK_Mgr::instance($mnt);

//-- Run PSF file

$psf=new PHK_PSF($psf_file,$args);
$psf->apply_to($phk);

//-- Dump to file

$phk->dump();
}

//---------
} // End of class PHK_PSF
//============================================================================
?>
<?php
//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Proxy class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Proxy',false))
{
// <PLAIN_FILE> //---------------
/** PHK Utilities (Non PHK mode only) */
require(dirname(__FILE__).'/PHK_Util.php');
/** File handling classes (Non PHK mode only) */
require(dirname(__FILE__).'/PHK_File.php');
// </PLAIN_FILE> //---------------

//=============================================================================
/**
* The 'back-end' object providing physical access to the package file. This
* object is created and called by the stream wrapper on cache misses.
*
* Runtime code -> 100% read-only except set_buffer_interp().
*
* @see PHK_Stream
* @see PHK
* @see PHK_Mgr
* @package PHK
*/

class PHK_Proxy
{
//========== Class constants ===============

/** Class version */

const VERSION='1.3.0';

/** The size of the interp line (fixed size) */

const INTERP_LEN=64;

/** The size of a version string in the magic block - Up to 12 bytes */

const VERSION_SIZE=12;

/** The size of each offset field. As offset are limited to 11 bytes, the
* theoritical max size of a PHK archive is 100 G bytes. Not tested :) */

const OFFSET_SIZE=11;

/** The magic string. This is the string we identify to recognize a PHK archive */

const MAGIC_STRING="#PHK M\024\x8\6\3";
const MAGIC_STRING_LEN=10;

/** INTERP_LEN + 6 */

const MAGIC_STRING_OFFSET=70;

/** The size of the magic block */

const MAGIC_LINE_LEN=177;

/** The name of the optional Automap section, when it exists */

const AUTOMAP_SECTION='AUTOMAP';

/** The offset of the CRC field, from the beginning of the archive file.
* The CRC field is 8 bytes long (32 bits in hexadecimal) */

const CRC_OFFSET=200;

//========== Instance data ===============

/** @var PHK_Tree	Section tree */

protected	$stree=null;

/** @var PHK_Tree	File tree */

public		$ftree=null;

/** @var integer	Mount flags */

protected	$flags;

/** @var PHK_FileSpace	File Handler */

protected	$fspace;

/** @var array		Magic values */

private		$magic=null;

//========== Class methods ===============

/**
* Constructor
*
* This method must be called only from PHK_Mgr::proxy() only
*
* @param string mount point
*
* @throws Exception
*/

public function __construct($path,$flags)
{
try
{
PHK_Util::slow_path();

//PHK_Util::trace("Starting proxy init");//TRACE

$this->flags=$flags;

if (!($this->flags & PHK::F_CREATOR))
	{
	// file_is_package() moved here from PHK_Mgr::compute_mnt() because we don't
	// need to check this if data is already in cache.

	if (! self::file_is_package($path))
		throw new Exception($path.'is not a PHK package');

	$this->fspace= new PHK_FileSpace($path,$flags);
	$this->fspace->open();

	// Get magic block

	$this->get_magic_values();

	// Check that file size corresponds to the value stored in the magic block.
	// Done only once in slow path because, if the file size changes, the
	// modification date will change too, and thus the mount point.

	if ($this->fspace->size()!=$this->magic['fs']) // Check file size
		PHK_Util::format_error('Invalid file size. Should be '.$this->magic['fs']);

	// Import section tree

	$this->stree=PHK_Tree::create_from_edata(
		$this->fspace->read_block($this->magic['sso']
			,$this->magic['sto']-$this->magic['sso'])
		,new PHK_FileSpace($this->fspace,$this->magic['sto']
			,$this->magic['fto']-$this->magic['sto']));

	$this->ftree=PHK_Tree::create_from_edata($this->section('FTREE')
		,new PHK_FileSpace($this->fspace,$this->magic['fto']
			,$this->magic['sio']-$this->magic['fto']));

	$this->fspace->close(); // We keep the file open during init phase
	}
else
	{
	$this->ftree=PHK_Tree::create_empty();
	$this->stree=PHK_Tree::create_empty();
	}
}
catch (Exception $e)
	{
	throw new Exception('While initializing PHK proxy - '.$e->getMessage());
	}
//PHK_Util::trace("Ending init - path=$path");//TRACE
}

//---------

public function crc_check()
{
self::check_crc_buffer($this->fspace->read_block());
}

//---------------------------------
/**
* Inserts or clears a CRC in a memory buffer
*
* @static
* @param string $buffer	The original buffer whose CRC will be overwritten
* @param string $crc	If set, the CRC as an 8-char string (in hexadecimal). If
*	not set, we clear the CRC (set it to '00000000').
* @return string	The modified buffer
*/

public static function insert_crc($buffer,$crc)
{
return substr_replace($buffer,$crc,self::CRC_OFFSET,8);
}

//--------------------------------
/**
* Returns the CRC extracted from a memory buffer (not the computed one)
*
* @param string $buffer
* @return string The extracted 8-char hex CRC
*/

private static function get_crc($buffer)
{
return substr($buffer,self::CRC_OFFSET,8);
}

//---------------------------------
/**
* Computes a CRC from a given memory buffer
*
* As the given buffer already contains a CRC, we first clear it.
*
* @param string $buffer
* @return string The computed 8-char hex CRC
*/

private static function compute_crc($buffer)
{
return sprintf('%08x',crc32(self::insert_crc($buffer,'00000000')));
}

//---------------------------------
/**
* Checks a memory buffer's CRC
*
* The memory buffer is supposed to contain a whole PHK archive.
*
* No return value: if the CRC check fails, an exception is thrown.
*
* @param string $buffer
* @return void
* @throws Exception
*/

public static function check_crc_buffer($buffer)
{
if (self::compute_crc($buffer) !== self::get_crc($buffer))
	throw new Exception('Wrong CRC');
}

//---------------------------------
/**
* Computes and inserts a CRC in a memory buffer
*
* @param string $buffer
* @return string	The modified buffer
*/

public static function fix_crc($buffer)
{
return self::insert_crc($buffer,self::compute_crc($buffer));
}

//---------
/**
* Check if a given path contains a PHK package
*
* @param string $path	path to check (can be virtual)
* @return boolean
*/

public static function file_is_package($path)
{
if (filesize($path)< (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false;
if (($fp=fopen($path,'rb',false))===false) return false;
if (fseek($fp,self::MAGIC_STRING_OFFSET) != 0) return false;
if (($m=fread($fp,self::MAGIC_STRING_LEN))===false) return false;
fclose($fp);
return ($m===self::MAGIC_STRING);
}

//---------
/**
* Check if a data buffer contains a PHK package
*
* @param string $data	data buffer to check
* @return boolean
*/

public static function data_is_package($data)
{
if (strlen($data) < (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false;
return (substr($data,self::MAGIC_STRING_OFFSET,self::MAGIC_STRING_LEN)
	===self::MAGIC_STRING);
}

//---------------------------------
/**
* Extracts the value values out of a magic line buffer
*
* Note: A package is signed if (Signature offset != File size)
*
* @param string $buf A magic line content
* @return array An array containing the magic values
*/

public function get_magic_values()
{
$buf=$this->fspace->read_block(self::INTERP_LEN,self::MAGIC_LINE_LEN);

$fsize=(int)substr($buf,47,self::OFFSET_SIZE);
$sio=(int)substr($buf,121,self::OFFSET_SIZE);
$crc=null;
sscanf(substr($buf,136,8),'%08x',$crc);

$this->magic=array(
	'mv'  => trim(substr($buf,18,self::VERSION_SIZE)),	// Minimum required version
	'v'	  => trim(substr($buf,32,self::VERSION_SIZE)),	// Version
	'fs'  => $fsize,									// File size
	'po'  => (int)substr($buf,61,self::OFFSET_SIZE),	// Prolog offset
	'sso' => (int)substr($buf,76,self::OFFSET_SIZE),	// Serialized sections offset
	'sto' => (int)substr($buf,91,self::OFFSET_SIZE),	// Section table offset
	'fto' => (int)substr($buf,106,self::OFFSET_SIZE),	// File table offset
	'sio' => $sio,										// Signature offset
	'pco' => (int)substr($buf,148,self::OFFSET_SIZE),	// PHP code offset
	'pcs' => (int)substr($buf,163,self::OFFSET_SIZE),	// PHP code length
	'crc' => $crc,
	'signed' => ($sio != $fsize));
}

//---------------------------------

public function magic_field($name)
{
return $this->magic[$name];
}

//---------------------------------
/**
* Brings all data in memory
*
* After this function has run, we never access the package file any more.
*
* @see PHK_DC implements the data cache
*
* @return void
*/

private function cache_data()
{
$this->stree->walk('read');
$this->ftree->walk('read');
}

//---------------------------------
/**
* Clears the data cache
*
* @see PHK_DC implements the data cache
*
* @return void
*/

private function clear_cache()
{
$this->stree->walk('clear_cache');
$this->ftree->walk('clear_cache');
}

//---------------------------------

public function path_list()
{
return $this->ftree->path_list();
}

//---------------------------------

public function section_list()
{
return $this->stree->path_list();
}


//---------------------------------
/**
* Is this package digitally signed ?
*
* @return boolean
*/

public function signed()
{
return $this->magic['signed'];
}

//-----
/**
* Gets interpreter string
*
* If the interpreter is defined, returns it. Else, returns an empty string
*
* @return string
* @throws Exception if the interpreter string is invalid
*/

public function interp()
{
$block=$this->fspace->read_block(0,self::INTERP_LEN);

if ((($block{0}!='#')||($block{1}!='!')) && (($block{0}!='<')||($block{1}!='?')))
	throw new Exception('Invalid interpreter block');
return ($block{0}=='#') ? trim(substr($block,2)) : '';
}

//-----
/**
* Builds an interpreter block from an interpreter string
*
* Note: can be applied to a signed package as the signature ignores the
* interpreter block and the CRC.

* @param string $interp Interpreter to set or empty string to clear
* @return string Interpreter block (INTERP_LEN). Including trailing '\n'
*/

public static function interp_block($interp)
{
if (($interp!=='') && (strlen($interp) > (PHK_Proxy::INTERP_LEN-3)))
	throw new Exception('Length of interpreter string is limited to '
		.(PHK_Proxy::INTERP_LEN-3).' bytes');

// Keep '<?'.'php' or it will be translated when building the runtime code

if ($interp==='') return str_pad('<?'.'php',PHK_Proxy::INTERP_LEN-2).'?'.'>';
else return '#!'.str_pad($interp,PHK_Proxy::INTERP_LEN-3)."\n";
}

//-----
/**
* Inserts a new interpreter block in a file's content
*
* Allows a PHK user to change its interpreter string without
* having to use the PHK_Creator kit.
*
* Note: can be applied to a signed package as the signature ignores the
* interpreter block and the CRC.
*
* @param string $path PHK archive's path
* @param string $interp Interpreter string to set (empty to clear)
* @return string The modified buffer (the file is not overwritten)
*/

public static function set_buffer_interp($path,$interp='')
{
return self::fix_crc(substr_replace(PHK_Util::readfile($path)
	,self::interp_block($interp),0,PHK_Proxy::INTERP_LEN));
}

//-----
/**
* The version of the PHK_Creator tool this package was created from
*
* @return string Version
*/

public function version()
{
return $this->magic['v'];
}

//-----
/**
* Returns the $path property
*
* @return string
*/

public function path()
{
return $this->fspace->path();
}

//-----
/**
* Get a section's content
*
* @param string $name The section name
* @return string The section's content
* @throws Exception if section does not exist or cannot be read
*/

public function section($name)
{
try { $node=$this->stree->lookup_file($name); }
catch (Exception $e) { throw new Exception($name.': Unknown section'); }

try { return $node->read(); }
catch (Exception $e)
	{ throw new Exception($name.': Cannot read section - '.$e->getMessage()); }
}

//-----

public function ftree()
{
return $this->ftree;
}

//-----

public function stree()
{
return $this->stree;
}

//-----
/**
* Returns the $flags property
*
* @return integer
*/

public function flags()
{
return $this->flags;
}

//---------------------------------

public function display_packages()
{
$this->ftree->display_packages();
}

//---------------------------------
// Display the file tree

public function showfiles()
{
$this->ftree->display(true);
}

//----
} // End of class PHK
//=============================================================================
} // End of class_exists('PHK')
//=============================================================================
?>
<?php
//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Stream',false))
{
// <PLAIN_FILE> //---------------
/** Load the 'slow' backend */
require(dirname(__FILE__).'/PHK_Stream_Backend.php');
// </PLAIN_FILE> //---------------

/**
* The PHK stream wrapper
*
* Handles every file access to an 'phk://...' URI
*
* Note: Always catch exceptions before returning to PHP.
*/

class PHK_Stream extends PHK_Util
{

private $uri;

private $mnt;		// Mount point (string)
private $path;		// File path in PHK (string|null)
private $command;	// Command (string|null)
private $params;	// Command parameter (array|null)

private $data;	// File data (regular file) or dir content
private $size;	// Size of buffer or number of dir entries
private $position; // Byte position or position in array

private $raise_errors=true;

//---------------------------------
// Display a warning if they are allowed

private function raise_warning($msg)
{
if ($this->raise_errors) trigger_error("PHK: $msg",E_USER_WARNING);
}

//---------------------------------

public static function get_file($dir,$uri,$mnt,$command,$params,$path,$cache=null)
{
$cache_id=PHK_Cache::cache_id('node',$uri);
//PHK_Util::trace("Cache ID : <$cache_id>");//TRACE

if (is_null($data=PHK_Cache::get($cache_id)))	// Miss
	{
	$can_cache=true;
	
	if (is_null($data=($dir ?
		PHK_Stream_Backend::get_dir_data($mnt,$command,$params,$path)
		: PHK_Stream_Backend::get_file_data($mnt,$command,$params,$path
			,$can_cache)))) throw new Exception("$uri: File not found");

	if ($can_cache && (($cache===true) || (is_null($cache)
		&& PHK_MGR::cache_enabled($mnt,$command,$params,$path))))
			PHK_Cache::set($cache_id,$data);
	}

if ($dir && (!is_array($data))) throw new Exception('Not a directory');
if ((!$dir) && (!is_string($data))) throw new Exception('Not a regular file');

return $data;
}

//---------------------------------
// Open a file - only read mode is supported
// STREAM_USE_PATH is ignored
// Fast path: Yes (only when data is found in the cache)
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function stream_open($uri,$mode,$options,&$opened_path)
{
//echo "<br>Starting stream_open: uri=$uri\n";//TRACE

try
{
$this->uri=$uri;
$this->raise_errors=($options & STREAM_REPORT_ERRORS);
if ($options & STREAM_USE_PATH) $opened_path=$uri;

if (($mode!='r')&&($mode!='rb'))
	throw new Exception($mode.': unsupported mode (Read only)');

self::parse_uri($uri,$this->command,$this->params,$this->mnt,$this->path);

if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);

$this->data=self::get_file(false,$uri,$this->mnt,$this->command
	,$this->params,$this->path);

$this->size=strlen($this->data);
$this->position=0;
}
catch (Exception $e)
	{
	$msg=$uri.': Open error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
//PHK_Util::trace("Exiting stream_open: uri=$uri");//TRACE
return true;
}

//---------------------------------
// Read on an open file

public function stream_read($nb)
{
//echo "Starting stream_read: uri=".$this->uri." - nb=$nb - position="
//	.$this->position." size=".$this->size."\n";//TRACE

if ($this->position==$this->size) return false;
$max=$this->size-($pos=$this->position);
if ($nb > $max) $nb=$max;
$this->position+=$nb;

return substr($this->data,$pos,$nb);
}

//---------------------------------
// Are we at the end of an open file ?

public function stream_eof()
{
return ($this->position==$this->size);
}

//---------------------------------
// Return current position in an open stream

public function stream_tell()
{
return $this->position;
}

//---------------------------------
// Seek on an open file

public function stream_seek($offset,$whence)
{
//echo "Starting stream_seek: uri=".$this->uri." - offset=$nb - whence=$whence\n";//TRACE

switch($whence)
	{
	case SEEK_CUR: $this->position+=$offset; break;
	case SEEK_END: $this->position=$this->size+$offset; break;
	default: $this->position=$offset; break;
	}
if ($this->position > $this->size) $this->position=$this->size;
if ($this->position < 0) $this->position=0;
return true;
}

//---------------------------------
// Open a directory
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function dir_opendir($uri,$options)
{
try
{
$this->uri=$uri;
$this->raise_errors=($options & STREAM_REPORT_ERRORS);

self::parse_uri($uri,$this->command,$this->params,$this->mnt
	,$this->path);

if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);

$this->data=self::get_file(true,$uri,$this->mnt,$this->command
	,$this->params,$this->path);

$this->size=count($this->data);
$this->position=0;
}
catch (Exception $e)
	{
	$msg=$uri.': PHK opendir error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
return true;
}

//---------------------------------
// Get next directory entry

public function dir_readdir()
{
if ($this->position==$this->size) return false;
return $this->data[$this->position++];
}

//---------------------------------
// Set open directory index to 0

public function dir_rewinddir()
{
$this->position=0;
}

//---------------------------------
// Utility function called by stream_stat and url_stat

private static function stat_array($mode,$size,$mtime)
{
return array(
	'dev' => 0,
	'ino' => 0,
	'mode' => $mode,
	'nlink' => 1,
	'uid' => 0,
	'gid' => 0,
	'rdev' => -1,
	'size' => $size,
	'atime' => $mtime,
	'mtime' => $mtime,
	'ctime' => $mtime,
	'blksize' => 8192,
	'blocks' => 1);
}

//---------------------------------
// Stat an open file (fstat)

public function stream_stat()
{
return $this->url_stat($this->uri,0,true);
}

//---------------------------------
// Stat an open or closed path - PHP streams API
//
// url_stat does not throw exceptions. It must just return false.
//
// This method must not modify properties (except for parsing the URI),
// because it can be called on an open path.
//
// We must check the mount point validity because we can be called for an
// unmounted path. In this case, we must return false before searching the
// cache, or the behavior will be different when the data is in the cache
// or not. Note that we check for global commands before validating the mount
// point.

public function url_stat($uri,$flags,$fstat=false)
{
//PHK_Util::trace("Entering url_stat($uri,$flags,$fstat)";//TRACE

try
{
$this->raise_errors=!($flags & STREAM_URL_STAT_QUIET);

// If we are coming from stream_fstat(), the uri is already parsed.

if (!$fstat)
	{
	self::parse_uri($uri,$this->command,$this->params,$this->mnt
		,$this->path);

	if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt);
	}

$cache_id=PHK_Cache::cache_id('stat',$uri);
if (is_null($data=PHK_Cache::get($cache_id)))	// Miss - Slow path
	{
	//PHK_Util::trace("url_stat($uri): not found in cache";//TRACE
	try
		{
		$cache=true;
		$mode=$size=$mtime=null;
		PHK_Stream_Backend::get_stat_data($this->mnt,$this->command
			,$this->params,$this->path,$cache,$mode,$size,$mtime);
		$data=array($mode,$size,$mtime);
		}
	catch (Exception $e) // Mark entry as non-existent
		{
		//PHK_Util::trace("url_stat($uri): lookup failed");//TRACE
		$data='';
		}

	if ($cache && (!is_null($this->mnt)) && PHK_MGR::cache_enabled($this->mnt
		,$this->command,$this->params,$this->path))
		{
		PHK_Cache::set($cache_id,$data);
		}
	}

if (is_array($data))
	{
	list($mode,$size,$mtime)=$data;
	return self::stat_array($mode,$size,$mtime);
	}
else throw new Exception('File not found');	// Negative hit
}
catch (Exception $e)
	{
	$msg=$uri.': PHK Stat error - '.$e->getMessage();
	$this->raise_warning($msg);
	return false;
	}
}

//---------------------------------
/**
* Parses an URI and splits it into four sub-parts : mount point, command name,
* command parameters, and path. Each of these components is optional.
*
* URI syntax: phk://[<mnt>[/path]][?command[&par=val&...]]
*
* On return, if no command: command=params=null
* Global command: phk://?command[&par=val&...] => path=mnt=null
* mnt=null => global command
*
* Test cases :
* phk://   Error
* phk://mnt1   mnt=mnt1, path='', command=params=null
* phk://mnt1/p1/p2	  mnt=mnt1, path=p1/p2, command=params=null
* phk://mnt1/p1/p2?cmd&par1=2&par2=3   mnt=mnt1, path=p1/p2, command=cmd,
*	  params=array(par1 => 2, par2 => 3)
* phk://?gcmd  mnt=path=null, command=gcmd, params=null
*
* @param string $uri
* @param string|null $command Return value
* @param array|null $params Return value
* @param string|null $mnt Return value - Null only if global command
* @param string|null $path Return value - Null only if global command
* @return void
* @throws Exception on invalid syntax
*/

public static function parse_uri($uri,&$command,&$params,&$mnt,&$path)
{
if (! PHK_Mgr::is_a_phk_uri($uri=str_replace('\\','/',$orig_uri=$uri)))
	throw new Exception('Not a PHK URI');
$uri=substr($uri,6);	// Remove 'phk://'

if (($pos=strpos($uri,'?'))!==false)	// If the uri contains a command
	{
	$cmd=PHK_Util::substr($uri,$pos+1);
	$uri=substr($uri,0,$pos);
	if (($pos=strpos($cmd,'&'))!==false)	// params present
		{
		$command=substr($cmd,0,$pos);
		parse_str(PHK_Util::substr($cmd,$pos+1),$params); // Get parameters
		}
	else $command=$cmd;
	if ($command=='') throw new Exception('Empty command');
	}

$uri=trim($uri,'/');	// Suppress leading and trailing '/'
if ($uri!='') // Not a global command
	{
	$a=explode('/',$uri,2);	//-- Separate mnt and path
	$mnt=$a[0];
	$path=isset($a[1]) ? $a[1] : '';
	}

if (is_null($command) && is_null($mnt)) throw new Exception('Empty URI');
}

//---------------------------------
} // End of class PHK_Stream
//=============================================================================
// Register the PHK wrapper

stream_wrapper_register('phk','PHK_Stream');

//=============================================================================
} // End of class_exists('PHK_Stream')
//=============================================================================
?>
<?php
//=============================================================================
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Stream_Backend',false))
{
//=============================================================================
/**
* The 'slow' backend to PHK_Stream
*
* This class is called when PHK_Stream cannot retrieve the information it needs
* from the cache or for uncacheable information.
*
* Note (30-NOV-2007): As long as the extension does not trap exceptions
* correctly, we trap them here and return null instead.
*/

class PHK_Stream_Backend
{

/** @var string		Used as temp storage by string_include() */

private static $tmp_data=null;

//---------------------------------
// Returns pseudo-file data string.
// If a command does not want to be cached, it sets $cache to false.
// stat() calls are used mainly for file existence/type. Size is less
// important.

private static function command_open_or_stat($stat_flag,$mnt,$command,$params
	,$path,&$cache)
{
$cache=true; // Default

try
{
if (is_null($mnt))	// Global command
	{
	switch($command)
		{
		case 'test':
			return "Test line 1/3\nTest line2/3\nTest line 3/3\n";
			break;

		case 'tmp':	// Special: Used by PHK::string_include();
			$cache=false;
			return self::$tmp_data;
			break;

		default:
			throw new Exception($command.': Unknown global command');
		}
	}
else // Slow path
	{
	$proxy=PHK_Mgr::proxy($mnt);

	switch ($command)
		{
		// These commands :
		//	- go to the proxy
		//	- are cached
		//	- take a mandatory 'name' argument and send it to the method
		//	- take the data returned by the method

		case 'section':
 		case 'magic_field':
			if (!isset($params['name']))
				throw new Exception($command
					.': command needs this argument: name');
			return $proxy->$command($params['name']);

		// These commands :
		//	- go to the proxy
		//	- are cached
		//	- serialize the data returned by the method

		case 'path_list':
		case 'section_list':
			return serialize($proxy->$command());

		default:
			throw new Exception($command.': Unknown command');
		}
	}
}
catch (Exception $e)
	{
	throw new Exception($command.': Error during command execution - '
		.$e->getMessage());
	}
}

//---------------------------------
// Segfault in extension if this function throws an exception. As long as
// this bug is not corrected, trap the exception before returning to PHK_Stream

public static function get_file_data($mnt,$command,$params,$path,&$cache)
{
$cache=true;

try
{
if (is_null($command))
	{
	$node=PHK_Mgr::proxy($mnt)->ftree()->lookup_file($path,false);
	if (is_null($node)) return null;
	return $node->read();
	}
else
	{
	return self::command_open_or_stat(false,$mnt,$command,$params,$path,$cache);
	}
}
catch (Exception $e) { return null; }
}

//---------------------------------
// Must accept the same parameters as get_file_data()

public static function get_dir_data($mnt,$command,$params,$path)
{
try
{
if (!is_null($command)) return null;

$node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path,false);
if (is_null($node)) return null;
return $node->getdir();
}
catch (Exception $e) { return null; }
}

//---------------------------------

public static function get_stat_data($mnt,$command,$params,$path,$cache
	,&$mode,&$size,&$mtime)
{
if (!is_null($command))
	{
	$mode=0100444;	// Pseudo regular file
	// Throws exception if command invalid or no target
	$size=strlen(self::command_open_or_stat(true,$mnt,$command,$params
		,$path,$cache));
	}
else
	{
	$node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path);

	$mode=$node->mode();
	$size=$node->size();
	}
$mtime=(is_null($mnt) ? time() : PHK_Mgr::instance($mnt)->mtime());
}

//----
// Undocumented
// Applies php_strip_whitespace() to a string

public static function _strip_string($str)
{
if (getenv('PHK_NO_STRIP')!==false) return $str;

$save=self::$tmp_data;
self::$tmp_data=$str;
$res=php_strip_whitespace('phk://?tmp');
self::$tmp_data=$save;
return $res;
}

//----
// Undocumented
// Include a string as if it was in a source file

public static function _include_string($str)
{
$save=self::$tmp_data;
self::$tmp_data=$str;
$res=require('phk://?tmp');
self::$tmp_data=$save;
return $res;
}

} // End of class PHK_Stream_Backend
//=============================================================================
} // End of class_exists('PHK_Stream_Backend')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TDir class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TDir',false))
{
//============================================================================

class PHK_TDir extends PHK_TNode
{

private $children; // array of basenames

//---

public function type() { return 'dir'; }
public function mode() { return 040555; }
public function size() { return count($this->children); }
public function get_needed_extensions() {}

//---

public function display($html,$link)
{
$path=$this->path;
if ($path=='') $path='/';

if ($html) echo '<tr><td nowrap colspan=4>&nbsp;<b><i>'.$path
		.'</i></b></td></tr>';
else echo "D $path\n";
}

//---

public function getdir()
{
return $this->children;
}

//---

public function dump($base)
{
$path=$base.$this->path;
if (mkdir($path)===false) throw new Exception($path.': cannot create directory');
}

//---

public function import($edata)
{
$this->children=explode(';',parent::import($edata));
}

//---

public function __construct($path,$tree)
{
parent::__construct($path,$tree);

$this->children=array();
}

//---

public function subpath($name)
{
return $this->path.'/'.$name;
}

// <CREATOR> //---------------

public function add_child($name)
{
if (array_search($name,$this->children)===false) $this->children[]=$name;
}

//---

public function remove_child($name)
{
if (($key=array_search($name,$this->children))===false)
	unset ($this->children[$key]);
}

//---

public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map)
{
return $this->tnode_export(implode(';',$this->children));
}

// </CREATOR> //---------------

} // End of class PHK_TDir
//-------------------------
} // End of class_exists('PHK_TDir')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TFile class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TFile',false))
{
//============================================================================

class PHK_TFile extends PHK_TNode // Regular file
{

private $dc;	// Data container

//---

public function type() { return 'file'; }
public function mode() { return 0100444; }

//---
// If a method is unknown, forward to the DC (poor man's multiple inheritance :)

public function __call($method,$args)
{
try { return call_user_func_array(array($this->dc,$method),$args); }
catch (Exception $e)
	{ throw new Exception($this->path.': '.$e->getMessage()); }
}

//---
// Must be defined as __call() is tried after PHK_TNode methods, and read()
// has a default in PHK_TNode.

public function read()
{
return $this->dc->read();
}

//---

public function flag_string()
{
$string=parent::flag_string().','.$this->dc->flag_string();
$string=trim($string,',');

return $string;
}

//---

public function display_package($html)
{
if ($this->flags & self::TN_PKG) $this->display($html);
}

//---
// In HTML, create an hyperlink only for files, not for sections

public function display($html,$link=false)
{
$flag_string=$this->flag_string();
$path=$this->path;

if ($html)
	{
	if ($this->flags & self::TN_PKG) $link=false;
	$field= ($link ? '<a href="'.PHK::subpath_url('/view/'
		.trim($path,'/')).'">'.$path.'</a>' : $path);
	echo '<tr><td nowrap>F</td><td nowrap>'.$field.'</td><td nowrap>'
		.$this->size().'</td><td nowrap>'.$flag_string.'</td></tr>';
	}
else
	{
	if ($flag_string!='') $flag_string = ' ('.$flag_string.')';
	echo 'F '.str_pad($this->size(),11).' '.$path.$flag_string."\n";
	}
}

//---

public function dump($base)
{
$path=$base.$this->path;
if (file_put_contents($path,$this->read())===false)
	throw new Exception($path.': cannot dump file');
}

//---

public function __construct($path,$tree)
{
parent::__construct($path,$tree);

$this->dc=new PHK_DC();
$this->dc->set_fspace($tree->fspace);
}

//---

public function import($edata)
{
$this->dc->import(parent::import($edata));
}

//---

public function set_flags($flags)
{
parent::set_flags($flags);
$this->dc->set_flags($flags);
}

//---
// <CREATOR> //---------------

// If PHK Package, move required extensions up
// Don't umount the package, it will be used later.

public function get_needed_extensions(PHK_Creator $phk
	,PHK_ItemLister $item_lister)
{
if (PHK::data_is_package($this->read()))
	{
	$mnt=require($phk->uri($this->path));
	$source_phk=PHK_Mgr::instance($mnt);
	if (!is_null($elist=$source_phk->option('required_extensions')))
		{
		foreach ($elist as $ext) $item_lister->add($ext,true);
		}
	
	}

return $this->dc->get_needed_extensions($phk,$item_lister);	// Now, ask DC
}

//---------------
// Process PHP scripts (Automap and source stripping)
// Register Automap symbols only if $map is non-null
// Distinction between files and sections: for files, $map is not null

public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map)
{
$path=$this->path;

PHK_Util::msg('Processing '.$path);

if (!is_null($map)) // This is a real file
	{
	if (getenv('PHK_NO_STRIP')!==false)	$this->flags &= ~self::TN_STRIP_SOURCE;

	if (PHK::data_is_package($this->read()))	//-- Package ?
		{
		//-- Set 'package' flag, clear 'strip source', and keep autoload
		$this->flags |= self::TN_PKG;
		$this->flags &= ~self::TN_STRIP_SOURCE;
		}

	//-- If it is a sub-package and autoload is true, merge its symbols
	//-- in the current map, but with different values.

	if ($this->flags & self::TN_PKG)
		{
		if (!($this->flags & self::TN_NO_AUTOLOAD))
			{
			PHK_Util::msg("	Merging Automap symbols");
			$map->register_package($phk->uri($path),$path);
			}
		}
	elseif ($phk->is_php_source_path($path))
		{
		//--- Register in automap
		if (!($this->flags & self::TN_NO_AUTOLOAD))
			{
			PHK_Util::msg("	Registering Automap symbols");
			$map->register_script($phk->uri($path),$path);
			}

		//--- Strip script files

		if ($this->flags & self::TN_STRIP_SOURCE)
			{
			PHK_Util::msg("	Stripping script");

			// We must save the Automap comments from php_strip_whitespace()
			// because we must be able to rebuild the Automap (when upgrading
			// the package, for instance).
			// If there are Automap comments in the file, we put them in a PHP
			// block after the stripped script.

			$comment_buf='';
			foreach(file($phk->uri($path)) as $line)
				{
				$line=trim($line);
				if (ereg(Automap_Creator::AUTOMAP_COMMENT,$line,$regs)===false)
					continue;
				// Warning: keep '//' and '<Automap> separate below or it will be
				// detected as an Automap comment when processing this file.
				$comment_buf .= '//'.' <Automap>:'.$regs[1].$regs[2]."\n";
				}
			// Keep '<?'.'php' or it will be translated when building the
			// runtime code
			if ($comment_buf!='') $comment_buf="<?"."php\n".$comment_buf."?".">";
			$this->set_data(php_strip_whitespace($phk->uri($path)).$comment_buf);
			}
		}
	else
		{
		$this->flags = ($this->flags & ~self::TN_STRIP_SOURCE) 
			| self::TN_NO_AUTOLOAD;
		}
	}

return $this->tnode_export($this->dc->export($phk,$stacker));
}

// </CREATOR> //---------------

} // End of class PHK_TFile
//-------------------------
} // End of class_exists('PHK_TFile')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_TNode_Backend class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_TNode',false))
{
//============================================================================

abstract class PHK_TNode		// Base class - never instantiated
{
protected $flags;

protected $path;

protected $tree=null;	// Back pointer to the tree

//---- Flags

const TN_DC_FLAG_MASK=PHK_DC::COMPRESS_TYPE; // Low bits reserved for compr type

const TN_STRIP_SOURCE=8;	// Strip source files
const TN_NO_AUTOLOAD=16;	// Don't register symbols in Automap
const TN_PKG=32;			// File is a PHK package

//---

abstract public function type(); // returns type string

//---
// Default: do nothing

public function display_package($html) {}

//---

public function is_package()
{
return ($this->flags & self::TN_PKG);
}

//---
// Default: error if the method is not overloaded

public function getdir()
{
throw new Exception($this->path.': Cannot getdir() on a '.$this->type());
}

//---
// Default: error

public function read()
{
throw new Exception($this->path.': Cannot read() a '.$this->type());
}

//---

protected function flag_string()
{
$flag_string='';
if ($this->flags & self::TN_PKG) $flag_string .=',package';
else
	{
	if ($this->flags & self::TN_STRIP_SOURCE) $flag_string .=',strip';
	if ($this->flags & self::TN_NO_AUTOLOAD) $flag_string .=',no_autoload';
	}

return $flag_string;
}

//---

// Cannot call set_flags() here, as it will call the derived
// method when it is defined (as in PHK_TFile)

protected function __construct($path,$tree)
{
$this->path=$path;
$this->tree=$tree;
$this->flags=0;
}

//---

protected function import($edata)
{
list($this->flags)=array_values(unpack('va',$edata));
return substr($edata,2);
}

// <CREATOR> //---------------

abstract public function export(PHK_Creator $phk,PHK_DataStacker $stacker,$map);

//---

protected function tnode_export($derived_edata)
{
return pack('v',$this->flags).$derived_edata;
}

//---

public function set_flags($flags)
{
$this->flags=$flags;
}

//---

private static function compute_flags(array $modifiers,$flags=0)
{
foreach($modifiers as $name => $value)
	{
	$name=strtolower($name);
	if ($name==='autoload')
		{
		if ($value==='true') $flags &= ~self::TN_NO_AUTOLOAD;
		else $flags |= self::TN_NO_AUTOLOAD;
		}
	elseif ($name==='strip')
		{
		if ($value==='true') $flags |= self::TN_STRIP_SOURCE;
		else $flags &= ~self::TN_STRIP_SOURCE;
		}
	elseif ($name==='compress')
		{
		if ($value=='none') $c=PHK_DC::COMPRESS_NONE;
		elseif ($value=='gzip') $c=PHK_DC::COMPRESS_GZIP;
		elseif ($value=='bzip2') $c=PHK_DC::COMPRESS_BZIP2;
		else throw new Exception($value.': Unknown compression method');
		$flags = ($flags & ~PHK_DC::COMPRESS_TYPE) | $c;
		}
	else throw new Exception($name.': Unknown modifier');
	}
return $flags;
}

//---

public function modify($modifiers)
{
$this->set_flags(self::compute_flags($modifiers,$this->flags));
}

// </CREATOR> //---------------

//---
} // End of class PHK_TNode
//-------------------------
} // End of class_exists('PHK_TNode')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Tree class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//============================================================================

if (!class_exists('PHK_Tree',false))
{
// <PLAIN_FILE> //---------------
require(dirname(__FILE__).'/PHK.php');
require(dirname(__FILE__).'/PHK_DC.php');
require(dirname(__FILE__).'/PHK_DataStacker.php');
require(dirname(__FILE__).'/PHK_TNode.php');
require(dirname(__FILE__).'/PHK_TDir.php');
require(dirname(__FILE__).'/PHK_TFile.php');
// </PLAIN_FILE> //---------------

//============================================================================

class PHK_Tree
{

public $fspace;		// Associated filespace

private $edata; // Exported data. Always contains a key for every node, even
				// in creator mode.

private $nodes;	// Tree nodes (key=path, value=PHK_TNode object). Contains
				// only the unserialized nodes. In creator mode, contains
				// every node.

private static $eclasses=array( 'D' => 'PHK_TDir', 'F' => 'PHK_TFile');

//---
// Create a tree from the edata stored in the PHK archive

public static function create_from_edata($serial_edata
	,PHK_FileSpace $fspace)
{
$tree=new self($fspace);

$tree->edata=unserialize($serial_edata);

return $tree;
}

//---

public function path_list()
{
return array_keys($this->edata);
}

//---

public function path_exists($rpath)
{
return array_key_exists($rpath,$this->edata);
}

//---

public function count()
{
return count($this->edata);
}

//---

public function walk($method)
{
$args=func_get_args();
array_shift($args);

foreach($this->path_list() as $path)
	{
	$node=$this->rlookup($path);
	call_user_func_array(array($node,$method),$args);
	}
}

//---
// Reduce the path to a canonical path - suppress '..' and '.' components
// Root=''
// Non-root: /xxx[/yyy...]

private function realpath($path)
{
$a=explode('/',trim($path,'/'));
$ra=array();
foreach($a as $comp)
	{
	switch($comp)
		{
		case '':
		case '.':
			break;
		case '..':
			if (count($ra)) array_pop($ra);
			break;
		default:
			$ra[]=$comp;
		}
	}
if (!count($ra)) return '';
return '/'.implode('/',$ra);
}

//---

public function lookup($path,$exception_flag=true)
{
return $this->rlookup(self::realpath($path),$exception_flag);
}

//---
// Lookup without path canonicalization - faster if self::realpath() has
// already been called

private function rlookup($path,$exception_flag=true)
{
if (array_key_exists($path,$this->edata))
	{
	if (!array_key_exists($path,$this->nodes))
		{
		$edata=$this->edata[$path];
		$class=self::$eclasses[$edata{0}];
		$node=$this->nodes[$path]=new $class($path,$this);
		$node->import(substr($edata,1));
		}
	return $this->nodes[$path];
	}

//echo "Lookup failed : <$path> <$rpath>\n";//TRACE
//print_r(array_keys($this->nodes));//TRACE
	
if ($exception_flag) throw new Exception($path.': path not found');
else return null;
}

//---

public function lookup_file($path,$exception_flag=true)
{
$f=$this->lookup($path,$exception_flag);

if ((!is_null($f)) && (!($f instanceof PHK_TFile)))
	{
	if ($exception_flag) throw new Exception($path.': No such file');
	else return null;
	}

return $f;
}

//---

public function display_header($html)
{
if ($html) echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 '
	.'cellspacing=0 style="border-collapse: collapse"><tr><th>T</th>'
	.'<th>Name</th><th>Size</th><th>Flags</th></tr>';
}

//---

public function display_footer($html)
{
if ($html) echo '</table>';
}

//---
// $link = wether we display an hyperlink on file names (in HTML mode)

public function display($link)
{
$html=PHK_Util::is_web();

$this->display_header($html);
$this->walk('display',$html,$link);
$this->display_footer($html);
}

//---

public function display_packages()
{
$html=PHK_Util::is_web();

ob_start();
$this->walk('display_package',$html);
$data=ob_get_clean();

if ($data!=='')
	{
	$this->display_header($html);
	$this->walk('display_package',$html);
	$this->display_footer($html);
	}
}

//---

public function dump($base)
{
$this->walk('dump',$base);
}

//---
// Same as dirname() function except:
// - Always use '/' as separator
// - Returns '' for 1st level paths ('/xxx')

public static function dir_base_name($path)
{
$dir=ereg_replace('/[^/]*$','',$path);
$base=ereg_replace('^.*/','',$path);
return array($dir,$base);
}

//---
// called from create_empty() or create_from_edata() only => private

private function __construct($fspace)
{
$this->fspace=$fspace;
$this->nodes=array();
}

// <CREATOR> //---------------

// Check for a list of forbidden chars in node names. Especially important for
// '#*' which can create conflicts in mount points (for subpackages), and ';'
// which is used as separator when exporting the list of dir children.

public function add_node($path,$node)
{
$path=self::realpath($path);

if (strpbrk($path,'#*?!&~"|`\^@[]={}$;,<>')!==false)
	throw new Exception("$path: Invalid characters in path");

if ($path != '')
	{
	list($dir,$basename)=self::dir_base_name($path);

	$dirnode=$this->rlookup($dir,false);
	if (is_null($dirnode)) $dirnode=$this->mkdir($dir);

	if (!($dirnode instanceof PHK_TDir))
		throw new Exception("Cannot add node over a non-directory node ($dir)");

	$dirnode->add_child($basename);
	}

// Add the node

$this->edata[$path]=null;
$this->nodes[$path]=$node;
}

//---
// Create an empty tree

public static function create_empty()
{
$tree=new self(null);
$tree->add_node('',new PHK_TDir('',$tree));

return $tree;
}

//---

public function export(PHK_Creator $phk,$map=null)
{
$edata=array();
$stacker=new PHK_DataStacker();

foreach($this->nodes as $path => $node)
	{
	$edata[$path]=array_search(get_class($node),self::$eclasses)
		.$node->export($phk,$stacker,$map);
	}
ksort($edata); // To display files in the right order

return array(serialize($edata),$stacker->data);
}

//---

public function add_file_tree($target_path,$source,$modifiers)
{
$target_path=self::realpath($target_path);
$this->remove($target_path);

// Don't use filetype() here because we want to follow symbolic links

if (!file_exists($source))
	{
	echo "$source : File does not exist - Ignored";
	}
elseif (is_file($source))
	{
	$this->mkfile($target_path,PHK_Util::readfile($source),$modifiers);
	}
elseif (is_dir($source))
	{
	$node=$this->mkdir($target_path,$modifiers);

	foreach(PHK_Util::scandir($source) as $subname)
		$this->add_file_tree($node->subpath($subname)
			,$source.DIRECTORY_SEPARATOR.$subname,$modifiers);
	return;
	}
else echo "$source : Unsupported file type (".filetype($source).") - Ignored\n";
}

//---

public function merge_file_tree($target_dir,$source_dir,$modifiers)
{
if (!is_dir($source_dir))
	throw new Exception($source_dir.': Should be an existing directory');

$target_dir=self::realpath($target_dir);
$tnode=$this->mkdir($target_dir,$modifiers);

foreach(PHK_Util::scandir($source_dir) as $subname)
	{
	$source=$source_dir.DIRECTORY_SEPARATOR.$subname;
	$target=$tnode->subpath($subname);
	if (is_file($source))
		{
		$this->mkfile($target,PHK_Util::readfile($source),$modifiers);
		}
	elseif (is_dir($source))
		{
		$this->merge_file_tree($target,$source,$modifiers);
		}
	else echo "$source : Unsupported file type (".filetype($source).") - Ignored\n";
	}
}

//---

private function get_subtree($path)
{
$rpath=self::realpath($path);

if ($rpath=='') return $this->path_list();

$result=array();
$prefix=$rpath.'/';
$len=strlen($prefix);
foreach($this->path_list() as $p)
	{
	if (($p==$rpath)||((strlen($p)>=$len)&&(substr($p,0,$len)==$prefix)))
		$result[]=$p;
	}
return $result;
}

//---

public function modify($path,$modifiers)
{
$path=self::realpath($path);

foreach ($this->get_subtree($path) as $subpath)
	{
	$this->lookup($subpath)->modify($modifiers);
	}
}

//---
// If parent dir does not exist, add_node() will call us back to create it,
// and it goes on recursively until the root node is reached.

public function mkdir($path,$modifiers=array())
{
$rpath=self::realpath($path);

if (is_null($node=$this->rlookup($rpath,false))) // If node does not exist
	{
	$node=new PHK_TDir($path,$this);
	$node->modify($modifiers);
	$this->add_node($path,$node);
	}
else // If node already exists, check that it is a directory
	{
	if (($type=$node->type())!='dir')
		throw new Exception("mkdir: $path is already a $type");
	}
return $node;
}

//---

public function mkfile($path,$data,$modifiers=array())
{
$rpath=self::realpath($path);

$node=new PHK_TFile($rpath,$this);
$node->set_data($data);
$node->modify($modifiers);

$this->add_node($rpath,$node);

return $node;
}

//---

public function remove($path)
{
$rpath=self::realpath($path);
if ($rpath=='') throw new Exception('Cannot remove root directory');

if (is_null($this->rlookup($rpath,false))) return; // Path does not exist

foreach($this->get_subtree($rpath) as $p)
	{
	unset($this->nodes[$p]);
	unset($this->edata[$p]);
	}

list($dir,$name)=self::dir_base_name($rpath);
$this->rlookup($dir)->remove_child($name);
}

// </CREATOR> //---------------

} // End of class PHK_Tree
//-------------------------
} // End of class_exists('PHK_Tree')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Util class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Util',false))
{
//============================================================================

class PHK_Util	// Static only
{
//-----

private static $verbose=true;

public static function msg($msg)
{
if (self::$verbose) echo $msg."\n";
}

//-----

public static function var_type($var)
{
return is_object($var) ? 'object '.get_class($var) : gettype($var);
}

//-----

public static function is_web()
{
return (php_sapi_name()!='cli');
}

//----

public static function is_windows()
{
return (substr(PHP_OS, 0, 3) == 'WIN');
}

//----

public static function file_suffix($filename)
{
$dotpos=strrpos($filename,'.');
if ($dotpos===false) return '';

return strtolower(substr($filename,$dotpos+1));
}

//---------
// Combines a base directory and a relative path. If the base directory is
// '.', returns the relative part without modification
// Use '/' separator on stream-wrapper URIs

public static function combine_path($dir,$rpath)
{
if ($dir=='.' || $dir=='') return $rpath;
$rpath=trim($rpath,'/');
$rpath=trim($rpath,'\\');

$separ=(strpos($dir,':')!==false) ? '/' : DIRECTORY_SEPARATOR;
if (($dir==='/') || ($dir==='\\')) $separ='';
else
	{
	$c=substr($dir,-1,1);
	if (($c==='/') || ($c=='\\')) $dir=rtrim($dir,$c);
	}

return $dir.$separ.$rpath;
}

//---------
// Adapted from PEAR

public static function load_extension($ext)
{
if (extension_loaded($ext)) return;

if (PHP_OS == 'AIX') $suffix = 'a';
else $suffix = PHP_SHLIB_SUFFIX;

@dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix);

if (!extension_loaded($ext)) throw new Exception("$ext: Cannot load extension");
}

//---------
// Require several extensions. Allows to list every extensions that are not
// present.

public static function load_extensions($ext_list)
{
$failed_ext=array();
foreach($ext_list as $ext)
	{
	try { self::load_extension($ext); }
	catch (Exception $e) { $failed_ext[]=$ext; }
	}
if (count($failed_ext))
	throw new Exception('Cannot load the following required extension(s): '
		.implode(' ',$failed_ext));
}

//---------
// Replacement for substr()
// Difference : returns '' instead of false (when index out of range)

public static function substr($buf,$position,$len=NULL)
{
$str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len);
if ($str===false) $str='';
return $str;
}

//---------
// This function must be called before every file access
// In PHP 6, magic_quotes_runtime is suppressed and set_magic_quotes_runtime()
// does not exist any more.

private static $mqr_exists=null;
private static $mqr_level=0;
private static $mqr_save;

public static function disable_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

if (self::$mqr_level==0)
	{
	self::$mqr_save=get_magic_quotes_runtime();
	set_magic_quotes_runtime(0);
	}
self::$mqr_level++;
}

//---------
// This function must be called after every file access

public static function restore_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

self::$mqr_level--;
if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save);
}

//---------
// Converts a timestamp to a string
// @ to suppress warnings about system timezone

public static function timestring($time=null)
{
if ($time=='unlimited') return $time;
if (is_null($time)) $time=time();
return @strftime('%d-%b-%Y %H:%M %z',$time);
}

//---------
// HTTP mode only: Compute the base URL we were called with

public static function http_base_url()
{
if (!self::is_web()) return '';

if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF'];

$phpself=$_SERVER['PHP_SELF'];
$slen=strlen($phpself);

$pathinfo=$_SERVER['PATH_INFO'];
$ilen=strlen($pathinfo);

// Remove PATH_INFO from PHP_SELF if it is at the end. Don't know
// which config does this, but some servers put it, some don't.

if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo))
	$phpself=substr($phpself,0,$slen-$ilen);

return $phpself;
}

//---------------------------------
// Sends an HTTP 301 redirection

public static function http_301_redirect($path)
{
header('Location: http://'.$_SERVER['HTTP_HOST'].self::http_base_url().$path);
header('HTTP/1.1 301 Moved Permanently');
exit(0);
}

//---------------------------------
// Sends an HTTP 404 failure

public static function http_404_fail()
{
header("HTTP/1.0 404 Not Found");
exit(1);
}

//---------------------------------
// Sends an HTTP 403 failure

public static function http_403_fail()
{
header("HTTP/1.0 403 Forbidden");
exit(1);
}

//-----

public static function bool2str($cond)
{
return $cond ? 'Yes' : 'No';
}

//---------

public static function readfile($path)
{
if (($data=@file_get_contents($path))===false)
	throw new Exception($path.': Cannot get file content');
return $data;
}

//---------
// Throws exceptions and removes '.' and '..'

public static function scandir($path)
{
if (($subnames=scandir($path))===false)
	throw new Exception($path.': Cannot read directory');

$a=array();
foreach($subnames as $f)
	if (($f!='.') && ($f!='..')) $a[]=$f;

return $a;
}

//---------

public static function trace($msg)
{
if (($tfile=getenv('PHK_TRACE_FILE')) !== false)
        {
        // Append message to trace file
        if (($fp=fopen($tfile,'a'))===false) throw new Exception($tfile.': Cannot open trace file');
        fwrite($fp,self::timestring().': '.$msg."\n");
        fclose($fp);
        }
}

//---------
// $start=microtime() float

public static function delta_ms($start)
{
$delta=microtime(true)-$start;

return round($delta*1000,2).' ms';
}

//---------

public static function mk_array($data)
{
if (is_null($data)) return array();
if (!is_array($data)) $data=array($data);
return $data;
}

//---------

public static function display_slow_path()
{
if (getenv('PHK_DEBUG_SLOW_PATH')!==false)
	{
	$html=PHK_Util::is_web();

	if (isset($GLOBALS['__PHK_SLOW_PATH']))
		$data="Slow path entered at:\n".$GLOBALS['__PHK_SLOW_PATH'];
	else $data="Fast path OK\n";

	PHK::info_section($html,'Fast path result');

	if ($html) echo "<pre>";
	echo $data;
	if ($html) echo "/<pre>";
	}
}

//---------

public static function slow_path()
{
if ((getenv('PHK_DEBUG_SLOW_PATH')!==false)
	&& (!isset($GLOBALS['__PHK_SLOW_PATH'])))
	{
	$e=new Exception();
	$GLOBALS['__PHK_SLOW_PATH']=$e->getTraceAsString();
	}
}

//-----
/**
* Sends an Exception with a message starting with 'Format error'
*
* @param string $msg Message to send
* @return void
* @throws Exception
*/

public static function format_error($msg)
{
throw new Exception('Format error: '.$msg);
}

//---------------------------------
// Utility functions called by PHK_Mgr. When using the accelerator, this
// data is persistent. So, retrieving it to populate the cache can be done
// in PHP.

public static function get_min_version($mnt,$caching)
{
return PHK_Stream::get_file(false,PHK_Mgr::command_uri($mnt
	,'magic_field&name=mv'),$mnt,'magic_field',array('name' => 'mv'),''
	,$caching);
}

public static function get_options($mnt,$caching)
{
return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt
	,'OPTIONS'),$mnt,'section',array('name' => 'OPTIONS'),'',$caching));
}

public static function get_build_info($mnt,$caching)
{
return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt
	,'BUILD_INFO'),$mnt,'section',array('name' => 'BUILD_INFO'),'',$caching));
}

//---------------------------------

public static function call_method($object,$method,$args)
{
return call_user_func_array(array($object,$method),$args);
}

//---------------------------------

public static function run_webinfo($phk)
{
$phk->proxy()->crc_check();	//-- check CRC before running webinfo
$phkw=new PHK_Webinfo($phk);
$phkw->run();
}

//---------------------------------

public static function atomic_write($path,$data)
{
$tmpf=tempnam(dirname($path),'tmp_');

if (file_put_contents($tmpf,$data)!=strlen($data))
	throw new Exception($tmpf.": Cannot write");

// Windows does not support renaming to an existing file (looses atomicity)

if (PHK_Util::is_windows()) @unlink($path);

if (!rename($tmpf,$path))
	{
	unlink($tmpf);
	throw new Exception($path,'Cannot replace file');
	}
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

public static function path_unique_id($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//---------
} // End of class PHK_Util
//=============================================================================
} // End of class_exists('PHK_Util')
//=============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* The PHK_Webinfo class
*
* @copyright Francois Laupretre <phk@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category PHK
* @package PHK
*/
//=============================================================================

if (!class_exists('PHK_Webinfo',false))
{
//============================================================================

class PHK_Webinfo
{
const VERSION='0.2.5';

private $PHK;	// Associated PHK instance

private $cmd_titles=array(
	'info' => 'Home',
	'techinfo' => 'Technical information',
	'showmap' => 'Automap',
	'showfiles' => 'Files',
	'test' => 'Unit tests');

//----

public function __construct($phk)
{
$this->PHK=$phk;

PHK_Mgr::set_cache(false); // Don't cache anything in webinfo mode
}

//----

private static function display_tab($url,$name)
{
echo '<li id="'.$name.'"><a href="'.PHK::subpath_url($url)
	.'"><span>'.$name.'</span></a></li>';
}

//----

private function header($title=null)
{
if (is_null($name=$this->PHK->option('name')))
	$name=basename($this->PHK->path());
$win_title=(is_null($title) ? $name : "$name - $title");

echo '<head>'
	."<title>$win_title</title>"
	.'<link href="'.PHK::subpath_url('/php_section/STATIC/tabs/tabs.css.php')
	.'" rel="stylesheet" type="text/css">'
	."<style type=text/css><!--\n"
	."a,a:active,a:link { color: blue; text-decoration: none; }\n"
	."a:hover { color: blue; text-decoration: underline; }\n"
	.'--></style>'
	."</head>\n";

echo '<table width=100% border=0 cellpadding=0 cellspacing=0>';

//-- Tabs

echo '<tr><td><div class="tabs"><ul>';

self::display_tab('/info','Home');

if (!is_null($this->PHK->option('help_prefix')))
	self::display_tab('/auto_option/help','Help');

if (!is_null($this->PHK->option('license_prefix')))
	self::display_tab('/auto_option/license','License');

self::display_tab('/techinfo','Info');
self::display_tab('/showfiles','Files');

if ($this->PHK->map_defined())
	self::display_tab('/showmap','Automap');

if ((!is_null($this->PHK->option('test_script')))
	||(!is_null($this->PHK->option('phpunit_test_package'))))
	self::display_tab('/test','Tests');

//-- Package specific tabs

if (!is_null($tabs=$this->PHK->option('tabs')))
	foreach($tabs as $n => $url) self::display_tab($url,$n);

echo '</ul></div></td></tr>';

//--

$bg_string=(is_null($opt=$this->PHK->option('icon_bgcolor'))
	? '' : 'bgcolor="'.$opt.'"');

if (is_null($icon_width=$this->PHK->option('icon_width'))) $icon_width='150';
 
echo '<tr><td width=100%><table width=100% border=1 bordercolor="#aaaaaa"'
	.' cellpadding=3 cellspacing=0>';
echo "<tr><td width=$icon_width $bg_string align=center>";

$url=$this->PHK->option('url');
if (!is_null($url)) echo '<a href="'.$url.'" target=_blank>';
if (!is_null($icon_path=$this->PHK->option('icon')))
	echo '<img border=0 src="'.PHK::subpath_url('/file/'.trim($icon_path,'/'))
		.'" alt="Package Home">';
elseif (!is_null($url)) echo '&lt;Website&gt;';
if (!is_null($url)) echo '</a>';
echo "</td>\n";

echo '<td bgcolor="#D7E2FF" align=center><h1>'.$name.'</h1></td>';

echo '<td width=151 align=center><a href="http://phk.tekwire.net"'
	.' target=_blank><img width=151 height=88 border=0 src="'
	.PHK::subpath_url('/section/STATIC/phk_logo.png')
	.'" alt="PHK Home"></a></td>';
echo '</tr>';

echo '</table></td></tr></table>';

// Page title

if (!is_null($title)) echo "<p><h1>$title</h1>";
@flush(); //-- Tries to flush the header as the command can be quite long
}

//----

public function run()
{
#-- Debug mode

if (isset($_REQUEST['debug']))
	{
	echo "<hr>";
	echo "<h2>Environment:</h2>";

	echo "<h3>_REQUEST :</h3>";
	echo "<pre>";
	var_dump($_REQUEST);
	echo "</pre>";

	echo "<h3>_SERVER :</h3>";
	echo "<pre>";
	print_r($_SERVER);
	echo "</pre>";
	}

#-- Get the command and optional arg. Supports both URL formats

$command=trim(PHK::get_subpath(),'/');
if (($pos=strpos($command,'/'))!==false)
	{
	$arg=substr($command,$pos+1);
	$command=substr($command,0,$pos);
	}
else $arg='';

if ($command=='') $command='info'; //-- Default command

#-- Run command

self::send_cache_header();

switch($command)
	{
	case 'view':
		$arg='/'.$arg;
		$this->header("File: $arg");
		$path=$this->PHK->uri($arg);
		if (!is_file($path))
			{
			echo '* ERROR: '.$arg.': File not found<p>';
			break;
			}

		echo "<table border=0>\n";
		echo '<tr><td>Size:</td><td>'.filesize($path).'</td></tr>';
		echo '<tr><td>Storage flags:</td><td>'
			.$this->PHK->proxy()->ftree()->lookup($arg)->flag_string().'</td></tr>';
		echo "</table><hr/>";

		switch($mime_type=$this->PHK->mime_type($arg))
			{
			case 'application/x-httpd-php':
				highlight_file($path);
				break;

			case 'text/html':
				echo PHK_Util::readfile($path);
				break;

			default:
				if (strpos($mime_type,'image/')===0) // Is it an image ?
					echo 'Image: <img src="'.PHK::subpath_url('/file'.$arg).'">';
				else echo '<pre>'.htmlspecialchars(PHK_Util::readfile($path))
					.'</pre>';
			}
		break;

	case 'run':
		$this->header();
		eval($this->PHK->web_tunnel($arg,true));
		break;

	case 'file':	// Bare file
		eval($this->PHK->web_tunnel($arg,true));
		return; // Don't put anything after the file

	case 'info':
	case 'techinfo':
	case 'envinfo':
	case 'showmap':
	case 'showfiles':
	case 'test':
		if (isset($this->cmd_titles[$command])) $t=$this->cmd_titles[$command];
		else $t=ucfirst($command);
		$this->header($t);
		$this->PHK->$command(array(__CLASS__,'view_subfile_url'));
		break;

	case 'auto_file':
		$this->header();
		echo $this->PHK->auto_file('/'.$arg);
		break;

	case 'auto_option':
		$this->header(ucfirst($arg));
		echo $this->PHK->auto_option($arg);
		break;

	case 'php_section':
		require($this->PHK->section_uri($arg));
		return; // Don't put anything after the file

	case 'section':	// Bare section (image, css,...) with PHP source auto-exec
		eval($this->PHK->web_tunnel('/?section&name='.$arg,true));
		return; // Don't put anything after the file

	default:
		echo '<b>'.$command.': Unknown subcommand</b><p>';
	}

self::footer();
}

//----
// Convert a subfile path to an URL. Needed because Automap must not
// directly reference PHK or PHK_Webinfo (to avoid cyclic dependencies).

public static function view_subfile_url($fname)
{
return PHK::subpath_url('/view/'.trim($fname,'/'));
}

//----
// Set headers to cache this url during 10 mins
// Taken from http-conditional (http://alexandre.alapetite.net)
// very important because, if it not sent, tabs background images are not
// cached by the browser.
// Unfortunately, since we had to change the syntax of webinfo URLs to be
// compatible with PHP in CGI mode, most browsers won't cache URLs containing
// a '?' char.

private static function send_cache_header()
{
header('Expires: '.gmdate('D, d M Y H:i:s \G\M\T',time()+600));
header('Cache-Control: public, max-age=600'); //rfc2616-sec14.html#sec14.9
header('Last-Modified: '.gmdate('D, d M Y H:i:s \G\M\T',time()));
}

//----

private static function footer()
{
echo '<hr>';
echo '<font size="-1"><i>For more information about the PHK package format:'
		.' <a href="http://phk.tekwire.net" target="_blank">'
		.'http://phk.tekwire.net</i></font>';
}

}	// End of class PHK_Webinfo
//-------------------------------------------------------------------
} // End of class_exists('PHK_Webinfo')
//-------------------------------------------------------------------
?>
Please consult the documentation <a href="http://phk.tekwire.net" target=_blank>here</a>.
Please consult the documentation on the PHK website: http://phk.tekwire.net
<p align="center">
Apache License<br />
Version 2.0, January 2004<br />
<a href="http://www.apache.org/licenses/">http://www.apache.org/licenses/</a>
</p>
<p>
TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
</p>
<p><b><a name="definitions">1. Definitions</a></b>.</p>
<p>
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
</p>
<p>
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
</p>
<p>
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
</p>
<p>
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
</p>
<p>
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
</p>
<p>
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
</p>
<p>
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
</p>
<p>
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
</p>
<p>
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
</p>
<p>
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
</p>
<p><b><a name="copyright">2. Grant of Copyright License</a></b>.
Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
</p>
<p><b><a name="patent">3. Grant of Patent License</a></b>.
Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
</p>
<p><b><a name="redistribution">4. Redistribution</a></b>.
You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
<ol type="a">
<li>You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
<br /> <br /></li>

<li>You must cause any modified files to carry prominent notices
          stating that You changed the files; and
<br /> <br /></li>

<li>You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
<br /> <br /></li>

<li>If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.</li>
</ol>
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
</p>
<p><b><a name="contributions">5. Submission of Contributions</a></b>.
Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
</p>
<p><b><a name="trademarks">6. Trademarks</a></b>.
This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
</p>
<p><b><a name="no-warranty">7. Disclaimer of Warranty</a></b>.
Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
</p>
<p><b><a name="no-liability">8. Limitation of Liability</a></b>.
In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
</p>
<p><b><a name="additional">9. Accepting Warranty or Additional Liability</a></b>.
While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.
</p>
<p>
END OF TERMS AND CONDITIONS
</p>
</div>

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
PNG

   IHDR      X   ø!e   bKGD ÿ ÿ ÿ ½§   	pHYs        tIME×00Eÿ?    IDATxÚí½i¬$Ùu&ö{o,¹¿ýÕÚUÕÕì}å*îwÔÆI3Ð,6 Àðÿ¶X2,Ã²Ûð Éc${ÆÚ(5)J×^ØÝd5»ØK-¯¶·çÛ½÷øÇÌÈå½Wìn5î,^FfDd,_{Îw¾s.áu¾F³ØºÉÞk/jP¥JµF­ZÎz> Âqò3ñ¯zØÜÍ2$iÌYkìê1Á+Ä*Y!aX <üODxëõ·ëõºîÖ,·oØÖËôDôwo\µhïñ==ö.Óþ# / -Ââ
ayM ¹HªºÙ\¤íFºÂnàRãz<à­hnq\©RºzôñÓd×ñ|02  óÿ3SgÏ.óËÙFã=û5ý3OýnílYÙü&ÆïË/ åAH¨T	µ&ñÒ*aqEp£(E=?Äz6-lVkÔz:Ã$æ«ñ ÛYÂ©¶)^?IÉÚI¡d=,"b ú-kø#.fö/¾ xéyý/|Kÿ'_}2[èí3ña@óÝÔAÌ %åH$ÂèVÖ×°BìTª´QmàZ¥F{¾(¬Õ¯Æ¾¤3Úq²°DÙÒÅÕ:ö)«7`Ã
Yé!&B@[CûHàbæð{Ïeïú+úW?óûñ;¯]²y>¨ælúýËDÎ@­AXX!n-­ÖA´a+uÚ²/y>úA¸Ö$-$6=¼jÚaÑÂ2e*öÃzÍe$+UëÐJ¡ äÃ²%"~N? ¸9üîÓÙÇþúÏÒ_ùÜÄìm³ipøxäu_È³ãÿnH®7	õqµVZ¸± á:[Üò|t+uTkd	_µ»~@ZQXÅ@*t-ê¯GiÒj± èè­áÿ¬ X×^N>þ¹ßOÿÏÿ?É£{Û¬õ«^ÈÂÃÛÉuæ®?sxDî½n(+@P!àzÃÐX])±ïhÐ¡íûØ	ªØH¸ZGoõ8v×O¡»´FI"%BÀ~ÿAÇt`}çöO]xÚüøÛæ±WØc;ÿÑë¸Ù·³|ØºG>x¤eÒ
ÀHI

ðp­A¶Ú !A
dB¢ëyØÚR"?Ä~µJ?@V`[Ë´·¼k'Ði."Q>p9¡þQé0`=ûìþO=õÔî/_øïíßýªïõ»ãÍ@µÁh.[! 3,ÈR@g££	:ÙïíZ³Ûgìµs:¶4#ÖkØ°VØó åQWl	²°»°HJºÖ0èæ"Ìò::\n.`¯Ö@T m!pÀ ·Ù¿!ÖOÞüå×¾?¶ùâ¢¿ùZ,s¡ïýÀ¢²²ÔoBSÂ³ð$y¤àIJäØXVÉL"¥² SBL0nc¸}~Þmìß¾uÇÉ®Q¡R!¬ ðDli¾ò`-Zm?Äï#©Ô­GZoa#¬âF­¨µA½Dy¸E× ´HÿPÀÅÌásÏµ?ñä7ÿ«¿þ«ÍÇªåí½²rÃªg@Í°i~×Â I¡2@jÐÊBJ$CÎýá@P
_yð½ ¾ Á
d=°ñÁÚÉ$²T KiB¹u$Xíh·×3ü¾jÍ°Þû ò°,Aù@+% <pX¡g-zB@Uèæ"t¥Îâ
¶NÇKçïÇ×Æ3Já*ì°r4XÁºýâoþÊ¾pãkW7'°ùý&Ãi ì"m¾S'[íó¸yY9ÿ,,KÃÏ42XÊ ÊÀ"DÈ,R@dÒ¤	·	@I)$P¤à{BßGàð½ ô bdñÀh4&¤±¢ÓX KØÐ¡nîgX§d·;ìÎ'ÿ
:(öCØ0Ä ±í3wáÖ}áÅÞ³´' ä3Ë»ïýÊ_oÿÆüÉÆÛ··êÜ¹
Ò'píÅ´>ÄÉºr¼t÷;ìæI\}YÌ¹<zë(Xó÷ 0ãð=È8 "#)°L`E#z iABB@B
"/aø ¡À÷<H@Ø Â Öw1È"4vï&°%0S~Ír÷CàQë7dsA@. 	BØJÉwáÖÇ~ùÀ;ð«õ]þAÁ¥·nÆ§¾ýìÞ/}þó×ß±½=ZgP*DÊ10ÀÃâ®jiÙB(ÒË`víáçünàoKãÍcK0Âå1Ñð-¹­aò0zG*ö±'¾®æ/;jA¡¨È^
ç)T0@¥å@XU<QDÁ­Ö
:ñ c,QÐ5kr0ZfBñ0ã¢x­G>ã»Ñ6ùös·9hÌÎ Az¨ìïàÌåøûü4µ]ú×.k­úÌ¿»þà÷¾×þÙë×{RëÆ¤°ÖäÁ.;0äà2¶F'0¬ÝQYÕ¬m ø² <Z.r|BUûÝñåCùz;ÐÕ*!Î¯>sënd	ÁR	J0@>bhJò.bÜ	 " ¾ï9 O91PøTä
È +°ñaÒ &ñaR£Ø
X-a áx¤ÂyS"£3+r&È&Ày0C è´³à~ÜÜÀ?oïrXoâÿêö²*±¿®üóßúÖvEëZ§06óÐM<iS `[¬ã,Oþ «7s¿ó¬ÞÄ2Àâ Ëà© «§plmÛ»UØDBñÄpÅ2#Æ.®Ø?Ff9ÅTxõ£Ñ]B "!¹FÎ¯d´|À÷à/áU	ò¨*|Qd}­³Vû°Z5*¯ÀV(rf}Èü®?Ý6È  KA_kA_ûÿmkùO s»¾óÂþÒÆÆà}ÛÛXl­;X\ÆfXÜXÈü*3>b ÅýÎJ óÅç~ÏS'zMÈg6ØA7³ 8Ó|v÷NèTÉYÃ Ñ)¬N`	4b¸®½¯ÓQRÁ£:¤PÁSR
HEð=¿âÃWÆ x!ldB°ñÀVº¿Æk·£s! 0)é}'WñÏ>ò3¸ÁÌß8j$©  M­×d]¸°{Në$ÉáÿxÁ[2ÛÃmÆ¾ÒÁ KÁ´:¶ð¸ +`dyPÀ`hDPÊÃbãUGôéHðHgúD¤ ¬ß@«qÍV½¶eoDß¨¢ÁÈÿjîÃ²Alw`ÙBÀÊò*Zñ{`LÂ"F}ÑAÄ¼.¤$(%¡J)g½A5¢D¾ómÓ©Y6©I¿ñåÏà®Õuügøi|7Ï\×¯êYf>ùÂw¶H1°ò+Øiÿiêùv¹µ³9<VaÎvea(hÚûQÇÛÀ0ê@M=tüPkÔ¨:¤¥Õ ÁSC~yx.IË5ZU¢â7Ð¨­ Á:ª¥èx1 çÃUÃ[=±^ ,ÀÈ#9EÆlê§°¥C¦5d3EBÅ¯¢Nw­SÐ(^¤Z!Ï ë,ÃdÞÖÞAø/áÇú1<ÎÌ;õR ðüóÛáÆFïvT»b«iÿißUÂÀ_gÜÀ¹ ;êP
@°AAÁo"LáÕ»`#IúH³B
X6ÇVrò8HR¹5ç2°ÕHR£L+È}È A
	
êÕeÃÊ×`R÷\¤K`Î¹'}_9Uó^¤&g°Á$)l¢ÛZËø- Ù[5%"iº±SÆÇÂs¹ÑÁàbfüöo¿èu:ÉYc&5¶^#ÿi%Åýq¾¦,Ýhf·ß!Ä³ûã$áÝdiÙ\rÂç*¬04¡ÀCwÅ;:3¾1¨õziu¨Eò¤(:A¹§Z&AFDP¢.#+`Ëèö:¨ùÉ(¢&J4 ËÙÔÍõdfuÕ°
ºëç¥2>©áõÔ@ûjÇ¯B!l¿ûdc v÷P{þxìÑÇ= ?j´(±Þ$° Ä(EneÈãgÍc|ÒÃRÍÕÕBÀº\£Õ
lÌ'²:Ï3¦ñ ÈR	d:cD)Å°aöès|®«kýÔÏÝÿY¯qâ/úý´föÎë×âüÆ×;ç¯_K$hCåDvØÎ¹ÄU1!PMØ`ûH¾KUåâø/b ª£JP2@£ºÐo"bf4Ô)nMØnï`¥ºêSYAtýîúþwðAf~á0¤¸×%`1ça,/ri8+ú&<¦£<Jòèûû¸ã}Öèñ5ÌkPB@)¯ +ÁLRB	|4Tvÿ®~ß+È£ã1`iGA3Ã²-û\sXnbF½%Ì»ÞµöwÜuüáÊE½[1º4uÀ²Öíßpf¼Ï©k5~($`$YZ§È2	i>¬Òõp¹¨q<DÁ2òBÕÉR03tU:rDAàf;÷e5èwiùÒEÜÿ" 
.¥°§5¼]ybf>­0sáÂQîÐ@A£Ú;=ìíßÈ@9Rý@
Ïð=ãk«8·²zÙeãñuçÈ°Ö@H;óiôMÆ`çÜd[[ÉúõëýO>õÔ­»66veC`YGD¾tNó0Q0ûØ ÖmShÙÂùÁÐ\lÕ±~ò2`sknpjé,äÞÃ°©f²@´L¬$HW`)ÊÓnå Ä}V{[8ÆLÇ \:\äyBãLTXî	'ÁtDîcäÆÎú9ÛòTJÁa0ÛâRDÂC-ÌÀu;Ö³ÅÒZ.kÖZHòÁ´G2iS Ðí¦rs³W¿reG¤iX CP¸Î}âþÆÃó/]"$·zÆÂÈ1³Ì¡ÕÀ=÷,î?øÄýZí½NÛü/iï´M*Û!´©¸u £BÂm®G¨AÛ¤Ð`ø4ºmú=Ðî6V­ÁéÃÀ% À÷¥§µ»q4r®CÇÐJqas²u8þz×Øv<¤ÎPò%)(¢hi>>0çù½å²ÈE[ RP>ÖÂr² 1&âëÌº¬áuÐÆÅYûãáÅ ±XæÇÆÐÚºD<ñìcÊßV×BýwþÖã?þ¶7u¯k§}Ìwk}Î9gò%jH³ä¥åÛo&À úÞ6äÐÒÔLÅ$3ÒÜòÇçÜ2,×ATUðô:â*¡:W@¸¿$ )<@QµKäÒf²yZhhí,3µ eKÔÂ<²7MI& ªVº¾O%`¯Ö¤L1ÒÜDµ³b
Dªä§ÖÂYÃ£6½mnnß´ÿäÙowåþlïäKKêJ»ßfº­D¹â*$CÃK`Ø:*ªèÏ2ÃZZÞxÕYðCÅ $1SÀrï©W<(ÏçþÛ)3IEL
xz-'rÑ'hø íä^æ¦Äå¶WRkÄÑ¥â,µ$í81&Aß Q«)ãy3eD G&|&Í1âÒ»î|H³§ç*"Ö _°þÞ6î¢ímÝ)ZúÄÙØâ`*CÊÓ`ØL­¢*º±\gÿ¶tÆ+7®â3Äø\8ÖSÀÂ]kxêÉ}yä"wè#ÇÎ=å¹/1JQYæß|;ûÝò~æàòvXÌcpÛÓTIÂ´}×ÁT)!)§`Ê£C¡ôNGs½³Ì3Ì?ÁÂNølÅ` ê1®¾BP +x¨"@M7.©EApT¿@ä!ÛO0è·Á^ßiëJ c"DÈÝMÔ %dÖ°èy¢>d!¥µ13ò3@ç¼ZæQ´x¨å,æT	¾JÇF)K0Í§° Îz;Úv®â@4 }æ_'ï_©5dºwim¥wÅ eáÔ´SXÒye_pÖ¾s_ÇeÅèÚGqv÷ÖeË±"ÍçÆ&>³°¹µ[×¿&OÜ}ÝQ²	V¯ßíïb	 e Z.¥Dc0È&cW&K0ºìN_	G:?{d÷AËGæLg[ ç4 cí(Ï6Ò«ÍúÙ0ÿF¦.>¯Ï+%
ir
õRÔûªûÀNGÀ18í[8§c+Å)DCO¤wMè@²¨ä>8§u`qD\P·ïîzû¸#ËpæPp	A#Ë5òI¡¤SQÍû\CU¬;ÜrÍå9Â¢~DýWY½À("mhñPpèÇtÄPJÍ#AG±ïÅ¤åµ0èsi.I¸9Î`ìøx
j	ìaºÙÂËf§
²)
!¼TÁÌðl@5`ç×Ç]8 ô2°ö¦×,¢jÛ×Ñ8Ô¡^/£"°rru®C}®¿1ÌÆÛdÎs#Y	î 8}¿bQmh(È S[Ö0Äì>J¡úíªg'"Óy¾ß¼hMÀwjaºJ[@FÃlíÑ¬Òë0H%WXèt µ±bdý8B=H¡£êÁÌÐ+¾Ïk[úC-WXTùMÑGð¹Fªq8D$¢çzæP
@ÖöQ¹ã:üÎk$L¡ýÊ¸gÖ`¶°ÈE9õíçsnêÑ]HåCãØr±s"Umè"hËë$YËÏ#hÔC(
ÐOÍº ,w'ýj!J£	a}ó:Î%v.¸PF#0 ¥ [Å~PIAÀcUE(FrG.ÏÒtæwgk§ïw¿#;8¶^Ç}÷Ã1ÚqVJo¹Ü"ÙäjÔùRk¾É¸íxy=¦YÖ,³°®è¬0SQ;¦$C¬«éw>vZ_ßÃgÙåIÁ03`0· dÐÚßA@®½À4C¯/­-¡ó1´á)fy¡/0íy&hL¢À2O2ê}Ð¾¸@·Y,.VÌãï;÷ê?þï|õôÉ¥lxãÆ¼ç¨íw:#qÔãÃAÇ>Ú³\Ãã²ÖÂØÔ3¶ºNîß-{ÊÃÝçN>ýwøÊ/ý§ïùw¼ãäv%TSÀiªÁª;É3ºûLqO0cu®Ïeµ,ÜÁ/¼Î¶º¬?$¸5â¹R 1ø)B£4Z4ÒsYXèü¯Ñ.;ÏLãÀa¢þX`}­©ßñcõ§?úá»÷ÇÞ}záOþèµ_&¢¥2°ÜM´lreÄmAÏ9V{ÖoH«o¤)¼À xLÁÐáû¼åVÓ³O¼ÿÎù4ÿ«+õNà«Fk!üx¯å*4õrmÞ´¢³Ï4Ð$Æê¼£Ê2­YpQ"!Ïå*µáZøÉ^.ãÀ!èL^lÀ)!û õm\éR(ÿ»²1kóúC®,Ë°Ð)A«@~àÌSïy|á·Îß¹üÙzÝ¿WJú%Ç	ú¡Û°	ÈÐÇxïæK~¦%7¥ýÐðÜhtýqf8féçÉ¦½s@Ø³g[WßvúJ§T´±ßk6ü_ a,#ÉzNÕÝ¥¨æÍ®Ïµ\I¢IkëUã¡CIg«'ÒóV:ô\ÐÐãð¨Nkukï.%ßÎë%¤PRBI	)Ü2å¡ Êõâúé¾ïÞµ§îyàßzàáæçî½gµ ­õÆéqTlØ¤Ît¨OGUÀ4Æh÷¿,Ki&7MYúáðÝÄXuþÐ9ÀzitÛÌD°A £J·µNkxÿ{qA,Sþµkøôµ×øÄ¼Qij¼I`Bº¡Íg89Î·§<a'Ùé¨Ë$ÑèèGk¸2lÖ+¡z8çrvê®æS¼=ø­ZøüùsËm"bfÃP%ÿLC`qÎs9M×E²ÍmëÛPÒck:®t*Zbýönz°<1LN.=Ì23QÕç|çÒG,ÛËRÐÞ6B ÏíÕêÍ » /­Ûëc5LµË@4Àòæ5^vYÊi¿ê÷3J]KóÉmÅÜâ¬/3
¥®Òl^Nqfúèö^C/´ªæñÿèÜÆ»Þ~ês'N´þÍù;¿uþÜr· ÃMj5/¡¡æ±à[kAÎ°\3@ÆÖbko¯ô	äU×ã<"WÌ*,´ê8½þ´·WaSÌTDPÊ¥7cp¥©ô'*×oæà"ù)öwìZã? ¯¯¬Ôº¾/{ÌX*Ëá ßá-E`4G:²¢Ýk³ì¶© 1ª~?CJX¹ÊsUg;u ËmËý`¹fêÔyX1|4pËUóáÞõÝ}äß8{féÏÏ]Üm5+éNjU/ñ[#ËæQ(Ò8¨|.MûÑ`¦¸@F8½$Ã
¢@¤<ÙÃìÃ@DLèÎ¯ýþ§ç_ç¤ùxkÈ½¦/3ÀÌÍ²ìï01óÝÌ8à)põºÅ®Bi.D|Ã=#R	²!ûM<Ö©$ÓE¹nÓxµ¡ýØGï¹øÓ|ð¿¿ëüò¿;sfi0-N+UÊÀ*ªQ±¶`@°yO í&#©mFÌðKDj:HÌo§ÝhàòEÛøßL?Þ\¤&±6oÜå¯Ëã¸e¿¶y­¤éË2#»%Azdû» ^+IN½êRc]SÚéëp¶rMö6òb(W"öjÔ}þä'îõïÿÂc¿ræôâ?ÞL(ÔÔPéÜÿc!ýã¤Î"?Õü. ìÊ®¦Õ²®¸ ¦s¬³öë¢á±2Â±ôÑ8ÿhI2:I@×¯ppó*wkjP¨æ~£8Z¤¦!-¥VOWTÅ·®]¶µÙàêeÇºÎ¹?Q&mæuRú<NyìsEþQ«	<úñÉÍ~eý~Z1Æ
$AE)Àû¿óµþôCÿõý÷­èÐæ&¬(ãîO¡Ükd¹rMÍï"+Gë<`	R° e aÁ,ÉSÂ\Î/8NóÁùÙÃr·EßCåøU"átLÀZF?êÁ2Ì>n&Ä1Î\ºÈ«³"F52Ý,Z,.£RÅ¥I4JÛý2çæÉæSgBûóÿàØ?ô©G¥R{ | Jk[ãÌïtãj§7ÒÔgÏ,=Õj8¹ià°ÖÕ°ÍzÌoHRXB!ôhÊ`©aÇÀ &dÚµìÊi¿Å¨sx¢4RqhþUxÒ3.NÕ ¨ËÉ0êqò~Ç+IÏòaQ×·oòÊ¬QÅq45QÉ~A®[.ÎÀÁ£a±P¥=ÏrÍ jM>òy"ñÆ¾l*+5­yvÌ'ÀúzÍ>øÐùvn{{«_»|y¡ÓÎ<K¸Ë¤:ôxJÍ9;¸ñÜÇé~°j0h«³ llÂ[¹
ée vÛ{  êIDAT (´Âã¸úíS(:³ûÐgR§èõ#xk1ÕQ~g)M°çKJTZÊ2SãÒ=ªÛ«7±ZEv,Á)$¼áÉtÆ:K¹O7á%¥ØÒé½÷a´X´jóZ¾"¼÷î?ù§þÒ7_øÆ7®¼ûþäÅ_ú«/_=Äv,çÏ9-¼ôl¢çt;`zyQuûZU{xêÍÍ6®]{)öFn>øcïT' ³å±æ-IfX¤ÜÃnòE æÅ"ÑMKlÅÖ`a\BZs0	,fÎå·Tªú,5*dÙBn±Ðæ¥[ÅuxoÿF½rG~CJ2E`9*Âéè]yO¸<,&4Z²südíOl=ùÀýÇ?w÷]ë/·°gfgËÛ$´«!P(fKzýAÅÎï@tç¤]X§×_ÑGHlÄ
=×f*D6S`ÙM	ûöSðé^Sªßd­V±£àh!/É',(r&ý TÄí¼@ö<Ö-Ùq¿k]Ø0GíP| ¬eúØR=ñFxÀr»qàS·9U»9&Ré(Ê =EÀ:§Ü	
º½AÍQ1ù@	ÀH¹ç¾*­¨«¯pu*Z¬V´v°f<OgTçN\èëU %Ms$}
rsü¦MñP©x=ß\ÖH,h5Ì¨t^ÖaÖ¡×f$±0Ôk¾{ ªbf¡SÃ\1¿¼DÍ@ø1+%ùPæIH;Ýî<#êaýÃt&a´`)Å5DIÊ7H#1}ZF4à;¯½f&#FU«ùÊ;Xy)O·ù×Ì¶$,w³ø­2½ñ¦ ¬ZU}Ï<©éÏ3,`Ç¹ °èuúì»ýz&Ub
XÌ8N¡LAÒ2_¹à(?»"Y¦A*REÌRcò!ázªº{ ±½¿íõÔ}	G:øÉ	´o4szZ Ð@°P#¨)5 ô»¼ÜÞãÅÉQÕëef
X<êjCÖ43¸®È¥2FÃpåc÷¿¥Tòr]½u¥MV»ß¸ãNeWT2O2ûúÁåE7$QËÅ¿®ßôa)M¨ÏbÐ³Ugm4S©xSÀrõ¤§gZÅi+ä×ÄÈ±NSVñT¦Ùl½Bîû!á~g/>ã
o@$°¶´3­ B6`ôÁz+XkdÀN03ZÝÝ²`Ç&#F*H3]¸0â&î^Ly0hãêBZ(/¼q¾ÐÍ²áÇ*á»J*<±hxâì;îTÏÌÊ®¿A+ñ`ðtU¹±.A\o9ÛiztT¤,?'p52õ<±ëû"bæJX+= ³¼OÐÁÂC©EÞ©B2]Û1'eHî!çlíÎ p&<¬WúÊBg4¿TÕÑRÈÕúÌhuóºBâ>cÐ KúùX4ä¹ì
óï[hh°µc¯Ý½Ñ!Ïl! ¤ÀéSö|ûK¾ÓÿÍµãêoÖ«ÐË<Oò°ÌXºqØÀüI#òùáâfZ5ä'>Të4èåüÔc7¥] "°iÂ¯%X=­a2rí¬ëj3Á' QÚGFk¨?"&f¶æAR·¦4+7¡I |$£)T¥ÈÁ\"¸³ÇH"^ïìqXrè}_Ö¢(°X¡sëØçCèç,»;)×õÅ$öPEÃúz?ò¡·½òè£'~uy%ü¬ÈþåÐûÔ~0öe[,Û»1¾úÌóð=5TM(û0±Ñ¨àïýÇî>öã§þzS|}Z
Uß÷EJ<Wó\¬ÑR¼ðê·VPR9k-¼\ä¨ IèàÊÆ6øF6<êB½¹·;ºx ÁVVÀ	6NkóI´ftw3°6SªZ,Ä:3È8B½¦÷eO*8½ãÜdØx0ÔÄìZý¸ò)EÊóD­?p5EqÓÏ»Lú¬Hq
d=Ï1e÷³V$>ýG_üïþÆw,|×ó9@aÊÃÈÛ±rR
ö}9¶k:«-öÛÙÛ¡ýäùîû?pÇ¯-­Êé4|lµê§¾/u±Ûæ}çu¦ñâÅËÒuk&P>=f¤$|T Ít¡½yç.¼«· É)qeA+!ÀØÅ.4Gsâ4Æ^¼¥!CGÞb<Ñ8SJè´3¤WuÊ³Èb1£é÷ñàÍ+åQI)ý^:ÁïäÅ èÉâ@XA8wæ$ñ®^¨Ã§!½ÌaçÂbð7åyéX÷½iÌßñx>iÏF)2R÷Á$xÁó	~@ö¥âMñËRÑÀóiày½ßçö<ÒÊ:ûÙ§²AH[B`$Í.0>ã*l0Gø©ßüïþÍ3w,þkkõ¢´<OH¥6%ËÂiflF·e¸:å¥=´w3WÀ[ A 1ÒR 6ì¶HBx ÂBjhm§e é/_¾K×6FzV.ä 6O`¡FûSbEf`gËí=ª#F%%5zýt¢fÑ´³\<­þ2!ô8sâN4Í:n\00C¾Ê¶Èöo~QÓS_¾U#Â9f¥b!ÏÔl\ïÂP ¬û!qöÁ~@ð°ç	( ±¹& ³g¼_»S-Îä´
»É¤F3¢1x¸·4`BàlýLwåñ«/µ«/EøÆyê+1ío,<Ú¾|r­¡%4§ù¼A\ËîïØ2y	áôÉ~ê÷ag+ÅþìUô{	ònÐ á¬mCïîÉÛ	[oà~î1|à'îq¢1d¸ðâüÎï=ÍÈeÁR
6®AÝ¼`8R½¨fÅ ¿?¯Û¹e©RSgªT%5»¤¬|ØM<Wb\1<Â«,ÃÚõÅgïqý³¬sZmî¼Z¶ÈÛu»Úa{¯±"6ïfS¨"ÒÑíZt;Å¦ll/)[H¡
yeÿçÌÅ= >ó{Àþ`óBàÃo¥ ¤ç\8ZAÓ®L¨KiÖ°pWàÅ?÷4£óXÃ©ÿÌÜEPZ¸©^,»ÉPß¶ÒÂ}ÇÏáX«éj/stKÃÓÇë¸°»cu>ãF»èàS`#dÜõ²wÀòGòczQµ³¤±Ht"ÆjÔýÚ%KaÞm4þß¸¨Ñïg%`+b4,¨c/\Çþ v îocñ!7á|óîIæÆxè\n2|O¹xÏ1Êl	Öº÷Cº¨køFßèÑ÷zXIù:ÃâÝ³cNnä0
ÓÓPé;×Ò= ~
j2}á&
ø£Î¤ÀÍ«'RúîLÉÛw^%üîÿ¬ñûáp³Åp5û;ç±&Ï»ÔVð¾¹kâKX]mà¸÷.¶°§/â¦þ»ï¦ ) kÈîwÚØ6ÀÂG¥ PØ»²ä®!:û=[ßÙ´£ù]j(-yã7!Î3i¡í }=Âë£§ÓMK£D9GîxÝ¡+rÎ]0÷W
Ç	) û+NäßÖRõ!H@H§oW$Ü>IHæ£ÌÇ=ÃÿýOÈÄC½Tþ©Ëp|®ÅhÃ9-MüÅHÞd-) !SÏäªJ9Û¡bÅýM4
Ëî½_¥By{o¦YÃêR+ Û8©¢5!2£¹#eXHR¡Dý^VøÕBY#ÝuÐïðÛ®¼l«C§^ð³Ìe­EÔjuÂsFO¶(R\nAþ£úxñ¡pg.sFÛ¿wß1zàä÷Þ}FBÖ³è÷¹ewpÄð	ý 0å}äÝþ(bàc{ÿêUÚéh`Qí=^Çb»w	]s=÷-?Àjã{i?D°´fÍj4óÈ0ÿÚíðÛ·lkHÀ)c¬(VþXk¡Mý¶}´VrÖÚÅ5(Û)ãGXÁ´Ã7å(ZþñßÂ{ÁïNDÐlVÐ¨- ßUØì@éË)õ,4×QÙxÄ^ôi5¤ô°º|{7¾sýÍ¼Ë Ý ilÊ)À[×N¡ÚAim%&eL~ß¢3hc¥"¢ÁáKBsZìç ûÛ¬7©oÚ0Þ=ËK5__EÜ÷°³{RðÈÃ'ð¾w=½-\¿èDå
|	 x "Ö!¼Â'DZ#1"Uo]3ÔZôïbÆ× $®ÚÚòX]ê`g¯åõÕzÑàð|²`av
1"ï´èÄoë=ÔKUÜw÷di«× 1À#Àû >ï]që5	¶@U¬!ðjN6-=È®ÄÖ%À¤;Mxµa0h{£éõ+¤Ò ±cí[¶psZ [Û]Ü{*Bs±Í£²uÔ²·Aq±¼	#»yÃýbEöXS,à)MXA¸3.,­;?~=J{µùo)°UÜ÷¶óÙ®¿¶Ð¬ã¾{Oá½ï:Á^×/ÅèµCd±ç3¼ÐRJÐåAÉFäµ¨DÐq¤ÐE}9Æò)4ò0h{èî½6ß¼î"F²ÐÌ 3cow öúh.2Äm?ä´ mì|½ÄPRÑr!E2ê¬ë¿JÕÐ(ÎèaÇ\±kÔFÀxêPíß{\Ò?ùì¸zSø;^ÓbZð=½néÍµÉïË¶gÏö("¡×BU.ãäÒÞ)ìÜ$Ô¢¨]l_à¹¿èw	8yUö±r±w£`q°u¥R­37î­Â>*U+-D]/¯lê£º %MÄ=í]{ÿÆ+&`f¨8É<=X c¥ØnoãôSXxEawëèjbÅM¤	¡g<axÎdæ*M8êþ]Þó:Ëâq^)Ë7¦×uÑ?,Cñ·ÆMïF ¡qJ¬0³{ÉfO§7µ>÷ïùg«øX²Èv{[ÈVÂºE¿áúeFw«$u¼C	Äq`ùDN£½®F£µ½Î>D²#|¤± Ap¶¿-¡³oîjïSu¨ÈÂ@ KÀZ.\Á=<{9g¾bÄ·gú#?mÝZ¦YQÏy^i\oDÇÜ_Õù(ëôCDÍÛ_qtË@sÎ³ìo8ü H­&Ì^CÁÄHObw½}ÏÊf,A÷¢ßëÁÈ.+È-¨ëØJ7±´XéUA-@ìì¡Ûî!hÞDmÀÞ`åxs	Àkby¹òôù»§TÃ©Qnmuð_{w¾½ó÷{ÞtaJÁ<£¤¸Àó+fm7¯eæaë~ó)í(e ÃzÍÂgCruD¬r°"ÏûIWghóî¬\oxv@!xÿâ Ä>£ÿÒ\Ï
Gé³\Je$[h_¯c÷j44+K¡j](³ýÝã»yb;hµªèmWAõkh,e¥ëì·Ð»~ýkhï2­¬Ëw2CªLÛ¿~äáãüüs×ó4¡Ï¹Wzuá¥ëXY~ïýàû°¿#qãþ¡ù®GQcuetôí&ÄÖeÎCç ÎóöõLúPDÓÜ6ì³*²=j¡Z0pt)7å³Í¬Cô®ØµûÃSf÷4º=,%¤ý*$«Q$×ËYÁ$
©6.G0ïÎRboopé±Ç¿:ê£P ÖP¢µÁß|ýûxuë|èï*¬S ÂõutKvHÜêÐÚÊYÍm Ã!%tGh{Øòäï©Y±E^¨0ÅÒù+8ûÞpö±Ô®	I}Ø £÷\¯fu4òÀFÁDÕ«,ôqìMydõ¥F=M»zsÃZ\¨$ëkg=OOR3¬á%LRûGOãÓÔøÿâ=øË?Txñ¹YjßÔzÃ×mÉ°8Y²ÉÏf­{Ød¥u&­¦{èµnÉbÎ³Â24òÑ E´1ÀÎ~¥Z½¶Åc)Ë©k'eÏc1aO;Ú>zqý+ë/²	A×>±·ùêî»WM÷Ý·gÛ	¬ÑÆÿýoÁw.\Ç?úùÇqîÞ5|ýÉ»[:ã*ÍózAvà¼! Ãº*b¢[àïõlªÏ*¦;èC#jí+¬­® ¨'HS¡4 k»Ñë=#¢rª© -/¶pÇ·cÐ9ÔQmÔ @z;7-ºýìÔÊqÈ_ûµf~fc7Òøì·¯zÙÀ*¾¶¶zøê7/âÜýïûÀ*`ö\)*Gv?D°ÑIÊ¼ ì(ÑááQãÁëeÛYÇL|?+"¥#3	¯±F­4Õê	°ÐÆ ð%t&0ÈÚØno¢ßË0èQôA1è2ú]N´ mU$±¨6`$â4ÁÝyxðÑÚ¿V øÑGO\øÏüÒK~åµ-¬!fúÿê÷¿ów¾<qÎ<º¨bçÄÞ-d IdÏ¢²nä7K1Okóæ[ªÉÍfçQ#Bk©wv4¯pñÆpbÞÝ¸tÅDõÄ\±:¢| åÉ®Ê¿a¡½,Þµ©¡3F5ÑTNîaõ®>jBðÚûFjâJù6¥%LWbáØ6Ä 6dý*L³ÖÉ=	6^«RX?A²Þw/Üü?þÓ~ãÿ_yøÆ¬É[,!NoáÜU[]D=XMªº
qÆ5wù­a.ªT¼á<lLí0®«äï0¯´NÉ²RÖð&>ãmJ`¥Ù­ÂGú*.§ÈºÀ×éNÏ'9>iËpB!{Ø'Ïa#¡sÉ¸÷=ö¯×ÐÝõ&|	+vot¬]¥±Ê#,/øßþxõ+eùÊµkûÿÝG?|ï¯ýég¾sÿînÿHÀràdDQW^ÝÆ+¯nCæ`«×,¶ª|T±BÊÇL<M4oX¡â\f'IÏ©ácúÇg34(Uzv ý9ÃQ¹ÛÑÍ²æåRW	Ñà%,âEU¤}:UH²èì Û¨Å)¤Ë­$¤®¢×÷%"o%KÆ5°»ÜºfVÔð <OÆÛÛ½'Ûødÿöþ½Õí>ñDRù(É[cAÁ Åæfo½þý¿<O¢Ù¨`uy`¡± Táêh:Ò¦1zÔókj"i+6@µ!¨M?õºÀ¤./×:O<~þ=OÔ@ýìÓÏ\}ô{/Ýq¢¬·^?¯,3ØÙíag·"@
åI4U,/5ÐÐ¨¯IàfL)ùQ
	â¬ÃW\S;U¶õF'>þÀÍõSôÇj2ÇÌW?ò¡{ÿ×Åê·ï8½ø÷¾úõ×>öíç6Nlm÷h8³Ù[ÀúÛýr%¶¢66·:â:ÊSÞK`´EêÑLÀÃW£àÓ?þðÞmÃ«&U$:ÌüçË+õï>½ø­<ñóß½pãÏ¿p­¾»;@jö°þV¬ ÃØÛüÀûk4B|ì£÷]ÿèïùÎYúãÇ½C8ZÆ×¿yé®W^Ý~ßÞÞà±4Õ_¿Ñy`ãÚ¾wáÅrãêEq­ÚÀÎ\]©¼>!èÜ?ÕsZÇõ'¼czCò6Vç`½¯F#ÄÏ|úáøÉ~ýáNü«ûî=¶GDGëäûêÆØËWö~æêÒ­­nãäñÖ§vw£:IðÝlsuÑDÚ8ò÷7lð[Jû¹e.¶PMÒÉ)eæûÕ*%"+¥)ÄRúÂimcÎ2¦q$qÅX-Ñ*I¢j&c¬-,ÇmÀác­-ÑC½X©å
¢fm+õ³zµÑ|D)r>39by²RærGfÆµëmºtivv®¡Ý½)ÀúÔÃ7>ññ~ý¡Oü_÷ßwlwØÃnõ£íµXéõ2¹µÝm¢¸j]ôK¥;.èÁ:¼v.3¡)Ïãz­i|?°DÊóY
ÅÕ¨ò½p1­µEÊtFYR¿ßA$ÑyDÌd-bÝ9ø¾äìÕÏ¥°=ïÂE<ÁÆÚáÔîÐÜ£a·Lã{#GyþÐqãÍF¤3Ê__o¾;MõÇ®\Ý}dk«Wù/¾$:.í"N+#¥«ÿ¾W½à§?õÈÍOòÁ_àþã¿7´XoØ°ð#VÙCøÑ~ÑµfPðÆÍvýû/oVÁh®­5~ÎZn\¼xë'¯ßìÿìç¿.nÒövq¬â¨×9òÕ:>þ±ûo}è÷ü÷Ý»þ/ßv×j{²ëÐúÍxëõ>ìÌLÌð±ôÌ³WÕ@¾owgðÓívTç±U¤I½>hÔþ;n¸bàiü)OÏÙï§~ÿ}ÇâYó.ýØìdSì    IEND®B`PNG

   IHDR   x   I   öBâÚ   	pHYs  .#  .#x¥?v    IDATxí}wUÅù÷÷9çíì.K¯ÒAA#¨X°ð3&QclXÒ~I4y-5¯&¨Ñ¨±`¬ÄØ%6"RD¾»l¹»·sfæyÿ8÷ncwÙ¥$Æ7Ù{¹÷3óg:sÑ1BayäQ/½òÂ÷CáPÀc :OLDIA"&Ø#¥µÅö)­m`2®B¤."°Â  fæüÜîÕ, "þmsÈÎz¬.YÁÌÙg3mÙwz<=Í°Ñþ13ì
d=OÕ¯fìÝÑ­ÚoZ+-»j)å¬X²~ MÆÁL`N(ÿ#O;Õ¬@Üvm®ÖAXºº:\wÝu:uª?pM:""ÏóxÈÐÃÆ*Ìä½h×s$Qs|Û~nöViD2ºX-"jxÑzf~£KN×§|ÂzmÅb°,¤ú£eþFÞÕý{Sr-0`I[×ÔWÊ­UëN0}mÐrrvYXmj"{z,]¹hÝ¨>òBÁ06Ä`XÂÖµ;åÖ=ë>Ù{òKZÄMbÃçWÖÛ7ÆXy¹ùê½Eo]V­xd	L$(36Ì!$Ø0Vmûv#³­.++PÇ&-D­Ö "fØò Á#<K/½VÛ 'IkçÎ]ráoqåesLM¤R3/ÍÆý?qCg¡ëºF£bwÅÎì/6¬ûþ§¯]ñåâ{VýS=úøKºu­ÒZ¤zäáÝFNÅo~ñ]©$ ÈË)0¯½5_Þôèe%/¿ñ\(???ÅÌDÔ¹Y¯µ²¤ë1§æÝ6ç~Ý£GO8®Öy9ùfþ»ÏË[»ºø§çÿ^ä
Ò 8q!Sqä¥`Ã A-ë·¤ê§=÷å7}ø/¼Ç:eI¹	"f °§ïzêÇÏ·-ZÖWoÉA©¥®F"Ò
%ÞüêT»Û¾Ð03g8ìOY%£¨UÉH¼F´p#³¦mö]æK¿!¹]²Ð¥ëp=zsÚfég»ýåÅ¥½K¦½ýÆ;gpÂôå `sÂ£6¶GFâÕ h(&ë`´f­5gÀj¹²ì2 kmF$V#ÃÑ Çe\%ê¡µâH´=Ï2
dÌC< P
¥57¶¯g!5ï¹ySfÿÏO]vê/1ýèÓiwívKÀäÌÜ§æÞüt^åiÃxD°.ß#D¸Ègd2	£xÊCzhV7Ñx5Ì$ ô_IBA&ï©Åwþ÷l|¹¥<D"Au±Z21ëè£'Òó÷-ðfyaï¿uâÛ~ðáá>Ê"¢63í	ÀÇ ÁÌÖ>dfî§ðçÏrRø]"ÝG!Óï-t;ï] @JÙPY!õþûï¹pö/7õÊÀy3.1x5YÂ 	Ð%»«ùËË÷6¼PûÀmÏÜ¿Ë5®NI),ã÷sßLpÿÙ}ìD«Z óçÏÇÏ~ö3Âc<WAZ-et 7ðkÓe¹³}6a!c4\Ïk$¢±(Y¶´çþô^¼%Qtîyg?±eÓÖ1áPØaÃh]Ð[å0eñ~,Ña"öum'êeé/V¯é}ÂÓþ>}Ì¬ÂKfÞ ë5RÀÐF#?»ÈÌ{ëañüÂ?%çÿãåÓï9mù¢gÿh²-ÕuÂuÝ&¸´£ {öìÁ`YRéêsrºfXme;°mgl;VÐÁIB$e#/']»!;'X¢0>he uã5wªó®>úÙçÝ^WW-{X`N¯~ý$D2ìrýõ×ÿ**cÁ×pS \ 3;ÃsrsscL#CIåääÄT÷éÓÇ)**ªgn¡·aÈ°VmÐZ)¥Þ¶u[Ñ'O{ulÿi}n¸èVwë¬<ÕF¡ §çÿózìõ;Í}÷Ý?ûôSÏ\¸ò½2Ë²¬6ëo<Ïk*J÷y½4
äôR!$´ÑÍ.4Æ +ßÀ}ÏÝª¥1­®!¤@¤ÜVPJy!b«0+ìÓmÎ<á">c&HAk®ã¡ ¨Àºfö/ù×ÿðÐ¤a62S=sZ
xâ_ú[§ÈQ,///
vçäyHëÍ/d0É
æ(K T\2 a|ã6,Kª=UÁÉS~9×ôsÓe÷(×$,6"¥
²xÁÇÿàû^¹IÜÿ}^yå/°ìN«BgûmYk­u\O cÂÂçË-_åy À©­­ÉZ»n]ÿE±dÉ	k×®¨µs"X·ý3¬ýË2,_³7]ûðÀiN'£8vâ4òúáfÃÈ ÉØK´°R±Ï2·c(m7çÕÕÕåÕ×Õw¯¨¨@ÐÊj¥¯AUþg><rh¯#¾(Ì-q-2ÄÖZ 0çñ´ýÍÏUd³å¹$öÝ¬úÀÜñÌµò¿øÅ®¼òªyNÊµ¡×A°Ù³°¥Ô
qÚxòÿCD0
êÏ>Z¢ÌÌ`HÃfL]]ÝÉË-;~ÇcÇ)ð9Üg"H@
ÂKç¡ûÓ=qõ¥?F,IÏtü.8nì)bÃ{M´ÖÖ~p0Ê¤Iln¤uKEëù§×~µ,`·è>láð>ãß>bÐäEÁÞ;ÃÁl¡øÔoÏxxùâµg?ôó¿{Y9!;JÀö]Uëé_=zuÅ?¼qîÜ¹h­-Û¶:®1f¿À:0@a'~àû¡µ`6s*..F=Ð¯_?TWWsUUq Ì ³§ÅÁ¼·ÂÇõG* #GNæ&ã\jTåö«M(ã©²#½&!rã}×n[Öwí¶e³_^òH¢K¨ûâsb³ï9ñysçÎýÑ?ß]xÙ?¯JJºÙ±D=dÜp6­W?{ð;Öå?üÁÜîp®ÖÚBtJ¡Ê¯ûK­5²ÃÙ"; ]ñb0<sÐ A¢oß¾ ".//×[·n¥êêjVöHf)ÃÅ¯cØ°DDrÑ«´,¡tSÏÞ»Ïþeþ6idÈÑYUñÓÿôôÝÓyîÞßIØ¡;~øØo°UøàìPvîÞî]w÷ùöS§ÿñO>tc\MDmzÀZ}² è ÀÆh	t-ê¥«Ñü÷Ôü¸qýûöíË555jåÊb÷îÝ"m@»Z^æÓÏ¿üNÊCÆ§µF^^ºäCiãPÃÛ1X0³ÈÌAÒAPJçþïw~oÆ>ê¢5àY¨¬Úcæüî<{âqG>ûâ/ÏafAD@Ülí£c
.°µÖsKÄpë½?Å3¯þ#FÇÅßùïÜ¹Ã¼óÎ;²¶¶¶¡!DÃÒîÃ¥¿ÛÙd2	+,`Á°-Ùá\pkñC4·ú¶u"X*­qÍY·ñôI§H¬1
¡`ÑúùÙ.óÜk¯¾ñ`0HÌÌBÆÚ©Åë!¤ÖN7[-Û¾Ä÷~<D%.ºè"03Þxãu*//@£ÅÌVá3=õ<J+Ø°²D ù/ãÚ¦<Lh«q!Ñ¸ðøkqÊäYT¹§BHãÀIoþó¢¼¾,ñäO¹=ªDÔ±$-¨`c¡lÊ3í*j`c @/À½Ïþ
ÝzãüÙWbé§K±páÂCØ¿e$£AØÝP0ÚÀõRÍ,~ChxDdø FÄ:ÅD@´:=^ëÂhDHFÝÆ6Ó$Ó¾SÇ§Oø>¶íjX±	XqÏ+?¦uÛ>c!¬¬'kñé/þÑÇÍyÁÂñBlà 'é"¶ ×izG©%Àé83ñÛK_ÄôéÓ1zôüýÕ¿cãÆ3þ äCÚt+ìp8 H%R¨OÔù¾â6zfC>nR!%<(£À`hÑèøÈ´ m¦ü6fbÉ¤`ö¹:ãþWoÂ-A
IÚ(!Â¯|øøV®ÿäÄ«N»íÒÂþu±dDJii¿iRBP³UdßL-Þ§ïOÿkI- 4) ;õÔS1dÈPzé¥QVV^¢:oJ)/´ÖîáC&ÂZH¸Á*kw£>YKÚ 	H+Ý	4ø¥ÝK?#PÁÙDÞSUe¹®MDYé>I´ÃÍf!?8@	´4¿Óç\#KgÜ¤o¸H +?¿y+¯{£ËkAU®;ûæg¿?òêoÏ=ãS6Ô'ª-!,ED ã{§R­ÜTÉMÜøÞw70CjL 4ugæÇ'OLÃ3o¿ý¶Øp¾Ë ­u¹WrYA;íèp¼$ð#!áPÊ6  ²(Vë ¶*7©a³ÇÑê$Ð,u	²ÁQYKfSÀ a Y m=\f¦cÚµ¯¥ð½Q{ÆU§Í6}» ðäßaÁª÷rï2³Ð¬RÅuCî~éGæqç·Ç:nI4±,i+!??¿Ã 7<s÷ýÿHXå7Òæ²»ú÷ïß{üøñê/¾°>ÿüsQg9·©\9iÒ¤ßúÖIÆ9vÉ;Þ{ï½ø¿?u#ÌúZ2
HÆxµ6/ÔØ¹¡uñ	Ø¡â¼uìÕ9ZéÓ.Ñ¾NË0f-²`Ø4;é¥=ô(êëgþ¶«4¸RHÄSQ,ýrAC}­1Ú$´§Ý¢»_ºá­Îºûäñ_T¨RZzÔ¨Qzî¶ú°X°õ1ì7ÿ.° `1SlÛ¾hÒ¤I&[K,ÙgåDÔ l4¡ ½a~=''gå-·Þ(¯Ø=äÎ»o¿æ£÷_8{ÚuÁ3ÍÖl§TLÃM)°RÎ,Yó ÞSBXZDRhV(Îë³'ÿ DÈ°ïköÛnpÐf0NÌÍ'oÆÏ]Û?y7rÃH¹80ü BN1¾âÏñÛç =]Ø°DB6¹÷Îÿéßoy÷qcLþ"¬ËÄ¢ö,f2Xk}Ý#PZZÊ.D]]]»K³Æ4*5ô	Àh ãb±X÷é'Lïj!Ké;	s/~öÎ×î °%¡Y£Kn±yméS"»Èú$»¨we2<W0¤/ZÚ(Ô'jV<dûKÐ2DDPÚ®ù;öA,}÷© HE1î°©8kÒåxiñCi©u¼8²§ÜÂ^»éù_]øçcºå÷ªvTP,¤¹Àà@ pòðáÃÅÄÒ¶wÛ"= FNv.Î6#ûac^JõNF½ÞPÁ@9ÅèZPª³9rV4®#+Ý5eæ¥%<ðÀíÏ<÷×YÎæ( Ã¶âoÿ{B]¢°¡Y#d¡Ò^zå&"9éRl)_[>jrKkÙH!¤&j>üúÍÜxÁÃç	?ªrh&"àÒÒÒP·nÝÔÆ­ÚÚÚVÍ!A¢AfyÒyøÁ?B¯®ý¯O!q¨sy¬§ÒFA)OFÜêüËÒûís?²2ùÙ+®¸âíûÿôôýµëË=YÁ0ÒÏ{ÀdØh´ÃI å&0¢ï8XÒB4%l(ã!/«Ë7}hB,1¸çh8n2-÷Ú(\zÒ/ñë§¾H²yÙy¨Ö·7F[RHµq×ç³þ±ôÉ7Ï|ù_êµR
yÀKukd¡qöLëÝ»7,Ë¢mÛ¶¥;Üüá2f@¯Ò>øÉ÷çbüÐ©¨ÜUe_¬Ò`ã$È7ÎüzÒáB!dZ­÷år³º°ã%Ô-O^nìè§ÿúî5o£¹âk¬"ñj,Ùºì ÙÁÁ@£úO@À
6ç40\åøaLã!'Í»×»^¸¦~.ï3R¥óÄ\å 0·üpÇW"''Å]QSSÃHZ¥1~"Ã«<~ë¸ÁSÿQÚ¥ïW9ÎíY 43 ìÖ­Ç¡
¿£M:1F8×;Ù(ÀëABÀ²¤FÉ	²6õ	!°°CFi?^ûxø·ÙE½r/|oñÌÞ}z×ø!Ã;éç°­ vWoÅÃoÞìCõ{çatÈ(åeÙùÍ÷CÈÎ2Í½IDÂÁ\ì¨Úb~ûÂæ¼·jË¢ckê+í 6ºÁÁP¨Å¨~qîä«ðÜGDV8Å]¨¤¤DïÚµKÄb1ÊÌ`BªèùÊG¯¿ú´Û¡u\ýäbfn#fl1¦+îùùùÇãT__ßì¢\9fÄ)¸úÛ·CÀb×IéâÂtûP(å!áDÅÎª-bÕWÅ«_¥ÊúõWÎ¹ìÎßßyï]¡`Xc,!×àË¤fu¥ÈÍÍÞ¹qóÆ£t6IgîDv(×|¸ð½QÓñ¹ Bk1á@j¢Þ-Ï\b÷í6äróµ×=tÚ¦õ=vÄ©&ª2µ@$VSÆý¶¯Á§ÿ¨ØÅ;ÙRöhÉoß±]°æ´Ùéû>Ùðîeß:ü¼{û­p¼$Ñ~(\ÌC­ÏÀ} deeeqee%¹®ÛpcÜ	C¦ãÚ3îÂç_-ÁuoS8mnOúÆyÒM º¾ÕÑrÔD+tã±¼ìÂGôòÒÍgüqÞqS§¯z­\:KB
f!V,{'Öà¹Ö¼U<o?|¸Æäd§°qemìâ©¨ºåKìn]z=wýÌß][U¤÷ÿâ«çß0iØÉFÓ4-ÌÀESb6ïþ"«8¿Ç¥ýý`Í+wôîÓ®·|µE&	øBL(ctñ¢uo\Ð¿Û{VRÙ©<­L»Â´Ò¸8#d2)3Ê`ÆîÃqÙ`ØpYÅzzwåó5BÈ7Ñí%F1 mIÛÙwBÅÒá;N<âÜõýº]Û·ä°p>âñ8Ì[.hpeÊP z¢öÒ-I2XñîVäjÒ;C²9X·cHøÉèÍæQÚià)Oß6ïr+7«`þ<2Ùã%qÂágÍ»çÞ°cÏ«(¯;<å6d)BV0~pÒÍ¸ãÅ+æ=ä¤Fö»ãû_ûùñÂn¦·n+Ú(º»bó:ö»÷ØVP5¦9uüiUÏØÁ¶eYB@©Æ	dØÀ6¾wâÏa[!h­°I9M³µZPfßL8kÏ¼yá.ð´¥=8^JDbUÐ9ùáµ
Øbopýü³rldPZtÙ +@(Ëj%£/åé¥Ìï_ºAÖ'ªÞùýçÏ$uJ¹àÐðÞã?Í
æ.úäËw&1árâ²¥-MDhP÷Ñ<kòzâw¾xó=üþ:ò·/_óÖæ¯69°ÿ`%Åv«ºº	TG+ÆnÜµjø~×&\Gîph:nÆèVeeuÆÇ°tv?¦~ë9I'Öý|3c4Ñ²Íâû¥ÖÊªW[uñ*«>Q+n !¤"ûñÍË^~© e®å½ïípiefY¼fë2±~ÇòÊ_÷à¬¼pA*å%Ò(£dN¨ ãN·dÃH¦`&hm°@$^CÓF­ÇVðÛ¯þ[aN÷ÈOfÞ7U¸ÁËÊ¶X½zöÒ]ºt!fV ä¦Ý«'3´Ò¢e}-­ñ¿G(J¥ "Û¶ÓkØVÓ?)/	¢f³4Sî@QBÈLÑÒkspXÚUTá*¤ð9JiÇKbÜÀ^®ªßU·q×çÒ6kí!=á
x**Ï|
ÙÙGÝóêõô^uÊg%cîæòrÙ³gO ØY½e¢§\´¹?¥MBTh­á8BÙÙ0¼ÏXô,v²ÿòK¾.DmTFÈXå ìx)Ù§xÈÎ^E__²áu,£´Þa¸KØÖ÷¦Ý¤7¯¾ìoï»dp÷#v5ñK+**t2ÝKK	 *"ÛÄu!Ýiî5ûà`!D9úT*P(@À´ë=.íý3ÝA'ß÷=fÍc¬ýÆ8áÙU[¡6VIÆ¨V9*¢Wá@1ëèëðÎªgïùøË7<nøÌ÷÷pÿ¶_!TEwõÙY½9G
µöè r0E TF£QÃaÃ ¼p?þù/Òÿ"I¤bÕ{ò;Æè«·.OíÍÅ¾<&ÔÅkhâàôøÓsüàG«êÊ­ÿÏo=G××Gëíü¼| (ñ*IßGæbÕzl[À÷E+ kjj9??ßïµmµ·µ²éËæ7ØñRV^¸(uXé/.Ýô´ÖÛá,fF<Y/Ïw¹ÊþØû7ÿ¹OñÐºzyOM,ËÖ$0F÷Wþú¼÷ÃföÍÀòÊÊJ!¸¸k×}ö²C¯ß$2Ú¥Æö?áoeUkywM%ÈfÕÍp0YLúþªrÍÅ¯-ÿËìñ¦?§ µö34óþjÐ¾nÝÑÁéxïÂªª*$	Ñ£´@ë¡ÂLløü)× `a¸mÃÜ÷!°B~ê?}±§taHÅ¨ñ9¡V½?å¤QKAm¯XÉT%¹=Å9ãçàOÿðà	#Î¿8lgU¦d	ÄÙÑFktÆË`Vn± d2±cÇ~\YYY±cÇn=J{0¨å	Bf[íGÎBN(¿!6ÚfãÌHº±o¢Ö¸ßW¡dN0_èyôÓ+·}8åØ!3ÁhnÅªODhLïãÌ¶ê/sß_÷ÂoVÐÆ¢  \Y¡´mw`BÛ®JN&rèÐ¡5}úôywÅ³ô`,[È½ohtýÄ°Ñr~ä03ÃhtÊMbL¯cÿþÉæ7~óUåÚÂ]G²ã%¨=Ý`ÄSubú°¸<òÕaÛj6dME9¥»²{8 L{É{×Èh´ð-
À_vÃá0.¼ðÂ§ËÊÊL&I´ùþÝQ²*[ßòCsÆNy	Ù5§wy·¼¾¯­ØúÀdÑÐí¥=036ú2dó ºdl°ÈÒµ[Eµ} BS__sÎ9ç­kÖ®¡PÈ|ÕCA¥F)0aTÏcÞPþ"ñ*"éôm+CÆ I7¬1â» ¬n_,(­«]× Ì9sîùtéR8®ÃØEÿÿeû¾YbLÒã°±ï1Ìúå	I¶Qzo§Gk&M,UÁ%cÅQýfà³­ï\¾;RVbQÐ;è Bh ¸â+4hÐ'áIÛ²Òþ?·|«CRV©iëiIofsàíPëúË>¶dF®av=ÇÊtqûxáóBkmæq!ÄSuâgéî¹Î_uÿCJ{`ã+¸=/²°°ÐÜvÛm?÷{ègÎ´7¬3§'QÀ
"`é×XQ¦mÍlÉw1½¤m[ÚI$HIÂ¤Ïä×ò·Ñ¤ó¿ÓÙMQÊÅèÇ=¿»~.¯Ûj	¬[q]¶V´Öð'OyªOÖ¹`Ã³ÿkQZY[îMÒ®ëÊ³Ï9û	'¼òèwùÆgOyñdÂ¶m¥ð3úòö¿]IR0öatH :Z¹úÕµjËbiX§ÅàÒjõÏ_éH²£Ý¶	$Üx6^ÙÏ_ÕÏ¶ýCZ Hp4f½öç¯be\1¨øH3¶×IpuÒ?ÔÍ0°µIº	ê7èóì@þGëÊ?zìÀsRIÙ¶¢ÚN!ÛÎ'¿çµ×Z  	âIDAT¯þãí¥¹>Þýè	7*í;OÁ n?àß@ée1fôÙ|üÉ«¬Ö{pw½rÅçàj Ël,«Xìçi¯íP&ÛàNO9ïÅú|ø!ÇL¥ðiY¿i?ÛÈØzõ ¦ì®Ù:
ÍûAðÏÜútkå6æBÎ©GJÅa#7³ý!=¤ä¨¿®¯X:u|ïN;:Hq§ú7Gõ>E¼½þñ¿t	uPÝs·§û<âÁ0âàÌ fN 8Oeõ}ûô6vì8|öÙ²ïÑ<f®$Ê¶ÖÈ°QZ´w6gæQñ 6;ÄöÖ¾ffßeÃRHX¶		'B0ØÁ`ãx),<âÕå;Þ©Ü^³¡¤waìªä>lâ¦D¥êÅØ'é]õ{¿±îÇgùÙI AC·ëkhä`nÝnv±?ü$Ø=BÐ)K~²Åu4h3/&¢Þ6llÓ±Àß)MÂÀÁjá´Òf;=Kþ31Rp]wb¦°6ì¸IYê±§kv¬­X×í³W9òø³£Sßzó¼[%ÖÊÚç½ªí`CóyÔx ©N\FDÓV¯^½6 gæ ¿YÑn­@meLãÜt´"ã¸þisé<äæEÃÃÆ?½­n-êÕÎcüû Ì²¦øÙT½üÆ/Ê?:- ²§=k_÷·UW^yÇw 6mÚ Zk-y+SUUõ,  ® ð$|Ùýu fÀI¥Ò®ÊÖü¾lR^½ò}À<ÿ¯jVÞuñ#:¾Lûp¢è3ãzE[_øsQ¨çÂpéVO¥ÚÇÓF ,ËÖ/Æ²eË°xñbTVV¦;Æ¾LÑÉÌ<7}oÀ ÜÌÑ½ß(Ê¾r]{fO¹VXæé>ùÃÿ²z)VF·y}{H;Q1¢xî7¼Û;[{2éÅ%³`e4uÑôüã¢Ìï)H 7`sú»¬p&¶oÐþòì@)û¼VªjRúçþ·äN·*¾Ã,Xë6®ß<vTRNì1SiÊ¢mÏß% Ùh%[»¾-¼ Z9´/3òÊðÃÌ ÐÀË ^0ß@ ÉdÃFë¶þÆRIQî·>Û.xsírK£µêtðÀO9d[Çö:Oï®¿aÍgÙNËãN:AßðÏh¾þFï'áÛ§Á·/§ýVjÈÖº9Àí¸RDl¡Oî¨g·Ö­FÒÃtÚí	J¤Üº{#JNÆ·ÜÝ|j-(Ñ®«²¤ÑhJm¿L/ Xà~ ý\/à¯ ÿ©ésç fÁVã¨zçx5¥cåñÍRÀê°ë²µ|®¤¥yãt¯w?ÿxÒ`Èh£h_®ÊY>^&	`ïà U ®°À+ ²Bs®þÚíy2GífvcåÈ¢ê®á~ûªnXCïOð ÍPöÑ¿ø{°ÑF¶äà¾¡!3²9t_8Àéðåò) >ð%|wg!¹ú?l6MÏªj/x  CÆÓ.$YåÉ¯u«¡µÜé?IXXãº¡÷$Ë®^WóáÅJiÏ:TÜ2@gá$|pÏÐÀw lpÝ ^pl4;sÿ×J9k·½P ±«¬«ýèäàÀw-
,Ý[/[ßÑa.ÖÇK"WÑ]NÂºEÜß4Zr@)­e[Yb3Ë0¡ñÔ¹* O{ÏKv'U NVÆ1è	¿ño!f£²iÓ´aDÀÖØÊîÝWÈ¿´(Ðëåíñ/ gnûÞ6¥^¡ºWxDîòWOzõY0¤µRÔVVeã¯dY<¼ãÆèPfùføQWÒ p<o8@9 Øßû·ä<vINoj×{+Åd£ÆÙ«Ú¼^áÑ»¹ôzqYäÅ_GÝ¡\»++öè@ÓS&!æLU·ü×ÿ0¶à¬KZ¤RÍ¨ÙrdÎM<ÔìGjøÚöz Âý ¯M P`{ºTc¯ÃúQzkz>$3Ã´â5p#ùÁI£i(&È%C"wÁÎäÚS©Æ°t§5²­Q¹3ôÇg/Ùýð³aÙÇ?È0Ç@à¡CböìÙÈÍÍE[DÊhßjº»BÃ÷mnò}6øgOæÁù_BÌª×3¶/JÁ
6d;Cd"¤E¡Eè8ì]ÎSûj¸ê@I#aÙ'`müÿ[ {~f!´[Ä, 8æcpÌ1Çp£ûI{ÜEïâéò/'­¤%ðêâÆw@A8Fø¿FÛ&5'l<¤ÐÕøÆÖÔg»«m¥ÅvVìð2 bÔU2=;ëâ$E¸!*9£ã_Á¹¥4W°þeòØ8 ­ý~²§Sv:D¬àÊÔæË/ív×]U(ûiÍÆ:XÛx$D?{éaõºü~[Ø³<ôZ@æ¿VVIKú7)Yþ¤R4<@&\ØQb04)tæmv^Pi#ÔªßòU?Ëh£¾0ÿ¸ÐÀûÀàc«¾Ö¨~]ÈOÐñ3·lh#h ]B>z,ËªÔFÎ ÚJl%ûÉàn S2gT»èJlaxíËà½Á°*ýÝc6ëJÀ>hcï#4Ð¸"nmU>&H æ¿ ·KþÂò¢¨ÄWp¹ðÖ66	Ñõ¥=ØxËóy¶lfí¼¶­ Ü¾sÛ9 þ/ÀíPÆõØHfu2¬¶- -JGÒ¨¬
ocÓU |ï[Ø^={-Ðì'iþKmã¸ÇãM~_i¿-"tH}íÌFegg`0ø_ÿ9ýP·Á ø¿ wò8êÀ	gVÿ|Isüè    IEND®B`GIF89a    °Ç   ,       D ;GIF89a	 ,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    	 , ÿ@P±É`H$!%Cq Ve2X­ÌJ(Ä +32$ÀÆ ¼kvä-Ëçõu*"}ã|}|~q("$f'l(&&$r&! )¢¤{¨£¥r­ª°©¯±¯¬´¦·»º³®«§¾¶ÃÂÀ¿²¹ÇÄËÆ²ÌÉÎµÒ½Í¼ÔÈÓ×Ð¸ÙÝÕÏÙÊâÜßãçæê¾äÛÅëÇíáîÖìéïøñ÷õüÑðåùü¤Pß?ÇÛBmåAÎáÀ%VÜî!Çk÷Ø/áÄ;^¤¨²$Æ#Mf)fÍ(WÎLæKçÒ° I)L:eD¡Cµ´x*4U¨h 
%A«£^ÁNKb¬Ùe§X± ´k»x!ÁÖí2tÝÖ	 !¯5tÛæéÀ]$¬´%Xíâ.i[¬]Y­ÊfEëõkg`µ:zëçÒ;£}ºµj×aaM¶é×¸cç½»vïÛºóî8ðáÈ'?®¼9óç©G_>Ýyuè¬_ß]zwêß­Ç¾º¼mîæµG~½ûôÞá/>ùööÙ«Ïÿ¿ÿýÿÅà|ÖWà} v ;GIF89a,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    , ÿ@pH,È¤rÉl:Ð¨tJ­Z¯Ø¬vh<¬pkL.Ïè´zÍn»ßð¸|N¯Ûïø¼~ÏwVa+ *)^,*ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃ¶)'ÆÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæÚ¥("ðñòóôõö÷øùúûüýþÿ 
H° ÁòK"RHH±¢Å3jÜÈ±£Ç CI²¤É(Sª\éÅu&@ Á²¦Í8sêÜÉ³§Oÿ(Â±DÐ£H*]Ê´©Ó§P£JJµªÕ«X³jÝÊµ«×¯S84± hÓª]Ë¶­Û·pãÊK·®Ý»xóêÝË·¯ß¿Ó} âDÌf(^Ì¸±ãÇ#KL¹²åË3kÞÌ¹³çÏ Cm¹ðCÄHXÍºµë×°cËM»¶íÛ¸sëÞÍ»·ïßÀN÷ÃJ Á®¹óçÐ£KN½ºõëØ³kßÎ½»÷ïàÃO¾<v1+_.³½û÷ðãËO¿¾ýûøóëßÏ¿¿ÿÿ (à_YÉ@Ár5èàF(áVháf¨ávèÿá (â$¨a¤H,¶èâ0Æ(ã4Öhâ	*¨"<öèã@)äDiäH&©äL6éäPF)åT&©\;V©å\véå`)æZ^%	d¦©æl¶éæpþhfqÖiçxæ©çsRæ*è ÂÙç&ªè¢6:ä¡F*é¤Æ	i¥fªé¦O^Êé§ Ê©§¢jê©êª¬¶Ê¦ª®Æ*ë¬SÂJë­¸æ*¤­ºöêë¬¼þ*ì°¥Kì±ÈVjl²Ì6è²ÎF+-ÐNkíµkVí¶Üv©m·àÛ©tkî¹Q~ÿîºìò¨n»ðûn¼ôr;o½øN{o¾ü2»o¿ ûoÀë:pÁK®	7íÁGl*ÄWü)Åg)Æw)Ç¬(È",(É&§'Ê*·léÂº,3¥,Ïl35ß¬30ïìó³=ÿ,t 9m´E­´A/ítI?-5QOm5U_=uÖZ?Íu×KöÑb=tÙfÿvÚ;¯ÍöÍn¿=sÜr»LwÝ*ß·Ézï-rß~{xàN¸Å.qâ;Ìxã	?yÁOpå÷yæùnÎy½oè¢·Kzéëú¹ª¯.në®{ìö6Mÿ»Ö³ß~mîºëk{ïRó¼³ÂïïïÆ+]|òÇ.Ï¼ÀÈ?/´óÒûJ}õG½Î×ok÷Þ+%Ãá«­}ùv~Þê¯ÏwûîÿüÏOáößxþú/Îÿû #'ÀR®¼¨¹2°s| è"(ÁÑQ°¦» S§Á²®|C(»°vãÙ		ÂF|.dc82ÒPZ3¼aªl¨Ãfå°Dã!õÃ!ê©F¤(,$2±NN|¢¡(Åìµ°L!¶ÈÅ.zñ`£ÇHÆ.zaH£×ÈÆ6ºñp£çHÇ:ÚÿñxÌ£÷ÈÇ>úñdÇ@ L¤"ÉÈF:ò¤$9  (8&ÉÉNzò ¥(G©FB^²!Ë¨ )WÉÊVºò°l¤)1wÄò¸Ì¥.wÊYºäà¥0IÌbó¾|ÉHpÌf:óÐìepJ±}È¦6·ÉÍnzóà§8û0 Â%"¸æ8×ÉÎvºóð§<ÉPÎQ`ò%×$>÷ÉÏ~úó ¨@JÐô M¨BÊÐ:ô¡¨D'ZPKF Ö¼&16ÊÑzô£ ©HGJRb ÷Lç5ÏÁÒºô¥ÿ0©LgJÓ#(e>¯Óúô§@ªPJÔ¢õ¨HMªRÊÔ¦:õ©PªT§JÕª&5;%U·ÊÕ®zõ«`«XÇJV«ÂC§ÑjY×ÊÖ¶ºõ­p«\U´À¦xÍ«^÷Ê×¾úõ¯ÐÀi)$ô°M¬bËØÆ:v,à²Í¬f7ËÙÎzö³ ­hGKÚÒö´¨M­jWËÚÖºöµ°­*$ÛSPô¶¸Í­nwËÛÞúö·ÀÅm + â¸ÈM®rËÜæ:÷¹ÐE®?±9ÏêZ÷ºØÍ®v¿9î"ºÛ¯xÇKÞòbÑLÿ¯z×Ë^A¢·½ð¯|ç÷Ò÷¾øÍ¯0í«ßþú÷¿¡ä/Là»×ÀN°ï(à;øÁ	n0'LaýJ¸ÂÎ0{/¬á{Øþ°G|ËøÄ(¥SÌâCrÅ.±	ãÛøÆv¬1wÌc6ê¸Ç@ÞñLd¹ÈHNñÌd/¹ÉPÎð£LeO¹ÊXp·|â+sùËýõ2ÇL_1ùÌí53×M5³ùÍÇt3ç¼_:ÛÙÂwÎsõÌgøÊ¹Ïp ýÌ?úÐ/F´¢ë¼èFãÒÐt!-éJãÒÎô1­éN»ÓuÿA-êPºÔ>5ª3­êUWºÕ®4¬cÝèYÓZÑ¶¾õ¡s­ëAóº×þ5°ù,ìaç¹ØÆ¶3²=çe3ûÍÎ~ö£-í3S»Úc¾6¶¿¬ímo¹ÛÞÆ2¸ÃMåqÊæ>7Ó­n$³»ÝD~7¼,ïyó¸ÞöÆ1¾ómã}óÛÈÿvµ¿Þâ\É/µÁNâ3ÜÉ÷´Ã#ÞáS\ÊguÆ-mñO¸ã0ÈC¾à\Ë'_´ÉS^à³|À.ùc.ó0×Ð4¿9~s®ó=÷¼Ï<ÿy|.ô4]ÏD?ºz®ô67]ÙO§3Ó£ÞÌ©SÄWvÖÙl>õ­3Úëdî:Øu)ö±?ÚìÙF;Ë®öW²½í­|;ÜW)÷¹²îvtÞË½w¾÷Ý|à×=xÂÞÝA  ;<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

//-- We must change the returned mime type (default is text/html)
//-- And we must do it before any output

header('Content-type: text/css');

//=============================================================================
?>

/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */

DIV.tabs
{
   float            : left;
   width            : 100%;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/bottom.gif'); ?>') repeat-x bottom;
   margin-bottom    : 0px
}

DIV.tabs UL
{
   margin           : 0px;
   padding-left     : 10px;
   list-style       : none;
}

DIV.tabs LI, DIV.tabs FORM
{
   display          : inline;
   margin           : 0px;
   padding          : 0px;
}

DIV.tabs FORM
{
   float            : right;
}

DIV.tabs A
{
   float            : left;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/right.gif'); ?>') no-repeat right top;
   border-bottom    : 1px solid #84B0C7;
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none
}

DIV.tabs A:hover
{
   background-position: 100% -150px;
}

DIV.tabs A:link, DIV.tabs A:visited,
DIV.tabs A:active, DIV.tabs A:hover
{
       color: #1A419D;
}

DIV.tabs SPAN
{
   float            : left;
   display          : block;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/left.gif'); ?>') no-repeat left top;
   white-space      : nowrap; padding-left:9px; padding-right:9px; padding-top:5px; padding-bottom:5px
}

DIV.tabs INPUT
{
   float            : right;
   display          : inline;
   font-size        : 1em;
}

DIV.tabs TD
{
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none;
}



/* Commented Backslash Hack hides rule from IE5-Mac \*/
DIV.tabs SPAN {float : none;}
/* End IE5-Mac hack */

DIV.tabs A:hover SPAN
{
   background-position: 0% -150px;
}

DIV.tabs LI#current A
{
   background-position: 100% -150px;
   border-width     : 0px;
}

DIV.tabs LI#current SPAN
{
   background-position: 0% -150px;
   padding-bottom   : 6px;
}

DIV.nav
{
   background       : none;
   border           : none;
   border-bottom    : 1px solid #84B0C7;
}
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

// This is needed because the file must be able to run as plain file

// <PLAIN_FILE> //---------------
require(dirname(__FILE__).'/../classes/PHK.php');
require(dirname(__FILE__).'/../classes/PHK_Proxy.php');
require(dirname(__FILE__).'/../classes/PHK_Stream.php');
require(dirname(__FILE__).'/../classes/PHK_Stream_Backend.php');
require(dirname(__FILE__).'/../classes/PHK_Cache.php');
// </PLAIN_FILE> //---------------

require(dirname(__FILE__).'/../classes/PHK_PSF.php');
require(dirname(__FILE__).'/../classes/Automap_Creator.php');
require(dirname(__FILE__).'/../classes/PHK_DataStacker.php');
require(dirname(__FILE__).'/../classes/PHK_ItemLister.php');
require(dirname(__FILE__).'/../classes/PHK_Creator.php');

//============================================================================

//-- Check PHP version - if unsupported, no return

ini_set('display_errors',true);
PHK_Mgr::php_version_check();

//---------
// <Automap>:ignore function send_error

function send_error($msg,$usage=true)
{
if ($usage) usage($msg);
else echo "** ERROR: $msg\n";
exit(1);
}

//---------
// <Automap>:ignore function usage

function usage($msg=null)
{
if (!is_null($msg)) echo "** ERROR: $msg\n";

echo "\nUsage: <action> <params...>\n";
echo "\nActions :\n\n";
echo "	- build <PHK file> <PSF file>\n";
echo "	- help\n\n";

exit(is_null($msg) ? 0 : 1);
}

//---------

try {

if (PHK_Util::is_web())
	throw new Exception('This package is supposed to be run in CLI mode only');

array_shift($_SERVER['argv']);
$action=(count($_SERVER['argv'])) ? $_SERVER['argv'][0] : 'help';

switch($action)
	{
	case 'build':
		if (count($_SERVER['argv'])<3) send_error('build needs 2 args');
		$phk_file=$_SERVER['argv'][1];
		$psf_file=$_SERVER['argv'][2];
		array_shift($_SERVER['argv']);array_shift($_SERVER['argv']);array_shift($_SERVER['argv']);
		PHK_PSF::build($phk_file,$psf_file,array_values($_SERVER['argv']));
		break;		

	case 'help':
		usage();
		break;

	default:
		send_error("Unknown action: '$action'");
	}

} catch(Exception $e)
	{
	if (getenv('PHK_DEBUG')!==false) throw $e;
	else send_error($e->getMessage(),false);
	}

//============================================================================
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

if (!class_exists('PHK',0))
	{
	//-- When extension is not present, the first package loads the PHP
	//-- ('slow') runtime code.

	$_phk_fp=fopen(__FILE__,'rb');
	$_phk_buf=fread($_phk_fp,241);
	fseek($_phk_fp,(int)(substr($_phk_buf,212,11)),SEEK_SET);
	$_phk_size=(int)(substr($_phk_buf,227,11));

	$_phk_code='';
	while (strlen($_phk_code) < $_phk_size)
		$_phk_code .=fread($_phk_fp,$_phk_size-strlen($_phk_code));

	fclose($_phk_fp);

	eval($_phk_code);

	unset($_phk_code);
	unset($_phk_fp);
	unset($_phk_buf);
	unset($_phk_size);
	}

//------

$_phk_cmd=null;
$_phk_ret=0;

PHK::prolog(__FILE__,$_phk_cmd,$_phk_ret);

eval($_phk_cmd);

//var_dump($_phk_cmd);
//var_dump($_phk_ret);

return $_phk_ret;
?>
